[{"title":"Java 中的 Protected 修饰符","date":"2017-09-11T02:37:52.000Z","path":"study/codding/programming-language/Java/grammer/keywords/protected/","text":"概述 protected 方法的调用是否合法（编译是否通过），关键是要看 调用者所在的类与被调用的 protected 方法所在的类是否在相同的包下，若相同，则合法；否则，不合法。 在子类内部，任何情况下都可以访问父类的 protected 方法 栗子1234567891011121314151617181920212223242526272829303132// pacakge p1;public class Father1 &#123; protected void f() &#123;&#125;&#125;// package p1;public class Son1 extends Father1 &#123;&#125;// package p2;public class Son2 extends Father1 &#123;&#125;// package p1;public class Test1 &#123; public static void main(String[] args) &#123; Son1 son1 = new Son1(); son1.f(); // Compile OK. Son2 son2 = new Son2(); son2.f(); // Compile OK. &#125;&#125;// package p2;public class Test2 &#123; public static void main(String[] args) &#123; Son1 son1 = new Son1(); son1.f(); // Compile Error. Son2 son2 = new Son2(); son2.f(); // Compile Error. &#125;&#125; 更有趣的栗子 ### $\\text{栗}_1$ 12345678910111213// package p1;public class MyObject1_2 &#123;&#125;// package p1;public class Test1_2 &#123; public static void main(String[] args) &#123; MyObject1_2 myObject1_2 = new MyObject1_2(); myObject12.clone(); // Compile Error. Test1_2 test1_2 = new Test1_2(); test1_2.clone(); // Compile OK. &#125;&#125; 这里 `myObject1_2.clone` 是继承自 `Object` 的 `protected` 方法，虽然 `Test1_2` 也是 `Object` 的子类，但是 `Test1_2` 和 `MyObject1_2` 并不存在直接的继承关系，并且由于 `Object` 和 `Test1_2` 不在同一个包中，因此编译不通过。 而由于 `Test1_2` 继承自 `Object`，因此可在 `Test1_2` 内部任意调用从 `Object` 继承来的 `protected` 方法。 ### $\\text{栗}_2$ 12345678910111213141516171819202122232425// package p1;public class MyObject1_3 &#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;//package p2;class MyObject2_3 extends MyObject1_3 &#123;&#125;// package p2;public class Test2_3 extends MyObject1_3 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject1_3 myObject1_3 = new MyObject1_3(); myObject1_3.clone(); // Compile Error. MyObject2_3 myObject2_3 = new MyObject2_3(); myObject2_3.clone(); // Compile Error. Test2_3 test2_3 = new Test2_3(); test2_3.clone(); // Compile OK. &#125;&#125; 和 ***[$\\text{栗}_1$](#example_1)*** 中不同，`Test2_3` 继承自 `MyObject1_3`，**因此 `main` 中调用的 `clone` 都可追溯到 `MyObject1_3` 所在的包 `p1`**，以此为前提，很容易分析: 1. `myObject1_3.clone()`: > 因为 `Test2_3` 在包 `p2` 下，和 `clone` 所在的包不同，因此编译不通过。 2. `myObject2_3.clone()`: > 虽然 `MyObject2_3` 和 `Test2_3` 在同一个包下，但由 **[前提](#tmp_asd1)** 很容易分析出编译不通过的原因。 3. `test2_3.clone()`: > 在 `Test2_3` 内部调用继承来的 `protected` 方法都是合法的。 ### $\\text{栗}_3$ 123456789101112131415161718// package p1;public class MyObject1_3 &#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;// package p1;public class Test1_3 extends MyObject1_3 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject1_3 myObject1_3 = new MyObject1_3(); myObject1_3.clone(); // Compile OK. Test1_3 test1_3 = new Test2_3(); test1_3.clone(); // Compile OK. &#125;&#125; 与 ***[$\\text{栗}_2$](#example_2)*** 中不同，`MyObject1_3` 和 `Test1_3` 在一个包下，所以可以调用 `MyObject1_3` 的 `protected` 方法。 ### $\\text{栗}_4$ 12345678910// package p1;public class MyObject1_4 extends Test2_4 &#123;&#125;// package p2;public class Test2_4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject1_4 myObject1_4 = new MyObject1_4(); myObject1_4.clone(); // Compile OK. &#125;&#125; 因为 `MyObject1_4` 的 `clone` 继承自 `Test2_4`，所以 `clone` 方法和 `Test2_4` 在相同的包下，因此编译通过。（注意与 ***[$\\text{栗}_1$](#example_1)*** 对比） ### $\\text{栗}_5$ 123456789101112131415// package p1;public class MyObject1_5 extends Test2_5 &#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;// package p2;public class Test2_5 &#123; public static void main(String[] args) &#123; MyObject1_5 myObject1_5 = new MyObject1_5(); myObject1_5.clone(); // Compile Error. &#125;&#125; 与 ***[$\\text{栗}_4$](#example_4)*** 不同，`MyObject1_5` 覆盖了父类的 `clone` 方法，因此在调用 `MyObject1_5` 的 `clone` 方法时，实际上是被调用的方法所在的包为 `p1`，而 `Test2_5` 所在的包为 `p2`，因此编译不通过。 Hint参考链接 Java 访问权限控制：你真的了解 protected 关键字吗？","tags":[{"name":"java","slug":"java","permalink":"http://littleclown.github.io/tags/java/"},{"name":"keyword","slug":"keyword","permalink":"http://littleclown.github.io/tags/keyword/"},{"name":"protected","slug":"protected","permalink":"http://littleclown.github.io/tags/protected/"}]},{"title":"概率论基础（1）","date":"2017-04-14T05:59:20.000Z","path":"study/math/probability-theory/basis/1/","text":"期望 设离散型随机变量 $X$ 的分布律为： $\\displaystyle P\\lbrace X=x_k\\rbrace = p_k,\\hskip 1em k=1,2,\\cdots$。若级数 $\\displaystyle \\sum_{k=1}^\\infty x_kp_k$ 绝对收敛，则称级数 $\\displaystyle \\sum_{k=1}^\\infty x_kp_k$ 为变量 $X$ 的数学期望，记为 $E(X)$，即 $\\displaystyle E(X)=\\sum_{k=1}^\\infty x_kp_k$ 设连续性随机变量 $X$ 的概率密度为： $f(x)$。若积分 $\\displaystyle \\int_{-\\infty}^{+\\infty} xf(x)dx$ 绝对收敛，则称积分 $\\displaystyle \\int_{-\\infty}^{+\\infty} xf(x)dx$ 的值为随机变量 $X$ 的数学期望，记为 $E(X)$ 定理设 $Y$ 是随机变量 $X$ 的连续函数：$Y=g(X)$ 如果 $X$ 是离散型随机变量，它的分布律为 $P\\lbrace X=x_k\\rbrace = p_k,\\hskip 1em k=1,2,\\cdots$；若 $\\displaystyle \\sum_{k=1}^{\\infty} g(x_k)p_k$ 绝对收敛，则有 $$\\displaystyle E(Y)=E\\big[g(X)\\big]=\\sum_{k=1}^{\\infty} g(x_k)p_k$$ 如果 $X$ 是连续型随机变量，它的概率密度为 $f(x)$，若 $\\displaystyle \\int_{-\\infty}^{+\\infty} g(x)f(x)dx$ 绝对收敛，则有$$\\displaystyle E(Y)=E\\big[g(X)\\big]=\\int_{-\\infty}^{+\\infty} g(x)f(x)dx$$ 性质设 $C$ 是常数，$X,Y$ 是两个随机变量， $E(C) = C$ $E(CX)=CE(X)$，$E(CY)=CE(Y)$ $E(X+Y)=E(X)+E(Y)$ 若 $X$ 和 $Y$ 相互独立，则 $E(XY)=E(X)E(Y)$ 设二维随机变量 (X,Y) 的概率密度为 $f(x,y)$，其边缘概率密度为 $f_X(x)$，$f_Y(y)$ 所以，\\begin{align} E(X+Y) &amp;= \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} (x+y)f(x,y)dxdy \\ &amp;= \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} xf(x,y)dxdy + \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} yf(x,y)dxdy \\ &amp;= E(X)+E(Y)\\end{align}又若 $X$ 和 $Y$ 相互独立，则\\begin{align} E(XY) &amp;= \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} xyf(x,y)dxdy \\ &amp;= \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} xyf_X(x)f_Y(y)dxdy \\ &amp;= \\left[ \\int_{-\\infty}^{+\\infty} xf_X(x)dx \\right]\\left[ \\int_{-\\infty}^{+\\infty} yf_Y(y)dy \\right] = E(X)E(Y)\\end{align} 方差设 $X$ 是一个随机变量，若 $E\\big\\lbrace [X-E(X)]^2 \\big\\rbrace$ 存在，则称 $E\\big\\lbrace [X-E(X)]^2 \\big\\rbrace$ 为 $X$ 的方差，记为 $D(X)$ 或 $Var(X)$。实际上，方差就是随机变量 $X$ 的函数 $g(X)=(X-E(X))^2$ 的数学期望。 若 $X$ 是一个离散型随机变量，且 $X$ 的分布律为： $\\displaystyle P\\lbrace X=x_k\\rbrace = p_k,\\hskip 1em k=1,2,\\cdots$。则 $\\displaystyle D(X)=\\sum_{k=1}^{\\infty} \\big[ x_k-E(X) \\big]^2p_k$ 若 $X$ 是一个连续型随机变量，且 $X$ 的概率密度为： $f(x)$。则 $\\displaystyle D(X)=\\int_{-\\infty}^{+\\infty} \\big[ x_k-E(X) \\big]^2f(x)dx$ 定理设 $X$ 是一个随机变量 $\\displaystyle D(X) = E(X^2)-\\big[ E(X) \\big]^2$ \\begin{align} D(X) &amp;= E\\big\\lbrace [X-E(X)]^2 \\big\\rbrace = E\\big\\lbrace X^2 - 2XE(X) + [E(X)]^2 \\big\\rbrace \\ &amp;= E(X^2) - 2E(X)E(X) + [E(X)]^2 \\ &amp;= E(X^2) - [E(X)]^2\\end{align} 性质设 $C$ 是常数，$X,Y$ 是两个随机变量， $D(C)=0$ $D(CX) = C^2D(X)$，$D(X+C) = D(X)$ $D(X)=0$ 的充要条件是 $X$ 以概率 1 取常数 $E(X)$，即 $P\\big\\lbrace X=E(X) \\big\\rbrace=1$ $D(X+Y) = D(X)+D(Y)+2E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace$ 若 $X$ 和 $Y$ 相互独立，则 $D(X+Y)=D(X)+D(Y)$ \\begin{align} D(X+Y) &amp;= E\\big\\lbrace [(X+Y)-E(X+Y)]^2 \\big\\rbrace \\ &amp;= E\\big\\lbrace [(X-E(X))+(Y-E(Y))]^2 \\big\\rbrace \\ &amp;= E\\big\\lbrace [X-E(X)]^2\\big\\rbrace + E\\big\\lbrace [Y-E(Y)]^2 \\big\\rbrace + 2E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace \\ &amp;= D(X)+D(Y) + 2E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace \\\\end{align} 若 $X$ 和 $Y$ 相互独立，则\\begin{align} &amp; E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace \\ =&amp; E\\big\\lbrace XY-XE(Y)-YE(X)+E(X)E(Y) \\big\\rbrace \\ =&amp; E\\big\\lbrace E(XY)-E(X)E(Y)-E(Y)E(X)+E(X)E(Y) \\big\\rbrace \\ =&amp; E\\big\\lbrace E(XY)-E(X)E(Y) \\big\\rbrace = 0\\end{align} 故 $D(X+Y)= D(X)+D(Y) + 2E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace $ 协方差$E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace$ 称为随机变量 $X$ 和 $Y$ 的协方差，记为 $Cov(X,Y)$，即$$Cov(X,Y)=E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace$$ 而 $\\displaystyle \\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)}}$ 称为随机变量 $X$ 和 $Y$ 的相关系数 性质 $Cov(X,Y)=Cov(Y,X)$，$Cov(X,X)=D(X)$ $Cov(X,Y)=E(XY)-E(X)E(Y)$ \\begin{align} Cov(X,Y) &amp;=E\\big\\lbrace [X-E(X)][Y-E(Y)] \\big\\rbrace \\ &amp;=E\\big\\lbrace XY-XE(Y)-YE(X)+E(X)E(Y) \\big\\rbrace \\ &amp;= E(XY)-E(X)E(Y)-E(Y)E(X)+E(X)E(Y) \\ &amp;= E(XY)-E(X)E(Y)\\end{align} 若 $a$ 和 $b$ 是常数，则 $Cov(aX,bY)=abCov(X,Y)$ $$Cov(aX,bY) = E(aXbY)-E(aX)E(bY) = abE(XY)-abE(X)E(Y) = abCov(X,Y)$$ $Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$ \\begin{align} Cov(X,Y) &amp;= E\\big\\lbrace (X_1+X_2)Y\\big\\rbrace - E(X_1+X_2)E(Y) \\ &amp;= E(X_1Y)+E(X_2Y) - E(X_1)E(Y) - E(X_2)E(Y) \\ &amp;= \\big\\lbrace E(X_1Y)-E(X_1)E(Y) \\big\\rbrace + \\big\\lbrace E(X_2Y)-E(X_2)E(Y) \\big\\rbrace \\ &amp;= Cov(X_1,Y)+Cov(X_2,Y)\\end{align} 矩设 $X$ 和 $Y$ 是随机变量，$k\\in N^+$ 若 $E(X^k)$ 存在，称它为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩 若 $E\\big\\lbrace [X-E(X)]^k \\big\\rbrace$ 存在，称它为 $X$ 的 $k$ 阶中心矩 若 $E(X^kY^l)$ 存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩 若 $E\\big\\lbrace [X-E(X)]^k[Y-E(Y)]^l \\big\\rbrace$ 存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩 协方差矩阵设 $n$ 维随机变量 $(X_1,X_2,\\cdots,X_n)$ 的二阶混合中心矩$$c_{ij}=Cov(X_i,X_j)=E\\big\\lbrace [X_i-E(X_i)][X_j-E(X_j)] \\big\\rbrace, \\hskip 1em i,j\\in N^+$$都存在，则称矩阵\\begin{align} \\mathbf C=\\left(\\begin{matrix} c_{11} &amp; c_{12} &amp; \\cdots &amp; c_{1n} \\ c_{21} &amp; c_{22} &amp; \\cdots &amp; c_{2n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ c_{n1} &amp; c_{n2} &amp; \\cdots &amp; c_{nn} \\ \\end{matrix}\\right)\\end{align} 为 $n$ 维随机变量 $(X_1,X_2,\\cdots,X_n)$ 的 协方差矩阵。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://littleclown.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率论","slug":"概率论","permalink":"http://littleclown.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"线性代数基础之矩阵(1)","date":"2017-03-09T04:18:44.000Z","path":"study/math/linear-algebra/matrix/1/","text":"【定义1】 由 $m\\times n$ 个数 $a_{ij}(i=1,2,\\cdots,m;j=1,2,\\cdots,n)$ 有序地排成 $m$ 行 $n$ 列的数表\\begin{align} \\left(\\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mn} \\ \\end{matrix}\\right)\\end{align} 称为一个 $m$ 行 $n$ 列的矩阵，简记为 $(a_{ij})_{m\\times n}$ 如果两个矩阵有相同的行数和列数，则称他们是 同型的 如果两个同型矩阵 $\\mathbf{A}=(a_{ij}){m\\times n}$、$\\mathbf{B}=(b{ij}){m\\times n}$ 的对应元素相同，即$$ a{ij} = b_{ij}, \\hskip 2em i=1,2,\\cdots,m; \\hskip .5em j=1,2,\\cdots, n$$则称矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$ 相等，记作 $\\mathbf{A}=\\mathbf{B}$ 矩阵的运算矩阵的加法和减法【定义2】 设有两个同型的矩阵 $\\mathbf{A}=(a_{ij}){m\\times n},\\mathbf{B}=(b{ij}){m\\times n}$，则矩阵\\begin{align} \\mathbf{C}&amp;=(c{ij}){m\\times n}=(a{ij}+b_{ij}){m\\times n} \\ &amp;=\\left(\\begin{matrix} a{11}+b_{11} &amp; a_{11}+b_{11} &amp; \\cdots &amp; a_{11}+b_{1n} \\ a_{21}+b_{21} &amp; a_{22}+b_{22} &amp; \\cdots &amp; a_{2n}+b_{2n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{m1}+b_{11} &amp; a_{m2}+b_{m2} &amp; \\cdots &amp; a_{mn}+b_{mn} \\ \\end{matrix}\\right)\\end{align} 称为矩阵 $\\mathbf{A}$ 和 $\\mathbf{A}$ 的和，记为 $\\mathbf{C}=\\mathbf{A}+\\mathbf{B}$ 矩阵加法的性质 交换律：$\\mathbf{A}+\\mathbf{B}=\\mathbf{B}+\\mathbf{A}$ 结合律：$(\\mathbf{A}+\\mathbf{B})+\\mathbf{C}=\\mathbf{A}+(\\mathbf{B}+\\mathbf{C})$ 加法零元 $\\mathbf{O}$：$\\mathbf{A}+\\mathbf{O}=\\mathbf{O}$ 矩阵的数乘【定义3】 矩阵 $\\mathbf{A}=(a_{ij}){m\\times n}$，$\\lambda$ 为常数，则矩阵 $(\\lambda a{ij}){m\\times n}$ 称为数 $\\lambda$ 与矩阵 $\\mathbf{A}$ 的乘积（简称 数乘），记为 $\\lambda \\mathbf{A}$，即\\begin{align} \\lambda\\mathbf{A} = (\\lambda a{ij}){m\\times n} = \\left(\\begin{matrix} \\lambda a{11} &amp; \\lambda a_{12} &amp; \\cdots &amp; \\lambda a_{1n} \\ \\lambda a_{21} &amp; \\lambda a_{22} &amp; \\cdots &amp; \\lambda a_{2n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ \\lambda a_{m1} &amp; \\lambda a_{m2} &amp; \\cdots &amp; \\lambda a_{mn} \\ \\end{matrix}\\right)\\end{align} 矩阵数乘的性质 交换律及结合律：$(\\lambda\\mu)\\mathbf{A}=\\lambda(\\mu\\mathbf{A})=\\mu(\\lambda\\mathbf{A})$ 分配率：$\\lambda(\\mathbf{A}+\\mathbf{B})=\\lambda\\mathbf{A}+\\lambda\\mathbf{B}$，$(\\lambda+\\mu)\\mathbf{A}=\\lambda\\mathbf{A}+\\mu\\mathbf{A}$ 乘法零元：$1\\cdot\\mathbf{A}=\\mathbf{A}$，$(-1)\\cdot \\mathbf{A}=-\\mathbf{A}$ 矩阵乘法【定义4】 设矩阵 $\\mathbf{A}=(a_{ij}){m\\times t}$，$\\mathbf{B}=(b{ij}){t\\times n}$，称 $\\mathbf{C}=(c{ij}){m\\times n}$ 是 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的乘积，若\\begin{align} \\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\left(\\begin{matrix} a{11} &amp; a_{12} &amp; \\cdots &amp; a_{1t} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2t} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mt} \\ \\end{matrix}\\right){m\\times t} \\left(\\begin{matrix} b{11} &amp; b_{12} &amp; \\cdots &amp; b_{1s} \\ b_{21} &amp; b_{22} &amp; \\cdots &amp; b_{2s} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ b_{t1} &amp; b_{t2} &amp; \\cdots &amp; b_{ts} \\ \\end{matrix}\\right){t\\times s} = \\sum{i=1}^m\\sum_{j=1}^n\\sum_{k=1}^t a_{ik}b_{kj}\\end{align} 矩阵乘法的性质 结合律：$(\\mathbf{A}\\mathbf{B})\\mathbf{C}=\\mathbf{A}(\\mathbf{B}\\mathbf{C})$ 分配率：$\\mathbf{A}(\\mathbf{B}+\\mathbf{C})=\\mathbf{A}\\mathbf{B}+\\mathbf{A}\\mathbf{C}$，$(\\mathbf{B}+\\mathbf{C})\\mathbf{A}=\\mathbf{B}\\mathbf{A}+\\mathbf{C}\\mathbf{A}$ $(\\lambda\\mathbf{A})\\mathbf{B}=\\mathbf{A}(\\lambda\\mathbf{B})=\\lambda(\\mathbf{A}\\mathbf{B})$（其中 $\\lambda$ 为常数） 矩阵的转置【定义5】 $\\mathbf A^T$ 为矩阵 $\\mathbf A$ 的转置矩阵，若\\begin{align} A=\\left(\\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ a_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mn} \\ \\end{matrix}\\right){m\\times n} , \\hskip 1em \\mathbf A^T=\\left(\\begin{matrix} a{11} &amp; a_{21} &amp; \\cdots &amp; a_{n1} \\ a_{12} &amp; a_{22} &amp; \\cdots &amp; a_{n2} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ a_{1n} &amp; a_{2n} &amp; \\cdots &amp; a_{nm} \\ \\end{matrix}\\right)_{n\\times m}\\end{align} 矩阵转置的性质 $(\\mathbf A^T)^T=\\mathbf A$ $(\\mathbf A\\pm\\mathbf B)^T=\\mathbf A^T\\pm\\mathbf B^T$ $(\\lambda\\mathbf A)^T=\\lambda\\mathbf A$ $(\\mathbf A\\mathbf B)^T=\\mathbf B^T\\mathbf A^T$ $(\\mathbf A_1\\mathbf A_2\\cdots\\mathbf A_m)^T=\\mathbf A_m^T\\mathbf A_{m-1}^T\\cdots A_1^T$ 方阵若 $m=n$，则称矩阵 $\\mathbf A_{m\\times n}$ 为 $n$ 阶方阵 方阵的性质方阵 $\\mathbf A$ 构成的行列式记为 $|\\mathbf A|$ 或 $\\det(\\mathbf A)$ $\\mathbf A^m=\\mathbf A\\cdot\\mathbf A\\cdot \\dotsc \\cdot\\mathbf A$ $|\\lambda\\mathbf A|=\\lambda^n|\\mathbf A|$ $|\\mathbf A\\mathbf B|=|\\mathbf A||\\mathbf B|$ $|\\mathbf A^m|=|\\mathbf A|^m$其中，$\\mathbf A$ 和 $\\mathbf B$ 均为 $n$ 阶方阵，$\\lambda$ 为常数，$m,n$ 为正整数n 阶单位方阵若 $n$ 阶方阵 $\\mathbf E_n$ 主对角线上的元素全为 1，且其余元素全为 0；则称 $E_n$ 为 $n$ 阶单位矩阵，即\\begin{align}\\mathbf E_n=\\left(\\begin{matrix} 1 &amp; 0 &amp; \\cdots &amp; 0 \\ 0 &amp; 1 &amp; \\cdots &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{matrix}\\right)_{n\\times n}\\end{align}单位方阵的性质若 $\\mathbf A(m\\times n)$ 为 $m$ 行 $n$ 列的矩阵，$E_m$ 和 $E_n$ 分别为 $m$ 阶和 $n$ 阶单位方阵 $\\mathbf A_{m\\times n}E_n=\\mathbf A_{m\\times n}$ $E_m\\mathbf A_{m\\times n}=\\mathbf A_{m\\times n}$ 对角矩阵\\begin{align} \\left(\\begin{matrix} a_{11} &amp; 0 &amp; \\cdots &amp; 0 \\ 0 &amp; a_{22} &amp; \\cdots &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 0 &amp; 0 &amp; \\cdots &amp; a_{nn} \\ \\end{matrix}\\right)_{n\\times n}\\end{align} 三角形矩阵\\begin{align} \\begin{matrix} \\left(\\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ 0 &amp; a_{22} &amp; \\cdots &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 0 &amp; 0 &amp; \\cdots &amp; a_{nn} \\ \\end{matrix}\\right){n\\times n} &amp; \\text{或} &amp; \\left(\\begin{matrix} a{11} &amp; a_{12} &amp; \\cdots &amp; 0 \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix}\\right)_{n\\times n} \\\\ \\color{purple}{上三角矩形} &amp; \\hskip 0em &amp; \\color{purple}{下三角矩形} \\end{matrix}\\end{align} 对称矩阵\\begin{align} \\left(\\bcancel{\\begin{matrix} \\nvdash a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\hdashline a_{12} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{1n} &amp; a_{2n} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix}}\\right)\\end{align} 反对称矩阵\\begin{align} \\left(\\begin{matrix} \\end{matrix}\\right)\\end{align}","tags":[{"name":"数学","slug":"数学","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://littleclown.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"矩阵","permalink":"http://littleclown.github.io/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"线性代数基础之行列式","date":"2017-03-08T05:47:43.000Z","path":"study/math/linear-algebra/Study-Math-LinearAlgebra-1/","text":"逆序数【定义1】 $n$ 级排列 $i_1i_2\\cdots i_n$ 的逆序数记为 $\\tau(i_1i_2\\cdots i_n)$。比如，$\\tau(123)=0$，而 $\\tau(321)=3$，因为 32,31,21 是逆序，共 3 对。 若 $\\tau(i_1i_2\\cdots i_n) \\equiv 0\\mod 2$ 则称为 偶排列；否则称为 奇排列 【定理1】 若互换排列 $i_1i_2\\cdots i_n$ 中两个数 $i_x$ 和 $i_y$ 的位置（不妨假设 $x&lt;y$），则 $$\\tau(i_1i_2\\cdots i_x\\cdots i_y\\cdots i_n) \\not\\equiv \\tau(i_1i_2\\cdots i_y\\cdots i_x\\cdots i_n) \\mod 2 \\tag{1}$$ 当 $y=x+1$ 时，也就是相邻两个数进行对换，由于和其它数的相对顺序没有发生改变；此时 定理1 成立 当 $y=x+k$ （其中 $k&gt;1$ 且 $k \\in Z^+$）时，可以理解成： $i_y$ 先和 $i_{y-1}$ 交换，随之和 $i_{y-2}$ 交换，直到和 $i_{x}$ 交换，此时 $i_y$ 一共发生了 $y-x$ 次交换，且 $i_x$ 位于交换前 $i_{x+1}$ 的位置 然后 $i_x$ 和 $i_{x+1}$ 交换，直到和 $i_{y-1}$ 交换，一共交换了 $y-1-x$ 次 不难发现这样交换的结果和直接让 $i_x$ 和 $i_y$ 交换是一样的，相当于进行了 $(y-x)+(y-1-x)=2\\times(y-x)-1$ 次相邻交换，而每次相邻交换 $\\tau$ 的奇偶性都会发生改变（前述已经证明），故等价于 $(2\\times(y-x)-1)\\mod 2$ 次相邻交换 综上，即可证明 定理1 n 阶行列式【定义2】 设 $n(\\geqslant 2)$ 为自然数，由 $n^2$ 个数 $a_{ij}(i,j=1,2,\\cdots,n)$ 组成的记号\\begin{align} D=\\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}称为一个 $n$ 阶行列式，其中 $a_{ij}$ 称为第 $i$ 行第 $j$ 列的元素。行列式的值等于所有取值不同行不同列的 $n$ 个元素乘积的代数和：$$D=\\sum_{(j_1j_2\\cdots j_n)} (-1)^{\\tau(j_1j_2\\cdots j_n)} a_{1j_1}a_{2j_2}\\cdots a_{nj_n} \\tag{2}$$其中，$j_1j_2\\cdots j_n$ 为 $n$ 级排列，$\\sum_{(j_1j_2\\cdots j_n)}$ 表示对所有的 $n$ 级排列求和。 【定理2】 式(2) 也可以写成$$D=\\sum_{(j_1j_2\\cdots j_n)} (-1)^{\\tau(i_1i_2\\cdots i_n)+\\tau(j_1j_2\\cdots j_n)} a_{i_1j_1}a_{i_2j_2}\\cdots a_{i_nj_n} \\tag{3}$$ 将 $a_{i_1j_1}a_{i_2j_2}\\cdots a_{i_nj_n}$ 重排成 $a_{1j’1}a{2j’2}\\cdots a{nj’_n}$。 该过程可以认为是发生了若干次交换；而每发生一次交换，排列 $i_1i_2\\cdots i_n$ 和 $j_1j_2\\cdots j_n$ 同时发生一次交换，而由 定理1 可知，每次交换，$\\tau$ 的奇偶性就会发生改变，故 $\\tau(i_1i_2\\cdots i_n)+\\tau(j_1j_2\\cdots j_n)$ 的奇偶性不会改变。 于是不难有 $$(-1)^{\\tau(i_1i_2\\cdots i_n)+\\tau(j_1j_2\\cdots j_n)} = (-1)^{\\tau(12\\cdots n)+\\tau(j’_1j’_2\\cdots j’_n)} = (-1)^{\\tau(j’_1j’_2\\cdots j’_n)}$$ 由乘法交换律和加法交换律即可证明 定理2 的正确性 【推论1】$$D=\\sum_{(j_1j_2\\cdots j_n)} (-1)^{\\tau(i_1i_2\\cdots i_n)} a_{i_11}a_{i_22}\\cdots a_{i_nn} \\tag{3-1}$$ 行列式的性质【性质1】 将 $n$ 阶行列式 $D$ 的行和列互换，其值不变。即若\\begin{align} D=\\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| \\text{，}\\hskip 2em D^T=\\left| \\begin{matrix} a_{11} &amp; a_{21} &amp; \\cdots &amp; a_{n1} \\ a_{12} &amp; a_{22} &amp; \\cdots &amp; a_{n2} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{1n} &amp; a_{2n} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}则 $D=D^T$，且称 $D^T$ 为行列式 $D$ 的 转置。 由 式2 及 式3-1 即可得证 【性质2】 互换 $n$ 阶行列式的任意两行（列），行列式仅改变符号，即\\begin{align} \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| = -\\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}【推论2】 若行列式中某两行（列）的元素对应相等，则行列式为 0【性质3】 行列式的某一行（列）的所有元素同乘以一个数 $\\lambda$，等于以 $\\lambda$ 乘以这整个行列式，即\\begin{align} \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ \\lambda a_{i1} &amp; \\lambda a_{i2} &amp; \\cdots &amp; \\lambda a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| = \\lambda\\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}【推论3】 若行列式中某两行（列）的元素对应成比例，则行列式为 0【推论4】 若行列式中某行（列）的元素全为 0，则该行列式为 0【性质4】 若行列式的某行（列）的各元素是两个数之和，则该行列式等于两个行列式之和，而这两个行列式除了这一行（列）以外，与原行列式的对应行（列）一样，即\\begin{align} \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1}+a’{i1} &amp; a{i2}+a’{i2} &amp; \\cdots &amp; a{in}+a’{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| + \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a’{i1} &amp; a’{i2} &amp; \\cdots &amp; a’{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}【性质5】 若行列式的某行（列）的各元素乘以 $\\lambda$ 后，加到另一行（列）的对应元素上，行列式的值不变，即\\begin{align} \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{k1}+\\lambda a_{i_1} &amp; a_{k2}+\\lambda a_{i_2} &amp; \\cdots &amp; a_{kn}+\\lambda a_{i_n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align} 行列式的计算拉普拉斯展开定理【定义3】（余子式） 在 $n$ 阶行列式中，把元素 $a_{ij}(i,j=1,2,\\cdots,n)$ 所在的行和列划去后，剩下的 $(n-1)^2$ 个元素按原来的顺序构成的 $n-1$ 阶行列式\\begin{align} \\left| \\begin{matrix} a_{11} &amp; \\cdots &amp; a_{i,j-1} &amp; a_{i,j+1} &amp; \\cdots &amp; a_{1n} \\ \\vdots &amp; &amp; \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{i-1,1} &amp; \\cdots &amp; a_{i-1,,j-1} &amp; a_{i-1,j+1} &amp; \\cdots &amp; a_{i-1,n} \\ a_{i+1,1} &amp; \\cdots &amp; a_{i+1,,j-1} &amp; a_{i+1,j+1} &amp; \\cdots &amp; a_{i+1,n} \\ \\vdots &amp; &amp; \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; \\cdots &amp; a_{n,j-1} &amp; a_{n,j+1} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right|\\end{align}称为元素 $a_{ij}$ 的 余子式，记作 $M_{ij}$；余子式带上符号 $(-1)^{i+j}$ 称为 $a_{ij}$ 的 代数余子式，记作 $A_{ij}=(-1)^{i+j}M_{ij}$ 【定理3】 （拉普拉斯(Laplace)展开定理） $n$ 阶行列式等于它的任一行（列）的各元素与其对应的代数余子式乘积之和，即 \\begin{align} D=\\sum_{k=1}^n a_{ik}A_{ik}, \\hskip 2em i=1,2,3,\\cdots,n \\tag{4-1} \\ D=\\sum_{k=1}^n a_{kj}A_{kj}, \\hskip 2em j=1,2,3,\\cdots,n \\tag{4-2} \\\\end{align} 当 $n=1,2$ 时定理显然成立 当 $n&gt;2$ 时（方便起见，用 $n$ 维向量来证明，仅用到向量的定义和向量的点乘），为区分行列式符号及行列式值，以下使用 $\\det D$ 表示行列式 $D$ 的值记 $e_i=(\\overbrace{0,0,\\cdots}^{i-1\\text{个}0},1,\\underbrace{\\cdots,0}{n-i\\text{个}0})^T$，$a_i=a{11}e_1+a_{21}e_2+\\cdots+a_{n1}e_n$ 【引理3-1】 若 $a_1=e_1$，则 $\\det D=\\det M_{11}$ 由于 $a_{11}=1,a_{1k}=0,k\\neq 1$；结合 式2 有，\\begin{align}\\det D&amp;=\\sum_{(j_1j_2\\cdots j_n)} (-1)^{\\tau(j_1j_2\\cdots j_n)} a_{1j_1}a_{2j_2}\\cdots a_{nj_n} \\&amp;=a_{11}\\sum_{(j_2\\cdots j_n)} (-1)^{\\tau(j_2\\cdots j_n)} a_{2j_2}\\cdots a_{nj_n}= \\det M_{11} \\\\end{align} 【推论】 若 $a_j=e_i$，则 $\\det D=(-1)^{i+j}\\det M_{ij}$ 仅需将行列式第 $j$ 列往左不断与相邻列往换，直至到达第一列（共计 $j-1$ 次交换）；再将第 $i$ 行往上不断与相邻行交换，直至到达第一行（共计 $i-1$ 次交换），此时得到行列式记为 $D’$。根据上述交换规则人，不难发现，$M’{11}=M{11}$。显然，$D’$ 的第一列 $a’1=e_1$，由 引理3-1 可知，$\\det D’=\\det M’{11} = \\det M_{11}$。由行列式的 性质2 可知，$\\det D’=(-1)^{j-1+i-1}\\det D=(-1)^{i+j}\\det D$故 $\\det D = (-1)^{i+j}\\det D’ = (-1)^{i+j}\\det M_{11}$ 因为 $\\det D=\\det (a_1,a_2,\\cdots,a_n)=\\det (a_{11}e_1+\\cdots+a_{n1}e_n,\\cdots,a_{1n}e_1+\\cdots+a_{nn}e_n)$ 由行列式的 性质3 和 性质4 以及 推论 可知： \\begin{align} \\det D &amp;= \\det (a_{11}e_1+\\cdots+a_{n1}e_n,a_2,a_3,\\cdots,a_n) \\ &amp;= a_{11}\\det(e_1,a_2,\\cdots,a_n)+a_{21}\\det(e_2,a_2,\\cdots,a_n)+\\cdots+a_{n1}\\det(e_n,a_2,\\cdots,a_n) \\ &amp;= \\sum_{i=1}^n (-1)^{i+1} a_{i1}\\det M_{i1} = \\sum_{i=1}^n a_{i1}\\det A_{i1} \\end{align} 同理可证 式4-1、式4-2 成立 【定理4】 $n$ 阶行列式的任一行（列）的各元素与另外一行（列）对应元素的代数余子式的乘积之和等于 0，即$$\\sum_{k=1}^n a_{ik}A_{jk}=0 \\hskip 1em \\text{或} \\hskip 1em \\sum_{k=1}^n a_{ki}A_{kj}=0, \\hskip 2em i\\neq j \\tag{5}$$ 克拉默法则【定理5】 （克拉默法则） 如果含有 $n$ 个方程的 $n$ 元线性方程组\\begin{align} \\left\\lbrace \\begin{aligned} &amp;a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n = b_1 \\ &amp;a_{21}x_1+a_{22}x_2+\\cdots+a_{2n}x_n = b_2 \\ &amp;\\hskip 3em \\cdots\\cdots \\ &amp;a_{n1}x_1+a_{n2}x_2+\\cdots+a_{nn}x_n = b_n \\ \\end{aligned} \\right. \\tag{6}\\end{align}的系数行列式\\begin{align} D = \\left| \\begin{matrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right | \\neq 0\\end{align}则 线性方程组(6) 有唯一解，且其解为$$x_1=\\frac{D_1}{D},x_2=\\frac{D_2}{D},\\cdots,x_n=\\frac{D_n}{D} \\tag{7}$$其中 $D_j(j=1,2,\\cdots,n)$ 是用常数项 $b_1,b_2,\\cdots,b_n$ 代替系数矩阵 $D$ 中第 $j$ 列对应元素得到的 $n$ 阶行列式，即\\begin{align} D_j = \\left| \\begin{matrix} a_{11} &amp; \\cdots &amp; a_{1,j-1} &amp; b_1 &amp; a_{1,j+1} &amp; \\cdots &amp; a_{1n} \\ a_{21} &amp; \\cdots &amp; a_{2,j-1} &amp; b_2 &amp; a_{2,j+1} &amp; \\cdots &amp; a_{2n} \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ a_{n1} &amp; \\cdots &amp; a_{n,j-1} &amp; b_n &amp; a_{n,j+1} &amp; \\cdots &amp; a_{nn} \\ \\end{matrix} \\right |\\end{align} 首先证明 式7 是 方程组6 的解 由 拉普拉斯展开定理 $D_j$ 按第 $j$ 展开得 $\\displaystyle D_j=\\sum_{k=1}^n b_kA_{kj}$ 将 式7 代入 方程组6 的第 $i(i=1,2,\\cdots n)$ 个方程，得\\begin{align} &amp; a_{i1}x_1+a_{i2}x_2+\\cdots+a_{in}x_n \\ =&amp; \\sum_{j=1}^n a_{ij}x_j = \\sum_{j=1}^n a_{ij}\\frac{D_j}{D} \\ =&amp; \\frac{1}{D} \\sum_{j=1}^n a_{ij}\\left(\\sum_{k=1}^n b_kA_{kj}\\right) = \\frac{1}{D} \\sum_{k=1}^n b_k\\left(\\sum_{j=1}^n a_{ij}A_{kj}\\right) \\tag{加法交换律} \\ =&amp; \\frac{b_i}{D} \\sum_{j=1}^n a_{ij}A_{kj} = \\frac{b_i}{D}\\cdot D=b_i \\tag{定理4} \\\\end{align} 再证明解的唯一性若 $x’1,x’2,\\cdots,x’n$ 是 方程组6 的一组不同于 式7 的解；用行列式 $D$ 的第 $j$ 列各元素的代数余子式 $A{1j},A{2j},\\cdots,A{nj}$ 分别乘以 方程组6 的第 1 个，第 2 个，$\\cdots$，第 $n$ 个方程，并相加，得：\\begin{align} &amp; \\left(\\sum_{k=1}^n a_{k1}A_{kj}\\right)x’1 + \\cdots + \\left(\\sum{k=1}^n a_{kj}A_{kj}\\right)x’j + \\cdots + \\left(\\sum{k=1}^n a_{kn}A_{kj}\\right)x’n \\ =&amp; A{kj} \\sum_{i=1}^n\\left(\\sum_{k=1}^n a_{ki}\\right)x’i = A{kj} \\sum_{i=1}^n\\sum_{k=1}^n a_{ki}x’i = A{kj} \\sum_{k=1}^n b_k \\\\end{align} 由 定理3 和 定理4 得 $$Dx’_j=D_j, \\hskip 1em j=1,2,\\cdots,n$$由于 $D\\neq 0$，故 $x’_j=\\frac{D_j}{D}=x_j (j=1,2,\\cdots,n)$，这与 式7 相同。 Hint参考文献： 湖南大学 大学数学 3（2009 年 2 月 第 2 版）参考链接： 线性代数(二十四) ： 行列式的展开式—拉普拉斯公式","tags":[{"name":"数学","slug":"数学","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://littleclown.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"行列式","slug":"行列式","permalink":"http://littleclown.github.io/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"}]},{"title":"初识 Ubuntu","date":"2016-09-16T10:19:59.000Z","path":"study/computer/os/ubuntu/1/","text":"安装 Ubuntu 双系统 在 Windows 下分出硬盘空间，我分了 60G 下载 Ubuntu 镜像软件 下载 ultralSO 并将下载的 Ubuntu 镜像软件制作成 U 盘启动盘 安装 Ubuntu （在出现机器 logo 的时候按下 F12， 选择 USG HDD 启动）；设置分区： 逻辑分区，200M，起始，Ext4 日志文件系统， /boot；（引导分区；200 M 足够） 逻辑分区，4000M，起始，交换空间；（交换分区；一般不大于物理内存） 逻辑分区，35000M，起始，Ext4 日志文件系统，/；（系统分区） 逻辑分区，剩下的空闲空间，起始，Ext4 日志文件系统，/home；（用户分区；存放个人文档） 使用 EasyBSD 创建启动系统 参考链接* 解决 install -f 错误问题在 Ubuntu16.04 下安装网易云音乐时，下载好 netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb 后，执行 sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb 提示要安装很多的依赖项；执行 sudo install -f 结果有一个 libopenjpeg5_1.5.2-3.1_amd64.deb 下不下来；导致 apt-get 不可用。直接从网上下好 libopenjpeg5_1.5.2-3.1_amd64.deb 并放在 /var/cache/apt/archives 下，再次执行 sudo apt-get install -f 结果还是一样的错，ls 发现清除了下下来的那个包。重新下那个包，并在包所在目录下执行 sudo dpkg -i libopenjpeg5_1.5.2-3.1_amd64.deb 成功安装该包；再执行 sudo apt-get install -f 至此，成功解决问题。 解决挂起和休眠无法唤醒Ubuntu16.04 用的内核版本是 4.4.0-xx-xxxxxx，这个内核是引起系统挂起非正常死机的原因。***下载新内核***，这里我选择的是 v4.4.12-xenial 的内核。注意，千万不要使用 v4.4.14-xenial 的内核！进入想要安装的内核目录，下载三个文件（自己根据自己的系统选择） linux-headers-xxx_all.deb linux-headers-xxx-generic_xxx.deb linux-image-xxx-generic_xxx.deb 下载好后，按照顺序进行安装 sudo dpkg -i linux-headers-xxx_all.deb sudo dpkg -i linux-headers-xxx-generic_xxx.deb sudo dpkg -i linux-image-xxx-generic_xxx.deb 一些习惯性软件QQ 下载 wine-qq 解压并打开 wine-qq…. 安装包，安装 参考链接 安装虚拟机下载 virtualbox 使用深度终端原生的 Ubuntu 上的终端是不支持分屏的；另外，个人还是比较喜欢 deepin 的终端。 添加 Linux Deepin 源 编辑文件 /etc/apt/sources.list，再最后一行加上deb http://packages.linuxdeepin.com/deepin trusty main non-free universedeb-src http://packages.linuxdeepin.com/deepin trusty main non-free universe 添加 Linux Deepin 密匙文件 导入密匙 sudo wget http://packages.linuxdeepin.com/deepin/project/deepin-keyring.gpg sudo gpg –import deepin-keyring.gpg列出密匙 sudo gpg –list-keys导出密匙 sudo gpg –export –armor 209088E7 | sudo apt-key add - 更新软件源列表sudo apt-get update 安装 deepin-terminalsudo apt-get install deepin-terminal 参考链接 将 deepin-terminal 设置为默认终端 安装 dconf-tools 打开 dconf-tools；图形化操作，点进 org &gt; gnome &gt; desktop &gt; applications &gt; terminala 将 exec 对应的值改成 deepin-terminal 参考链接 vim+号寄存器解决方法是重装 vim sudo apt-get remove --purge vim sudo apt-get install build-essential sudo apt-get install ncurses-dev sudo apt-get install xorg-dev sudo apt-get install libgtk2.0-dev sudo apt-get install vim vim-scripts vim-gtk vim-gnome sudo apt-get install exuberant-ctags cscope 参考链接 配置 vim 我的配置文件：***.vimrc*** 插件： for HTML、css、javascript 下载 HTML.zip 解压到 ~/.vim/ 下即可下载 css.vim 拷贝到 ~/.vim/syntax 目录下即可下载 mark.vim （用于 javascript 变量标记和检查）拷贝到 ~/.vim/plugin 目录下即可下载 javascript.vim （用于语法高亮） 拷贝到 ~/.vim/syntax 目录下 在 javascript.vim 下设置 1setlocal foldlevel=1 在 .vimrc 下添加 12345678910111213141516171819202122232425let b:javascript_fold=1 &quot; 打开 javascript 折叠let javascript_enable_domhtmlcss=1 &quot; 打开 javascript 对 dom、html、css 的支持&quot; html 标签自动补全（简陋版） function! InsertHtmlTag() let pat = &#x27;\\c&lt;\\w\\+\\s*\\(\\s\\+\\w\\+\\s*=\\s*[\\-/:&#x27;&#x27;#$;,().&quot;a-z0-9]\\+\\)*\\s*&gt;&#x27; normal! a&gt; let save_cursor = getpos(&#x27;.&#x27;) let result = matchstr(getline(save_cursor[1]), pat) &quot;if (search(pat, &#x27;b&#x27;, save_cursor[1]) &amp;&amp; searchpair(&#x27;&lt;&#x27;,&#x27;&#x27;,&#x27;&gt;&#x27;,&#x27;bn&#x27;,0, getline(&#x27;.&#x27;)) &gt; 0) let lemon = search(pat, &#x27;b&#x27;, save_cursor[1]) if( lemon ) normal! lyiwf&gt; normal! a&lt;/ normal! p normal! a&gt; normal! k endif :call cursor(save_cursor[1], save_cursor[2], save_cursor[3]) if( lemon ) :execute &quot;normal! a\\&lt;CR&gt;\\&lt;CR&gt;&quot; normal! k&gt;&gt; endif endfunction autocmd FileType md inoremap &gt; &lt;ESC&gt;:call InsertHtmlTag()&lt;CR&gt;a autocmd FileType html inoremap &gt; &lt;ESC&gt;:call InsertHtmlTag()&lt;CR&gt;a vim 下web开发html css js插件 把 vim 打造成牛逼的 C++ IDE YouCompleteMegit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim Git安装 sudo apt-get install git 设置 git config --global user.name &quot;xxxx&quot; # 设置用户名 git config --global user.email &quot;xxxx@xxx.com&quot; # 设置用户邮箱 解决中文乱码 git config --global core.quotepath false git config --global gui.encoding utf-8 # 设置 git gui 的界面编码 git config --global i18n.commitencoding utf-8 # 设置 commit log 提交时使用 utf-8 编码 # git config --global i18n.logoutputencoding gbk # 设置在 git log 时将 utf-8 编码转换成 utf-8编码 export LESSCHARSET=utf-8 # 使得 git log 可以正常使用中文 新建 ssh 密匙 cd ~/.ssh ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; ssh-agent bash ssh-add id_rsa 将 id_rsa.pub 部署到 github 上，测试： ssh git@github.com 参考链接参考链接 pipsudo apt-get install python-pip （默认 python2.7） sudo apt-get install python3-pip （基于 python3.x) java 下载 java 将下载文件（应该是一个 tar.gz 结尾的文件）解压到 /opt12tar zxvf xxx.tar.gzsudo mv xxx /opt 在解压后的目录下找到 bin 目录，创建 java 软链接（源文件一定要使用绝对路径）到 /bin/ 目录下1sudo ln /opt/jdk1.8.0_101/bin/java /bin/java 设置 java 环境打开 /etc/profile12345export JAVA_HOME=/opt/jdk1.8.0_92export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATHsource /etc/profile chromesudo apt-get install google-chrome-stable youdao-dict 下载 youdao-dict_1.1.0-0-ubuntu_amd64.deb 到该目录下安装sudo dpkg -i youdao-dict_1.1.0-0-ubuntu_amd64.deb 如果失败，请参考 Ubuntu16.04 安装有道词典 nodejs现下好 ***nodejs***。应该是一个 xxx.tar.xz 文件。假设该文件所在目录为 /lemon： xz -d xxx.tar.xz tar -xvf xxx.tar ln -s /lemon/bin/node /usr/local/bin/node ln -s /lemon/bin/npm /usr/local/bin/npm .tar.xz 文件解压后即可执行，建立软链接使得全局可以使用。建立软链接时一定要用绝对路径。参考链接 hexo使用 npm 命令安装 hexo，你会发现安装的位置在你 npm 下，所以需要建立软链接以使得全局可以使用。 sudo npm install -g hexo-cli ln -s /lemon/bin/hexo /usr/local/bin/hexo Rsudo apt-get install r-base mysqlsudo apt-get install mysql-client mysql-server mongodbtar -zxvf mongodb-linux-x86_64-ubuntu1604-3.4.0.tgz TTF 字体先下好字体，比如 consolas.ttf 字体；安装命令如下： sudo cp consolas.ttf /usr/share/fonts/truetype/ sudo fc-cache -f -v tex-live下载 ***intall-tl-unx.tar.gz***，执行 tar -xvzf intall-tl-unx.tar.gz 在解压后的文件夹中找到 install.tl，在终端中执行 sudo ./install-tl 参考链接 或者，可以下载 texlive2016.iso 文件： 中科大镜像 清华镜像 阿里云镜像为了使用图形化安装界面，安装 perl 的 tk 组件： sudo apt-get install perl-tk到 texlive2016.iso 目录下，执行 sudo mount -o loop texlive2016.iso /mntcd /mntsudo ./install-tl -gui在图形化界面中安装，创建符号链接选是。安装完成后，卸载镜像文件 cd /; sudo umount /mnt 参考链接关于字体的问题，只要安装好 simfang.ttf、simhei.ttf、simkai.ttf、simsun.ttf 应该问题就不大了。 JavaEETomcat 安装下载 Core&gt;tar.gz安装配置 tar -zxvf apache-tomcat-9.0.0.M10 sudo mv apache-tomcat-9.0.0.M10 /opt cd /opt/apache-tomcat-9.0.0.M10/bin sudo ./startup.sh # 开启 tomcat 打开浏览器， localhost:8080 即可访问到 tomcat 的页面。查看监控信息 cd /opt/apache-tomcat-9.0.0.Min/logs tail -f catalina.out 参考链接","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://littleclown.github.io/tags/Ubuntu/"},{"name":"技术","slug":"技术","permalink":"http://littleclown.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"前端学习之 css(1)","date":"2016-09-14T13:35:17.000Z","path":"study/codding/projects/web/frontend/css/1/","text":"边框 border-radius圆角边框效果 语法123border-radius: 5px; /* 四个角的半径均为 5px 的圆角 */border-radius: 5px 7px; /* 左上角和右下角半径为 5px；右上角和左下角半径为 7px*/border-radius: 5px 4px 3px 7px; /*依次为 左上角、右上角、右下角、左下角*/ 使用 border-radius 时，需要给边框设置宽度和高度 效果 可以使用 border-radius 画实心圆，只要满足：height=width, border-radius=$\\frac{1}{2} \\times $width。 box-shadow向盒子添加阴影效果；支持多重添加 语法1box-shadow: X 偏移量 Y 偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]; X 偏移量和 Y 偏移量可以看做光线投影过来的方向；投影方式：设置了 inset 时为 内部阴影，否则为 外部阴影 参考链接 border-image为边框应用背景图片 语法1border-image: url(xxx.png) 70 70 70 70 延伸方式 其中，延伸方式为：round （平铺）；repeat （重复）；stretch （拉伸） 参考链接 颜色 渐变色彩 线性渐变 语法1linear-gradient(方向,颜色点1,颜色点2,...颜色点n); 方向可以用角度表示，单位为 deg，如： 0deg、90deg、123deg 等 方向也可以用关键字表示，如：to top、to right、to bottom、to left、to top left 等颜色点：每个颜色点有一个颜色值表示，在线上依次紧邻排布 参考链接 径向渐变 语法1radial-gradient(center, shape, size, color-stop1, ..., color-stopn); center 渐变的起点；可以为百分比；默认在图形的中心 shape 渐变的形状： ellipse 表示椭圆形，circle 表示圆形，默认为 ellipse； size 大小：closest-side 最近边；closest-corner 最近角；fathest-side 最远边；fathest-corner 最远角； start-color 颜色点 参考链接 文字与字体 text-overflow用于说明文字溢出时用什么方式显示： clip 表示剪切；ellipsis 表示显示省略标记。为了产生理想的省略号的效果，还需 强制文本在一行内显示 white-space: nowrap; 及 溢出内容隐藏 overflow: hidden; 语法123text-overflow: ellipsis;overflow: hidden;white-space: nowrap; 参考链接 word-wrap用来指定当前行溢出时是否断开换行 语法1word-wrap: normal | break-word; 其中，normal（默认值） 表示控制连续文本换行；break-word 表示内容将在边界内换行 @font-face 语法1234@font-face &#123; font-family: 字体名称; src: 字体文件在服务器上的相对或绝对路径；&#125; 这样就可以加载出本地没有但服务器上有的字体了 text-shadow 语法1text-shadow: X-Offset Y-Offset Blur Color; 其中，X-Offset 表示阴影的水平偏移距离；Y-Offset 表示阴影的垂直偏移距离； Blur 表示阴影的模糊程度，值越大越模糊（不可为负）；Color 表示阴影的颜色 参考链接 与背景相关的样式 background-origin设置元素背景图片的 原始起始位置 语法 1background-origin: border-box | padding-box | content-box; 参数分别表示背景图片从 边框、内边框（默认值）、内容区域 显示注意，这个属性仅当背景为 no-repeat 时有效；否则将从 边框 开始显示。 参考链接 background-clip对背景图片做适当 裁剪 以适应实际需要 语法 1background-clip: border-box | padding-box | content-box | no-clip; 参数分别表示从 边框、内边框（默认值）、内容区域 向外裁剪背景; no-clip 表示不裁剪 参考链接 background-size设置背景图片的大小，以 长度值 或 百分比 显示；还可以通过 contain 和 cover 来对图片进行缩放 语法1background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | contain | cover; 取值说明 auto：默认值，不改变背景图片的原是尺寸 &lt;长度值&gt;：成对出现时，如：background-size: 20px 30px; 表示将背景图片宽度设为 20px，高度设为 30px；只设置一个值时，表示长宽值相同 &lt;百分比&gt;：成对出现时，如：background-size: 20% 30%; 表示将背景图片宽度设为其所在容器的宽度的 20%，高度设为其所在容器的宽度的 30%；只设置一个值时，表示长宽比例相同 cover：将背景图片缩放至铺满整个容器为止 contain：将背景图片缩放至某一边抵住容器边缘（上下抵住 ，或左右抵住） 参考链接 multiple backgrounds 多背景技术 综合练习1 选择器属性选择器 属性选择器 功能描述 E[att^=”val”] 选择匹配拥有属性 att 且 att 属性值是以 val 开头的字符串 的元素 E E[att$=”val”] 选择匹配拥有属性 att 且 att 属性值是以 val 结尾的字符串 的元素 E E[att*=”val”] 选择匹配拥有属性 att 且 att 属性值中存在一子串为 val 的字符串 的元素 E 结构性伪类选择器根选择器 :root在 HTML 文档中，根元素始终是 &lt;html&gt;。通过 :root 选择器可以设置背景颜色 1234567:root &#123; background: orange;&#125;/* 或者 */html &#123; background: purple;&#125; 否定选择器 :not选择除符合否定条件的所有元素。 1234567div:not([id=&quot;XXX&quot;]) &#123; background: purple; /*对所有 id 不是 &quot;XXX&quot; 的 div 元素有效 */ &#125; input:not([type=&quot;submit&quot;]) &#123; background: orange; /*对所有不是 submit 类型的 input 元素有效*/&#125; 空选择器 :empty选择没有任何内容（空白字符也不可有）的元素。 1234div:empty &#123; border: 1px solid green;&#125;/* 对于 &lt;div&gt;&lt;/div&gt; 有效； 对于 &lt;div&gt; &lt;/div&gt; 无效。 */ 目标选择器 :target 匹配文档（页面）的 url 的某个标识符的目标元素。具体来说，触发元素的 url 中的标识符通常会包含一个 #号，后面带有一个 标识符名称。 html 123456789101112&lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div id=&quot;brand&quot;&gt; content for Brand.&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#jake&quot;&gt;Jake&lt;/a&gt;&lt;/h2&gt;&lt;div id=&quot;jake&quot;&gt; content for jake.&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#aron&quot;&gt;Aron&lt;/a&gt;&lt;/h2&gt;&lt;div id=&quot;aron&quot;&gt; content for aron.&lt;/div&gt; css 1234567891011121314#brand:target &#123; background: orange; color: #fff;&#125;#jake:target &#123; background: blue; color: #fff;&#125;#aron:target &#123; background: red; color: #fff;&#125; 参考链接 子包含选择器 E &gt; F匹配 满足的 E 的元素 的 满足 F 的子元素。 1table.lemon td &gt; p &#123; &#125; /* 匹配 td 的子元素中所有的 p 元素；且 td 从 table 继承，该 table 元素有一个 lemon 的 class 属性 */ 其它 选择器 用法 参考链接 :first-child 顾名思义 imooc :last-child 顾名思义 imooc :nth-child(n) 匹配父元素第 $n$ 个子元素可以采用 $3n+1$ 以匹配第 1、4、7… 个子元素可以用 even 表示 $2n$，odd 表示 $2n+1$ imooc :nth-last-child(n) 与 :nth-child(n) 相比是 逆序 计数的 imooc :first-of-type 和 :first-child 类似，但匹配同类型的元素中第一个兄弟元素可以指定多个类型 imooc :last-of-type 顾名思义 imooc :nth-of-type(n) 顾名思义 imooc :nth-last-of-type(n) 顾名思义 imooc :only-child 匹配父元素仅有一个元素的元素如，li:only-child&#123;&#125; 匹配的是仅含一个子元素，且该子元素为 li 的子元素（也就是这个 li 元素） imooc :only-of-type 与 :only-child 类似，只是把匹配条件改为：指定类型的元素仅有一个 imooc 伪元素选择器::selection用来匹配网页上鼠标选择的文本。 1234::selection &#123; background: red; color: purple;&#125; :before 和 :after用来给元素的前面或后面插入内容，经常和 content 配合使用；content 属性指定插入的内容。 变形与动画rotate()rotate() 函数让元素顺时针旋转，接受度数作为参数。 1234/* rotate(xdeg) 表示顺时针旋转 x 度 */-webkit-transform: rotate(20deg); /* for chrome */-moz-transform: rotate(20deg); /* for firefox */transform: rotate(20deg); skew()skew() 函数能让元素倾斜显示；比如对一个矩形使用 skew(argx,argy)，那么显示的时候的时候，原来垂直于 x 轴的边将沿逆时针方向旋转 argx；而原来垂直于 y 轴的边将沿逆时针方向旋转 argy。（注意：这里的坐标系沿屏幕向右为 x 轴正方向，屏幕向下为 y 轴正方向）skewX() 仅接受一个参数，且仅是元素在水平方向上扭曲变形；skewY() 仅接受一个参数，且仅是元素在垂直方向上扭曲变形；参考链接 scale()scale() 函数能让元素缩放显示；它接受两个参数：scale(X,Y)。但是，如果只有一个参数，则对 Y 的缩放倍数是一样的。scaleX() 仅接受一个参数，且表示元素在 X 轴方向上缩放；scaleY() 仅接受一个参数，且表示元素在 Y 轴方向上缩放； translate()translate() 函数可以将元素向指定的方向移动，且 不影响页面上的其它组件。translate() 接受两个参数：translate(X,Y)。也就是朝 X 方向和 Y 方向移动的距离。translateX() 仅接受一个参数，且表示元素在 X 轴方向移动。translateY() 仅接受一个参数，且表示元素在 Y 轴方向移动。例： 1234567.wrapper &#123; top: 50%; left: 50%; position: absolute; transform: translate(-50%, -50%);&#125; matrix()","tags":[{"name":"web 开发","slug":"web-开发","permalink":"http://littleclown.github.io/tags/web-%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://littleclown.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://littleclown.github.io/tags/css/"}]},{"title":"组合游戏基础之 SG 函数和 SG 定理","date":"2016-09-04T09:28:53.000Z","path":"study/math/combinatorial-game/SG/","text":"NP 状态描述 无法进行任何移动的局面为 P-position 可以移动到 P-position 的局面为 N-position 任意移动都到达 N-position 的局面为 P-position Nim 游戏Nim 游戏是组合游戏中的经典游戏，描述如下：有 $n$ 堆石子，第 $i$ 堆有 $x_i$ 颗石子。$A$、$B$ 两人轮流取石子，每次仅能选择一堆不为空的石子进行操作：取走至少一颗石子。不能操作的人输。 关于 Nim 游戏有一个著名的结论：当且仅当 $x_1\\oplus x_2\\oplus\\cdots\\oplus x_n=0$ 时，先手获胜；否则后手胜。证明很简单，当 $X=x_1\\oplus x_2\\oplus\\cdots\\oplus x_n\\neq 0$ 时，设 $X$ 的二进制最高位为 $k$，那么一定存在一个 $x_i$ 其第 $k$ 位为 1。我们只需要从第 $i$ 堆石子中取走 $X\\oplus x_i$ 个（显然，$X\\oplus x_i &lt; x_i$，所以此操作是有效的），那么新的游戏状态下：$x_1\\oplus x_2\\oplus\\cdots(x_i\\oplus X)\\oplus x_n=X\\oplus X=0$。事实上，这也是构造 Nim 游戏方案的方法。 接下来，介绍 $SG$ 函数和 $SG$ 定理，$SG$ 函数和 $SG$ 定理是解决一类组合游戏的有力工具。 SG 函数对于任意状态 $x$，定义 $SG(x)=mex(S)$；其中，$S$ 是 $x$ 的所有后继状态的 $SG$ 函数值集合，$mex(S)$ 表示不在 $S$ 中的最小非负整数。 特别地，当 $S$ 为空集，即 $x$ 没有后继节点时，$SG(x)=0$。不难验证：\\begin{align} x~\\text{is}\\left\\lbrace \\begin{aligned} &amp;\\text{P-position}, &amp;SG(x)=0 \\ &amp;\\text{N-position}, &amp;SG(x)\\neq0 \\ \\end{aligned} \\right.\\end{align} SG 定理游戏和的 $SG$ 函数等于各子游戏的 $SG$ 函数的 $Nim$ 和。具体来说，若游戏 $A$ 可以看做由 $n$ 个互不干扰的子游戏 $(A_1,A_2,\\cdots,A_n)$ 构成；也就是对于游戏任一状态 $(x_1,x_2,\\cdots,x_n)$，只能选择一个子游戏 $A_i(1\\leqslant i\\leqslant n)$ 进行操作，得到状态 $(x_1,x_2,\\cdots,x’_i,\\cdots,x_n)$；那么，$SG_A\\big((x_1,x_2,\\cdots,x_n)\\big)=SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus SG_{A_n}(x_n)$。 证明不妨假设当前游戏状态为 $X=(x_1,x_2,\\cdots,x_n)$；记 $X$ 的所有后继状态集合为 $S$；并记 $b=SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus SG_{A_n}(x_n)$。我们的证明分两步： $\\forall_{0\\leqslant a &lt; b},\\exists_{X’\\in S} SG_{A}(X’) = a.$ $\\forall_{X’\\in S} SG_{A}(X’) \\neq b.$ step 1记 $c=b\\oplus a$；因为 $a &lt; b$，所以必有：若 $c$ 的二进制最高位为 $k$，则 $b$ 的二进制第 $k$ 位也为 1；否则必有 $a &gt; b$。于是必有 $x_i \\in X$ 满足 $SG_{A_i}(x_i)$ 的二进制第 $k$ 位为 1。令 $d=c\\oplus SG_{A_i}(x_i)$，不难验证：$d &lt; SG_{A_i}(x_i)$。所以，根据 $SG$ 函数的定义可知，子游戏 $A_i$ 必有一个 $SG$ 值为 $d$ 的后继节点 $x_i’$。此时，\\begin{align} &amp;SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus SG_{A_i}(x_i’)\\cdots\\oplus SG_{A_n}(x_n)\\ =&amp;SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus \\big(SG_{A_i}(x_i’)=d=c\\oplus SG_{A_i}(x_i)=b\\oplus a\\oplus SG_{A_i}(x_i)\\big)\\cdots\\oplus SG_{A_n}(x_n)\\ =&amp;\\big(SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus SG_{A_i}(x_i)\\cdots\\oplus SG_{A_n}(x_n)\\big)\\oplus b\\oplus a\\ =&amp;b\\oplus b\\oplus a=a.\\end{align} step 2不妨操作子游戏 $A_i$ 到状态 $x_i’$ 得到游戏状态 $X’=(x_1,x_2,\\cdots,x_i’,\\cdots,x_n)$。由 $SG$ 函数的定义可知，$SG_{A_i}(x_i’) \\neq SG_{A_i}(x_i)$，即 $SG_{A_i}(x_i’)\\oplus SG_{A_i}(x_i)\\neq 0$。那么：\\begin{align} &amp;SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus SG_{A_i}(x_i’)\\cdots\\oplus SG_{A_n}(x_n)\\ =&amp;SG_{A_1}(x_1)\\oplus SG_{A_2}(x_2)\\oplus \\cdots\\oplus \\Big(\\big(SG_{A_i}(x_i’)\\oplus SG_{A_i}(x_i)\\big)\\oplus SG_{A_i}(x_i)\\Big)\\cdots\\oplus SG_{A_n}(x_n)\\ =&amp;b\\oplus SG_{A_i}(x_i’)\\oplus SG_{A_i}(x_i) \\neq b.\\end{align} 参考链接 Hint由 $SG$ 函数的定义，不难联系到 Nim 游戏。实际上，我们可以用解决 Nim 游戏的方法来构造一般组合游戏的方案。只需要顺着将 $SG(X)$ 变成 0 的方向做出决策就好了。在实际问题上，通常 $x$ 是一个很大的数，但是一般 $SG$ 函数是有规律的（总要给点活路= =），然后只要本地打表找规律。。。 练习 problems categories solution/code 51Nod/1661 $SG$ 函数（本地打表找规律） Code","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://littleclown.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"组合游戏","slug":"组合游戏","permalink":"http://littleclown.github.io/tags/%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F/"},{"name":"SG 定理","slug":"SG-定理","permalink":"http://littleclown.github.io/tags/SG-%E5%AE%9A%E7%90%86/"}]},{"title":"网络流专题","date":"2016-07-30T05:16:55.000Z","path":"acm/special-topic/graph-theory/network-flow/","text":"实现由于网络流问题难点在于建模，实现网络流的代码几乎可以不变，为此，特将下文中将会多次使用到的代码给罗列出来。 ISAP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100namespace ISAP &#123;/*&#123;&#123;&#123;*/ static const int MAXN = 10000+10; static const int INF = 0x3f3f3f3f; struct edge &#123; int from, to, cap, flow; edge(int from=0, int to=0, int cap=0, int flow=0): from(from), to(to), cap(cap), flow(flow) &#123;&#125; &#125;; int s, t, n; int cnt[MAXN]; int cur[MAXN]; int path[MAXN]; int dist[MAXN]; std:: vector&lt;edge&gt; edges; std:: vector&lt;int&gt; G[MAXN]; std:: queue&lt;int&gt; Q; void addedge(int from, int to, int cap) &#123; int siz = edges.size(); edges.push_back(edge(from, to, cap, 0)); edges.push_back(edge(to, from, 0, 0)); G[from].push_back(siz); G[to].push_back(siz+1); &#125; void BFS() &#123; memset(dist, 0x3f, sizeof dist); Q.push(t); dist[t] = 0; while( !Q.empty() ) &#123; int o = Q.front(); Q.pop(); for(int i=0; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( dist[e.to] == INF &amp;&amp; e.cap == 0 ) &#123; dist[e.to] = dist[o] + 1; Q.push(e.to); &#125; &#125; &#125; &#125; int augment() &#123; int mif = INF; for(int o=t; o != s;) &#123; edge&amp; e = edges[path[o]]; mif = std:: min(mif, e.cap-e.flow); o = e.from; &#125; for(int o=t; o != s;) &#123; edges[path[o]].flow += mif; edges[path[o]^1].flow -= mif; o = edges[path[o]].from; &#125; return mif; &#125; int maxflow() &#123; BFS(); memset(cur, 0, sizeof cur); memset(cnt, 0, sizeof cnt); for(int i=0; i &lt; n; ++i) if( dist[i] &lt; n ) ++cnt[dist[i]]; int ans = 0; for(int o=s; dist[o] &lt; n; ) &#123; if( o == t ) ans += augment(), o = s; bool ok = false; for(int i=cur[o]; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( e.cap &gt; e.flow &amp;&amp; dist[o] == dist[e.to]+1 ) &#123; ok = true; cur[o] = i; path[e.to] = G[o][i]; o = e.to; break; &#125; &#125; if( !ok ) &#123; int d = n-1; for(int i=0; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( e.cap &gt; e.flow ) d = std:: min(d, dist[e.to]); &#125; if( --cnt[dist[o]] == 0 ) break; ++cnt[dist[o] = d+1]; cur[o] = 0; if( o != s ) o = edges[path[o]].from; &#125; &#125; return ans; &#125; void solve(); void solve(int); void solve(int, int); void solve(int, int, int);&#125;;/*&#125;&#125;&#125;*/ Dinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace Dinic &#123;/*&#123;&#123;&#123;*/ struct edge &#123; int from, to, cap, flow; edge(int from=0, int to=0, int cap=0, int flow=0): from(from), to(to), cap(cap), flow(flow) &#123;&#125; &#125;; int s, t; int cur[MAXN]; int dist[MAXN]; std:: queue&lt;int&gt; Q; std:: vector&lt;edge&gt; edges; std:: vector&lt;int&gt; G[MAXN]; void addedge(int from, int to, int cap) &#123; int siz = edges.size(); edges.push_back(edge(from, to, cap, 0)); edges.push_back(edge(to, from, 0, 0)); G[from].push_back(siz); G[to].push_back(siz+1); &#125; bool BFS() &#123; memset(dist, -1, sizeof dist); Q.push(s); dist[s] = 0; while( !Q.empty() ) &#123; int o = Q.front(); Q.pop(); for(int i=0; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( dist[e.to] != -1 || e.cap &lt;= e.flow ) continue; dist[e.to] = dist[o]+1; Q.push(e.to); &#125; &#125; return dist[t] != -1; &#125; int DFS(int o, int minflow) &#123; if( o == t || minflow == 0 ) return minflow; int flow = 0; for(int&amp; i=cur[o]; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( dist[e.to] == dist[o]+1 ) &#123; int f = DFS(e.to, std:: min(minflow, e.cap-e.flow)); if( f &lt;= 0 ) continue; e.flow += f; edges[G[o][i]^1].flow -= f; flow += f; minflow -= f; if( minflow == 0 ) break; &#125; &#125; return flow; &#125; int maxflow() &#123; int ans = 0; while( BFS() ) &#123; memset(cur, 0, sizeof cur); ans += DFS(s, INF); &#125; return ans; &#125; void solve(); void solve(int); void solve(int, int); void solve(int, int, int);&#125;;/*&#125;&#125;&#125;*/ MCMF12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485namespace MCMF &#123;/*&#123;&#123;&#123;*/ const int MAXN = 10000+10; const int INF = 0x3f3f3f3f; struct edge &#123; int from, to, cap, flow, cost; edge(int from=0, int to=0, int cap=0, int flow=0, int cost=0): from(from), to(to), cap(cap), flow(flow), cost(cost) &#123;&#125; &#125;; int s, t; int cost, flow; int path[MAXN]; int dist[MAXN]; std:: vector&lt;edge&gt; edges; std:: vector&lt;int&gt; G[MAXN]; void init(int source=0, int converge=1, int N=MAXN) &#123; s = source; t = converge; cost = 0; flow = 0; edges.clear(); for(int i=0; i &lt; N; ++i) G[i].clear(); &#125; void addedge(int from, int to, int cap, int cost) &#123; int siz = edges.size(); edges.push_back(edge(from, to, cap, 0, cost)); edges.push_back(edge(to, from, 0, 0, -cost)); G[from].push_back(siz); G[to].push_back(siz+1); &#125; bool SPFA() &#123; static std:: queue&lt;int&gt; Q; static bool inq[MAXN]; memset(dist, 0x3f, sizeof dist); Q.push(s); inq[s] = true; dist[s] = 0; while( !Q.empty() ) &#123; int o = Q.front(); Q.pop(); for(int i=0; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( e.cap &gt; e.flow &amp;&amp; dist[e.to] &gt; dist[o]+e.cost ) &#123; dist[e.to] = dist[o] + e.cost; path[e.to] = G[o][i]; if( inq[e.to] ) continue; inq[e.to] = true; Q.push(e.to); &#125; &#125; inq[o] = false; &#125; return dist[t] != INF; &#125; std:: pair&lt;int, int&gt; mincostmaxflow() &#123; while( SPFA() ) &#123; int mif = INF; for(int o=t; o != s;) &#123; edge&amp; e = edges[path[o]]; mif = std:: min(mif, e.cap-e.flow); o = e.from; &#125; for(int o = t; o != s;) &#123; edges[path[o]].flow += mif; edges[path[o]^1].flow -= mif; o = edges[path[o]].from; &#125; flow += mif; cost += mif*dist[t]; &#125; return std:: make_pair(flow, cost); &#125; void solve(); void solve(int); void solve(int, int); void solve(int, int, int);&#125;;/*&#125;&#125;&#125;*/ read12345678910inline int read() &#123;/*&#123;&#123;&#123;*/ bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;/*&#125;&#125;&#125;*/ 网络流 24 题01 **Power OJ/1736 *[飞行员配对方案问题](https://www.oj.swust.edu.cn/problem/show/1736)*** 经典的二分图模型。 - 外籍飞行员作为左侧点，英国飞行员作为右侧点，可以互相配合的飞行员之间连一条容量为 1 的边 - 建立源点 $s$，并从 $s$ 对左侧的每个点引一条容量为 1 的边 - 建立汇点 $t$，并从右侧的每个点向 $t$ 引一条容量为 1 的边 跑最大流。至于方案，仅需考虑满流的边 $\\left&lt; \\mu,\\nu \\right&gt;$（其中 $\\mu \\in$ 左侧的点集，$\\nu \\in$ 右侧的点集），那么 $\\mu$ 和 $\\nu$ 是一对搭档。 123456789101112131415161718192021222324252627282930313233343536373839404142void ISAP:: solve(int N, int M) &#123;/*&#123;&#123;&#123;*/ s = 0; t = M+1; n = M+2; int ans = maxflow(); if( ans &gt; 0 ) &#123; printf(&quot;%d\\n&quot;, ans); for(int o=0; o &lt; N; ++o) &#123; edge&amp; e = edges[G[0][o]]; if( e.cap == e.flow ) &#123; for(auto&amp; i: G[e.to]) &#123; edge&amp; e2 = edges[i]; if( e2.cap == e2.flow ) &#123; printf(&quot;%d %d\\n&quot;, e.to, e2.to); break; &#125; &#125; &#125; &#125; &#125; else puts(&quot;No Solution!&quot;);&#125;int main()&#123; int N = read(); int M = read(); for(int i=1; i &lt;= N; ++i) ISAP:: addedge(0, i, 1); for(int i=N+1; i &lt;= M; ++i) ISAP:: addedge(i, M+1, 1); while( true ) &#123; int u = read(); int v = read(); if( u == -1 &amp;&amp; v == -1 ) break; if( u &gt; v ) std:: swap(u, v); ISAP:: addedge(u, v, 1); &#125; ISAP:: solve(N, M); return 0;&#125;/*&#125;&#125;&#125;*/ 02 **Power OJ/1737 *[太空飞行计划问题](https://www.oj.swust.edu.cn/problem/show/1737)*** 经典的最大权闭合图问题。 关于最大权闭合图可以参见 ***[网络流基础之最大权闭合图](http://littleclown.github.io/2016/07/24/Study-GT-network-flow-Maximum-weight-Closure-of-a-Graph/)***。 - 设实验 $i$ 获利为 $x\\_i$，实验仪器 $j$ 花费为 $y\\_j$ - 将每个实验与实验所需仪器连边，且容量设为 $\\infty$ - 建立源点 $s$，并从 $s$ 对所有的实验引一条容量为 $\\alpha\\times x+\\beta$ 的边（其中，$\\alpha$ 与 $\\beta$ 的作用及取值在 ***[网络流基础之最大权闭合图](http://littleclown.github.io/2016/07/24/Study-GT-network-flow-Maximum-weight-Closure-of-a-Graph/)*** 一文中有详细讨论） - 建立汇点 $t$，并从所有的实验仪器向 $t$ 引一条容量为 $\\alpha\\times y$ 的边 跑最大流，$\\big(\\sum x \\big)$-最大流量 即是答案。至于方案，仅需考虑满流的边所连接的节点即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void ISAP:: solve(int M, int N, int tot) &#123;/*&#123;&#123;&#123;*/ static bool used[MAXN]; static std:: stack&lt;int&gt; st; memset(used, 0, sizeof used); s = 0; t = M+N+1; n = M+N+2; int ans = tot-maxflow(); st.push(s); while( !st.empty() ) &#123; int o = st.top(); st.pop(); used[o] = true; for(auto&amp; i: G[o]) &#123; edge&amp; e = edges[i]; if( e.cap &gt; e.flow &amp;&amp; !used[e.to] ) st.push(e.to); &#125; &#125; for(int i=1; i &lt;= M; ++i) if( used[i] ) printf(&quot;%d &quot;, i); putchar(&#x27;\\n&#x27;); for(int i=1; i &lt;= N; ++i) if( used[M+i] ) printf(&quot;%d &quot;, i); putchar(&#x27;\\n&#x27;); printf(&quot;%d\\n&quot;, ans&gt;&gt;16); &#125;const int INF = 0x3f3f3f3f;const int partail = (1&lt;&lt;16)-1;char s[10000], *ss;inline int nextint(char* &amp;s) &#123; for(; *s &lt; &#x27;0&#x27; || *s &gt; &#x27;9&#x27;; s++) if( *s == &#x27;\\n&#x27; ) return -1; int num = 0; for(; *s &gt;= &#x27;0&#x27; &amp;&amp; *s &lt;= &#x27;9&#x27;; s++) num = num*10 + *s-&#x27;0&#x27;; return num;&#125;int main()&#123; int M = read(); int N = read(); int tot = 0; for(int i=1; i &lt;= M; ++i) &#123; for(ss=s; (*ss=getchar()) == &#x27;\\n&#x27;; ); for(ss=s+1; (*ss=getchar()) != &#x27;\\n&#x27;; ++ss); ss = s; int val = nextint(ss)&lt;&lt;16|1; ISAP:: addedge(0, i, val); for(int id; (id=nextint(ss)) != -1;) ISAP:: addedge(i, M+id, INF); tot += val; &#125; for(int i=1; i &lt;= N; ++i) &#123; int val = read()&lt;&lt;16; ISAP:: addedge(M+i, M+N+1, val); &#125; ISAP:: solve(M, N, tot); return 0;&#125;/*&#125;&#125;&#125;*/ 03 **Power OJ/1738 *[最小路径覆盖问题](https://www.oj.swust.edu.cn/problem/show/1738)*** 经典的有向无环图最小路径覆盖问题。 - 最小路径覆盖要求的是有向无环图，将原图每个点拆成两个，显然新图是一个二分图 - 求出二分图最大匹配，最小路径覆盖数=原图点数-新图最大匹配数。 简单证明：初始时可以看做有 $N$ 个长度为 0 的路径，每得到一个匹配相当于合并两条路径。至于方案，从左侧任意一个未访问过的点出发，经沿着交替路走，得到的就是最小路径覆盖中的一条路径。考虑到使用网络流求出路径比较麻烦 = =，仅给出二分图的 增广路算法 的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/const int MAXN = 1000+10;const int INF = 0x3f3f3f3f;namespace hungary &#123; int L, R; std:: vector&lt;int&gt; G[MAXN]; int left[MAXN], right[MAXN]; bool mark[MAXN]; void init(int L=0, int R=0) &#123; hungary:: L = L; hungary:: R = R; for(int u=1; u &lt;= L; ++u ) G[u].clear(); &#125; bool match(int u) &#123; for(int i=0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if( !mark[v] ) &#123; mark[v] = true; if( !left[v] || match(left[v]) ) &#123; left[v] = u; right[u] = v; return true; &#125; &#125; &#125; return false; &#125; void solve() &#123; memset(left, 0, sizeof left); memset(right, 0, sizeof right); int ans = 0; for(int u=1; u &lt;= L; ++u) if( !right[u] ) &#123; memset(mark, 0, sizeof mark); if( match(u) ) ++ans; &#125; memset(mark, 0, sizeof mark); mark[0] = true; for(int o=1; o &lt;= L; ++o) if( !mark[o] ) &#123; mark[o] = true; printf(&quot;%d&quot;, o); for(int u=right[o]; !mark[u]; u=right[u]) &#123; mark[u] = true; printf(&quot; %d&quot;, u); &#125; putchar(&#x27;\\n&#x27;); &#125; printf(&quot;%d\\n&quot;, L-ans); &#125;&#125;;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;int main()&#123; int N = read(); int M = read(); hungary:: init(N, N); for(int i=1; i &lt;= M; ++i) &#123; int u = read(); int v = read(); hungary:: G[u].push_back(v); &#125; hungary:: solve(); return 0;&#125;/*&#125;&#125;&#125;*/ 04 **Power OJ/1739 *[魔术球问题](https://www.oj.swust.edu.cn/problem/show/1739)*** 经典的有向无环图最小路径覆盖问题。 - 同样地，拆点得到二分图结构 - 如果 $\\mu$ 是左侧的点，$\\nu$ 是右侧的点，且 $\\mu+\\nu$ 是一个完全平方数，那么连一条从 $\\mu$ 到 $\\nu$ 的边 - 逐渐加点，直到最小覆盖数超过给定值终止 - 假如在 $N+1$ 的时候终止，可以考虑对于前面 $N$ 个点中会与 $N+1$ 形成完全平方数的点删掉最后一条边，再跑一遍最大匹配。 路径的问题和 03 一样，不再赘述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/const int MAXN = 10000+10;const int INF = 0x3f3f3f3f;namespace hungary &#123; int L, R; bool mark[MAXN]; int left[MAXN], right[MAXN]; std:: vector&lt;int&gt; G[MAXN]; void init(int L=0, int R=0) &#123; hungary:: L = L; hungary:: R = R; for(int u=1; u &lt;= L; ++u ) G[u].clear(); &#125; bool match(int u) &#123; for(int i=0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if( !mark[v] ) &#123; mark[v] = true; if( !left[v] || match(left[v]) ) &#123; left[v] = u; right[u] = v; return true; &#125; &#125; &#125; return false; &#125; int maxmatch() &#123; int ans = 0; for(int u=1; u &lt;= L; ++u) if( !right[u] ) &#123; memset(mark, 0, sizeof mark); if( match(u) ) ++ans; &#125; return ans; &#125; void solve(int N) &#123; static std:: vector&lt;int&gt; A; for(int i=1; i &lt;= 100; ++i) A.push_back(i*i); memset(left, 0, sizeof left); memset(right, 0, sizeof right); init(N, N); for(int i=1; i &lt;= N; ++i) for(auto&amp; a: A) if( a-i &gt;= 1 &amp;&amp; a-i &lt; i ) G[a-i].push_back(i); int ans = maxmatch(); while( true ) &#123; ++L, ++R; for(auto&amp; a: A) if( a-L &gt;= 1 &amp;&amp; a-L &lt; L ) G[a-L].push_back(L); ans += maxmatch(); if( L-ans &gt; N ) break; &#125; for(auto&amp; a: A) if( a-L &gt;= 1 &amp;&amp; a-L &lt; L ) G[a-L].pop_back(); right[left[L]] = 0; --L; --R; maxmatch(); printf(&quot;%d\\n&quot;, L); memset(mark, 0, sizeof mark); mark[0] = true; for(int o=1; o &lt;= L; ++o) if( !mark[o] ) &#123; mark[o] = true; printf(&quot;%d&quot;, o); for(int u=right[o]; !mark[u]; u=right[u]) &#123; mark[u] = true; printf(&quot; %d&quot;, u); &#125; putchar(&#x27;\\n&#x27;); &#125; &#125;&#125;;int main()&#123; int N; std:: cin &gt;&gt; N; hungary:: solve(N); return 0;&#125;/*&#125;&#125;&#125;*/ 05 **Power OJ/1740 *[圆桌问题](https://www.oj.swust.edu.cn/problem/show/1740)*** 经典的二分图多重匹配问题。 - 将不同单位作为左侧点，不同圆桌作为右侧点，每个左侧点与每个右侧点连接一条容量为 1 的边 - 建立源点 $s$，并从 $s$ 向所有的左侧点引一条容量为 $cap\\_i$ （第 $i$ 个单位的人数）的边 - 建立汇点 $t$，并从所有的右侧点向 $t$ 引一条容量为 $cap\\_j$ （第 $j$ 张圆桌的容量）的边 跑最大流。 - 若满流，则有解，方案仅需考虑每个左侧点引出的满流边即可 - 若不能满流，则无解 12345678910111213141516171819202122232425262728293031323334353637void ISAP:: solve(int M, int N, int tot) &#123;/*&#123;&#123;&#123;*/ s = 0; t = M+N+1; n = M+N+2; int ans = maxflow(); if( ans &lt; tot ) &#123; puts(&quot;0&quot;); return; &#125; puts(&quot;1&quot;); for(int o=1; o &lt;= M; ++o) &#123; for(auto&amp; i: G[o]) &#123; edge&amp; e = edges[i]; if( e.cap &gt; 0 &amp;&amp; e.cap == e.flow ) printf(&quot;%d &quot;, e.to-M); &#125; printf(&quot;\\n&quot;); &#125;&#125; int main()&#123; int M = read(); int N = read(); int tot = 0; for(int i=1; i &lt;= M; ++i) &#123; int val = read(); tot += val; ISAP:: addedge(0, i, val); for(int j=1; j &lt;= N; ++j) ISAP:: addedge(i, M+j, 1); &#125; for(int i=1; i &lt;= N; ++i) &#123; int val = read(); ISAP:: addedge(M+i, N+M+1, val); &#125; ISAP:: solve(M, N, tot); return 0;&#125;/*&#125;&#125;&#125;*/ 06 **Power OJ/1741 *[最长递增子序列问题](https://www.oj.swust.edu.cn/problem/show/1741)*** 经典的最多最长不相交路径问题。 不妨记第 $i$ 个数大小为 $A\\_i$。 为了保证每个点只使用一次，拆点。不妨假设原序列第 $i$ 个数对应点 $x\\_i$，将其拆成 $x\\_i$ 和 $x'\\_i$。 1. 定义 $dp[i]$ 为以第 $i$ 个数为结尾的最长上升子序列的长度，$O(N^2)$ 的动态规划 2. 记最长上升子序列长度为 $ans=\\max\\big\\lbrace dp[i] \\big| 1\\leqslant i\\leqslant N\\big\\rbrace$。 - 对于任意 $1\\leqslant i\\leqslant N$，从 $x\\_i$ 向 $x'\\_i$ 引一条容量为 1 的边（以保证第 $i$ 个数只使用一次） - 若 $A\\_i < A\\_j$ 且 $dp[i]+1=dp[j]$，则从 $x\\_i'$ 向 $x\\_j$ 引一条容量为 1 的边 - 建立源点 $s$，从 $s$ 向 $\\big\\lbrace x\\_i \\big| 1\\leqslant i\\leqslant N$ 且 $dp[i]=1 \\big\\rbrace$ 引一条容量为 1 的边 - 建立汇点 $t$，从 $\\big\\lbrace x'\\_i \\big| 1\\leqslant i\\leqslant N$ 且 $dp[i]=ans \\big\\rbrace$ 向 $t$ 引一条容量为 1 的边 跑最大流即可。 3. 在 2. 的基础上，仅需将从源点出发的边及到达汇点的边（不包括反向边）的容量全改为无穷即可 原题描述不严谨，如果第一问答案为 2，第三问中，方案 $\\big\\lbrace x_1,x_N \\big\\rbrace$ 只能记做一次。最后需要注意的是，当 $N=1$ 时，第三问要特判。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int MAXN = 400+10;/*&#123;&#123;&#123;*/const int INF = 0x3f3f3f3f;int dp[MAXN], in[MAXN];int main()&#123; int N = read(); for(int i=1; i &lt;= N; ++i) in[i] = read(); for(int i=1; i &lt;= N; ++i) for(int j=0; j &lt; i; ++j) if( in[i] &gt; in[j] ) dp[i] = std:: max(dp[i], dp[j]+1); int ans = 0; for(int i=1; i &lt;= N; ++i) ans = std:: max(ans, dp[i]); printf(&quot;%d\\n&quot;, ans); for(int i=1; i &lt;= N; ++i) &#123; if( dp[i] == 1 ) ISAP:: addedge(0, i&lt;&lt;1, INF); ISAP:: addedge(i&lt;&lt;1, i&lt;&lt;1|1, 1); if( dp[i] == ans ) ISAP:: addedge(i&lt;&lt;1|1, 1, INF); &#125; for(int i=1; i &lt;= N; ++i) for(int j=i+1; j &lt;= N; ++j) if( in[i] &lt; in[j] &amp;&amp; dp[i]+1 == dp[j] ) ISAP:: addedge(i&lt;&lt;1|1, j&lt;&lt;1, 1); ISAP:: s = 0; ISAP:: t = 1; ISAP:: n = N+1&lt;&lt;1; printf(&quot;%d\\n&quot;, ISAP:: maxflow()); if( ans == 1 ) &#123; printf(&quot;%d\\n&quot;, N); return 0; &#125; for(auto&amp; e: ISAP:: edges) e.flow = 0; for(auto&amp; i: ISAP:: G[2]) &#123; auto&amp; e = ISAP:: edges[i]; if( e.to == 3 ) &#123; e.cap = INF; break; &#125; &#125; for(auto&amp; i: ISAP:: G[N&lt;&lt;1]) &#123; auto&amp; e = ISAP:: edges[i]; if( e.to == (N&lt;&lt;1|1) ) &#123; e.cap = INF; break; &#125; &#125; printf(&quot;%d\\n&quot;, ISAP:: maxflow()); return 0;&#125;/*&#125;&#125;&#125;*/ 07 **COGS/732 *[试题库](http://cojs.tk/cogs/problem/problem.php?pid=732)*** 如 **[05](#05)**，经典的二分图多重匹配问题。 - 将每道题与其所属类型连接一条容量为 1 的边 - 建立源点 $s$，从 $s$ 向每道试题引一条容量为 1 的边 - 建立汇点 $t$，从每个类型向 $t$ 引一条容量为该类型所需要的题数的边 跑最大流，仅当流量为所有类型所需要的题数总和时有解。 123456789101112131415161718192021222324252627282930313233343536373839404142void ISAP:: solve(int K, int N, int limit) &#123;/*&#123;&#123;&#123;*/ s = 0; t = N+K+1; n = N+K+2; if( maxflow() != limit ) &#123; puts(&quot;NoSolution!&quot;); return ; &#125; for(int o=1; o &lt;= K; ++o) &#123; printf(&quot;%d:&quot;, o); for(int i=0; i &lt; G[N+o].size(); ++i) &#123; edge&amp; e = edges[G[N+o][i]]; if( e.to &lt;= N &amp;&amp; e.flow == -1 ) printf(&quot; %d&quot;, e.to); &#125; putchar(&#x27;\\n&#x27;); &#125;&#125; const int MAXN = 400+10;const int INF = 0x3f3f3f3f; int main()&#123;freopen(&quot;testlib.in&quot;, &quot;r&quot;, stdin);freopen(&quot;testlib.out&quot;, &quot;w&quot;, stdout); int K = read(); int N = read(); int limit = 0; for(int i=1; i &lt;= K; ++i) &#123; int val = read(); limit += val; ISAP:: addedge(N+i, N+K+1, val); &#125; for(int i=1; i &lt;= N; ++i) &#123; ISAP:: addedge(0, i, 1); int M = read(); while( M-- ) &#123; int j = read(); ISAP:: addedge(i, N+j, 1); &#125; &#125; ISAP:: solve(K, N, limit); return 0;&#125;/*&#125;&#125;&#125;*/ 08 **Power OJ/1743 *[机器人路径规划问题](https://www.oj.swust.edu.cn/problem/show/1743)*** **暂缺** 09 **Power OJ/1744 *[方格取数问题](https://www.oj.swust.edu.cn/problem/show/1744)*** 经典的二分图点权最大独立集。 将方格二染色得到二分图 - 对于左侧的点，向其对应方格的前后左右方格对应的点连接一条容量为$\\infty$的边 - 建立源点 $s$，从 $s$ 向左侧的点分别引一条`容量为该点所对应的方格中的数`的边 - 建立汇点 $t$，从右侧的点分别引一条`容量为该店所对应的方格中的数`的边 跑最大流，方格中的数的和 - 最大流量 即是答案。 12345678910111213141516171819202122232425262728293031const int INF = 0x3f3f3f3f;/*&#123;&#123;&#123;*/int main()&#123; int row = read(); int col = read(); int tot = 0; int idx = 0; for(int r=1; r &lt;= row; ++r) for(int c=1; c &lt;= col; ++c) &#123; ++idx; int val = read(); tot += val; if( (r+c) &amp; 1 ) ISAP:: addedge(idx, row*col+1, val); else &#123; ISAP:: addedge(0, idx, val); if( c &gt; 1 ) ISAP:: addedge(idx, idx-1, INF); if( r &gt; 1 ) ISAP:: addedge(idx, idx-col, INF); if( c &lt; col ) ISAP:: addedge(idx, idx+1, INF); if( r &lt; row ) ISAP:: addedge(idx, idx+col, INF); &#125; &#125; ISAP:: s = 0; ISAP:: t = row*col + 1; ISAP:: n = row*col + 2; printf(&quot;%d\\n&quot;, tot - ISAP:: maxflow()); return 0;&#125;/*&#125;&#125;&#125;*/ 10 **Power OJ/1745 *[餐巾计划问题](https://www.oj.swust.edu.cn/problem/show/1745)*** 最小费用最大流。 设第 $i$ 天有 $A\\_i$ 条脏毛巾（可以是之前的脏毛巾累积下来的），需要 $B\\_i$ 条干净的毛巾。 将第 $i$ 天拆成两个点 $\\alpha\\_i$，$\\beta\\_i$。 - 建立源点 $s$ * 从 $s$ 向 $\\alpha\\_i$ 引一条容量为 $B\\_i$、`单位流量费用为 0`的边（表示每天会产生 $B\\_i$ 条脏毛巾） * 从 $s$ 向 $\\beta\\_i$ 引一条容量为 $B\\_i$（或者大于等于 $B\\_i$ 皆可）、`单位流量费用为新毛巾的费用`的边（表示每天可以购买的新毛巾数） - 建立汇点 $t$ * 从 $\\beta\\_i$ 向 $t$ 引一条容量为 $B\\_i$、`单位流量费用为 0` 的边（表示每天需要的干净的毛巾数） - 如果 $i+m+1 \\leqslant j$（此 OJ 本题数据有点不一样，应为 $i+m \\leqslant j$），那么从 $A\\_i$ 向 $B\\_j$ 引一条容量为 $\\infty$（大于 $\\displaystyle \\sum\\_{k=1}^i B\\_k$ 即可）、单位流量费用为 $f$ 的边（表示第 $i$ 天快洗可以提供给第 $j$ 天；这里有这样一个事实：如果第 $j+k$ 天需要用到快洗的毛巾，那么大可以将脏毛巾攒到第 $i+k$ 天快洗） - 慢细连边类似 - 最后，对于 $i < N$，从 $A\\_i$ 向 $A\\_{i+1}$ 引一条容量为 $\\infty$、`单位流量费用为 0` 的边（表示每天留下来的脏毛巾可以免费留到第二天洗） 跑最小费用最大流即可，由于每天新毛巾可以直接供应 $B_i$ 条，因此必然可以满流。最小费用即为答案。 123456789101112131415161718192021222324252627const int INF = 0x3f3f3f3f;/*&#123;&#123;&#123;*/int main()&#123; int N = read(); int p = read(); int m = read(); int f = read(); int n = read(); int s = read(); MCMF:: init(0, 1); for(int i=1; i &lt;= N; ++i) &#123; int val = read(); MCMF:: addedge(0, i&lt;&lt;1, val, 0); MCMF:: addedge(0, i&lt;&lt;1|1, val, p); MCMF:: addedge(i&lt;&lt;1|1, 1, val, 0); if( i+1 &lt;= N ) MCMF:: addedge(i&lt;&lt;1, (i+1)&lt;&lt;1, INF, 0); if( i+m &lt;= N ) MCMF:: addedge(i&lt;&lt;1, (i+m)&lt;&lt;1|1, INF, f); if( i+n &lt;= N ) MCMF:: addedge(i&lt;&lt;1, (i+n)&lt;&lt;1|1, INF, s); &#125; std:: pair&lt;int, int&gt; ans = MCMF:: mincostmaxflow(); printf(&quot;%d\\n&quot;, ans.second); return 0;&#125;/*&#125;&#125;&#125;*/ 11 **Power OJ/1746 *[航空路线问题](https://www.oj.swust.edu.cn/problem/show/1746)*** 最大费用最大流。 其实是求两条最长的不相交路径。 - 为了保证每个城市只访问一次，需要拆点；不妨将第 $i$ 个城市拆成 $\\alpha\\_i$ 和 $\\beta\\_i$，且从 $\\alpha\\_i$ 向 $\\beta\\_i$ 引一条容量为 1，费用为 1 的边 - 如果 $i < j$ 且城市 $i$ 和 城市 $j$ 之间有直达航线，那么向 $\\beta\\_i$ 和 $\\alpha\\_j$ 连接一条容量为 1，费用为 0 的边 跑最大费用最大流（只增广两次），方案根据满流边判断即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/namespace MCMF &#123; const int MAXN = 1000+10; const int INF = 0x3f3f3f3f; struct edge &#123; int from, to, cap, flow, cost; edge(int from=0, int to=0, int cap=0, int flow=0, int cost=0): from(from), to(to), cap(cap), flow(flow), cost(cost) &#123;&#125; &#125;; int s, t; int path[MAXN]; int dist[MAXN]; std:: vector&lt;edge&gt; edges; std:: vector&lt;int&gt; G[MAXN]; void addedge(int from, int to, int cap, int cost) &#123; int siz = edges.size(); edges.push_back(edge(from, to, cap, 0, cost)); edges.push_back(edge(to, from, 0, 0, -cost)); G[from].push_back(siz); G[to].push_back(siz+1); &#125; bool SPFA() &#123; static std:: queue&lt;int&gt; Q; static bool inq[MAXN]; memset(dist, 0x3f, sizeof dist); Q.push(s); inq[s] = true; dist[s] = 0; while( !Q.empty() ) &#123; int o = Q.front(); Q.pop(); for(int i=0; i &lt; G[o].size(); ++i) &#123; edge&amp; e = edges[G[o][i]]; if( e.cap &gt; e.flow &amp;&amp; dist[e.to] &gt; dist[o]+e.cost ) &#123; dist[e.to] = dist[o] + e.cost; path[e.to] = G[o][i]; if( inq[e.to] ) continue; inq[e.to] = true; Q.push(e.to); &#125; &#125; inq[o] = false; &#125; return dist[t] != INF; &#125; void DFS(std:: vector&lt;int&gt;&amp; ans, int o) &#123; ans.push_back(o&gt;&gt;1); for(auto&amp; i: G[o]) &#123; edge&amp; e = edges[i]; if( e.flow == 1 ) DFS(ans, e.to|1); &#125; &#125; bool solve(std:: string* in) &#123; static std:: vector&lt;int&gt; ans[2]; for(int i=0; i &lt; 2; ++i) &#123; if( !SPFA() ) return false; for(int o = t; o != s;) &#123; edges[path[o]].flow += 1; edges[path[o]^1].flow -= 1; o = edges[path[o]].from; &#125; &#125; for(auto&amp; i: G[3]) &#123; edge&amp; e = edges[i]; if( e.flow == 2 ) &#123; printf(&quot;%d\\n&quot;, 2); std:: cout &lt;&lt; in[1] &lt;&lt; &quot;\\n&quot; &lt;&lt; in[t&gt;&gt;1] &lt;&lt; &quot;\\n&quot; &lt;&lt; in[1] &lt;&lt; &quot;\\n&quot;; return true; &#125; &#125; ans[0].push_back(s&gt;&gt;1); ans[1].push_back(s&gt;&gt;1); int idx = 0; for(auto&amp; i: G[3]) &#123; edge&amp; e = edges[i]; if( e.flow == 1 ) &#123; DFS(ans[idx++], e.to|1); &#125; &#125; ans[1].pop_back(); std:: reverse(ans[1].begin(), ans[1].end()); printf(&quot;%d\\n&quot;, ans[0].size() + ans[1].size()-1); for(auto&amp; a: ans[0]) std:: cout &lt;&lt; in[a] &lt;&lt; &quot;\\n&quot;; for(auto&amp; a: ans[1]) std:: cout &lt;&lt; in[a] &lt;&lt; &quot;\\n&quot;; return true; &#125;&#125;;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;const int MAXN = 100+10;const int INF = 0x3f3f3f3f;std:: unordered_map&lt;std:: string, int&gt; ump;std:: string in[MAXN];int main()&#123; int N = read(); int M = read(); for(int i=1; i &lt;= N; ++i) &#123; std:: cin &gt;&gt; in[i]; ump[in[i]] = i; if( i == 1 || i == N ) MCMF:: addedge(i&lt;&lt;1, i&lt;&lt;1|1, 2, -1); else MCMF:: addedge(i&lt;&lt;1, i&lt;&lt;1|1, 1, -1); &#125; for(int i=1; i &lt;= M; ++i) &#123; std:: string s, t; std:: cin &gt;&gt; s &gt;&gt; t; int ids = ump[s]; int idt = ump[t]; if( ids &gt; idt ) std:: swap(ids, idt); if( ids == 1 &amp;&amp; idt == N ) MCMF:: addedge(ids&lt;&lt;1|1, idt&lt;&lt;1, 2, 0); else MCMF:: addedge(ids&lt;&lt;1|1, idt&lt;&lt;1, 1, 0); &#125; MCMF:: s = 1&lt;&lt;1; MCMF:: t = N&lt;&lt;1|1; if( !MCMF:: solve(in) ) puts(&quot;No Solution!&quot;); return 0;&#125;/*&#125;&#125;&#125;*/ 12 **Power OJ/1747 *[软件补丁问题](https://www.oj.swust.edu.cn/problem/show/1747)*** 更像一个状压 $dp$。 抽象出图的结构，跑最短路即可。 定义 $s$ 为当前软件的错误状态，如果 $s$ 中包含 $B1[i]$ 的所有错误，且不包含 $B2[i]$ 中的所有错误，那么存在一条从 $s$ 到 $s-F1[i]+F2[i]$（这里的‘-’指集合运算），且花费为 $cost[i]$ 的边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/namespace solve &#123; const int INF = 0x3f3f3f3f; const int MAXN = (1&lt;&lt;20) + 10; struct node &#123; int B1, B2; int F1, F2; int cost; node(int B1=0, int B2=0, int F1=0, int F2=0, int cost=0): B1(B1), B2(B2), F1(F1), F2(F2), cost(cost) &#123;&#125; &#125;; int s, t; int dist[MAXN]; std:: vector&lt;node&gt; nodes; void update(char* s, int&amp; x, int&amp; y) &#123; x = y = 0; for(int i=0; s[i]; ++i) &#123; if( s[i] == &#x27;+&#x27; ) x |= 1&lt;&lt;i; else if( s[i] == &#x27;-&#x27; ) y |= 1&lt;&lt;i; &#125; &#125; int SPFA() &#123; static bool inq[MAXN]; static std:: queue&lt;int&gt; Q; memset(dist, 0x3f, sizeof dist); Q.push(s); dist[s] = 0; inq[s] = true; while( !Q.empty() ) &#123; int o = Q.front(); Q.pop(); for(auto&amp; e: nodes) &#123; if( (o&amp;e.B1) == e.B1 &amp;&amp; (o&amp;e.B2) == 0 ) &#123; int u = (o&amp;e.F1) | e.F2; if( dist[u] &gt; dist[o]+e.cost ) &#123; dist[u] = dist[o]+e.cost; if( !inq[u] ) &#123; inq[u] = true; Q.push(u); &#125; &#125; &#125; &#125; inq[o] = false; &#125; return dist[t] != INF? dist[t]: 0; &#125;&#125;;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;int main()&#123; int N = read(); int M = read(); int B1, B2, F1, F2, cost, re; char in[100]; re = (1&lt;&lt;N)-1; for(int i=0; i &lt; M; ++i) &#123; cost = read(); scanf(&quot;%s&quot;, in); solve:: update(in, B1, B2); scanf(&quot;%s&quot;, in); solve:: update(in, F2, F1); F1 = re^F1; solve:: nodes.push_back(solve:: node(B1, B2, F1, F2, cost)); &#125; solve:: s = re; solve:: t = 0; printf(&quot;%d\\n&quot;, solve:: SPFA()); return 0;&#125;/*&#125;&#125;&#125;*/ 汇总 problems categories solution code Power OJ/1736 二分图最大匹配 01 Code Power OJ/1737 最大权闭合图 02 Code Power OJ/1738 最小路径覆盖 03 Code Power OJ/1739 最小路径覆盖 04 Code Power OJ/1740 二分图多重匹配 05 Code Power OJ/1741 最多最长不相交路径 06 Code COGS/732 二分图多重匹配 07 Code Power OJ/1743 暂缺 08 暂缺 Power OJ/1744 二分图点权最大独立集 09 Code Power OJ/1745 最小费用最大流（难在建图） 10 Code Power OJ/1746 最大费用最大流 11 Code","tags":[{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"二分图","slug":"二分图","permalink":"http://littleclown.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"网络流","slug":"网络流","permalink":"http://littleclown.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"专题训练","slug":"专题训练","permalink":"http://littleclown.github.io/tags/%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/"}]},{"title":"网络流基础之最大权闭合图","date":"2016-07-24T06:06:44.000Z","path":"study/codding/graph-theory/network-flow/maximum-weight-Closure-of-a-Graph/","text":"概念对于有向图 $G=(V,E)$，其中 $V$ 为 $G$ 的点集，$E$ 为 $G$ 的边集。 割集: 一个 $s$–$t$ 割 $[S,T]$ 是 $V$ 的一种划分，使得 $s\\in S$、$t\\in T$ 最小割: 一个 $s$–$t$ 割的容量是 $\\displaystyle c(S,T) = \\sum_{(\\mu,\\nu) \\in (S\\times T)\\bigcap E} c(\\mu,\\nu)$；容量最小的割集称为最小割 简单割：若一个 $s$–$t$ 割满足割中的每条边都只与源点 $s$ 或汇点 $t$ 相连，则称该割为简单割 闭合图：若点集 $V’ \\in V$ 是一个闭合图，那么对于 $\\forall \\left&lt; \\mu, \\nu\\right &gt; \\in E$，若 $\\mu \\in V’$ 则必有 $\\nu \\in V’$ 最大权闭合图： 一个点权和最大的闭合图 上图中，有 9 个闭合图（含空集）：$\\emptyset$，$\\lbrace 3,4,5 \\rbrace$，$\\lbrace 4,5 \\rbrace$，$\\lbrace 5 \\rbrace$，$\\lbrace 1,2,4,5 \\rbrace$，$\\lbrace 2,5 \\rbrace$，$\\lbrace 2,4,5 \\rbrace$，$\\lbrace 2,3,4,5 \\rbrace$，$\\lbrace 1,2,3,4,5 \\rbrace$。其中，惟一的最大权闭合图为 $\\lbrace 3,4,5 \\rbrace$，且权和为 4。 最大流最小割定理设 $f$ 为流网络 $G=(V,E)$ 中的一个流, 该流网络的源节点为 $s$, 汇点为 $t$, 则下面的条件是等价的: $f$ 是 $G$ 的一个最大流 残流网络 $G_f$ 不包含任何增广路径 $|f|=c(S,T)$, 其中 $[S,T]$ 是流网络 $G$ 的最小割 构造将原图转化为网络 $N=(V_N, E_N)$： 将原图中的所有有向边 $\\left&lt; \\mu, \\nu\\right &gt; \\in E$ 替换为容量为 $c(\\mu,\\nu)=\\infty$ 的有向边 $\\left&lt; \\mu,\\nu \\right &gt; \\in E_N$ 在此基础上增加源点 $s$ 和汇点 $t$ 由源点向原图中的所有正权点 $\\nu(\\omega_\\nu &gt; 0)$ 连接一条容量为 $c(s,\\nu)=\\omega_\\nu$ 的有向边 $\\left&lt; s,\\nu \\right &gt; \\in E_N$ 由原图中的所有负权点 $\\nu(\\omega_\\nu &lt; 0)$ 连接一条容量为 $c(\\nu,t)=-\\omega_\\nu$ 的有向边 $\\left&lt; \\nu,t \\right &gt; \\in E_N$ 也就是\\begin{align}&amp;V_N=V \\bigcup \\lbrace s,t \\rbrace \\&amp;E_N=E \\bigcup \\big\\lbrace \\left&lt; s,\\nu \\right&gt; \\big| \\nu\\in V, \\omega_\\nu &gt; 0 \\big\\rbrace \\bigcup \\big\\lbrace \\left&lt; \\nu,t \\right&gt; \\big| \\nu\\in V, \\omega_\\nu &lt; 0 \\big\\rbrace \\&amp;\\left \\lbrace \\begin{aligned}&amp;c(\\mu,\\nu)=\\infty &amp; \\left&lt; \\mu,\\nu \\right&gt; \\in E \\&amp;c(s,\\nu)=\\omega_\\nu &amp; \\omega_\\nu &gt; 0 \\&amp;c(\\nu,t)=-\\omega_\\nu &amp; \\omega_\\nu &lt; 0\\end{aligned} \\right.\\end{align} 这里 $\\displaystyle \\infty &gt; \\sum_{\\nu \\in V} \\big| W_\\nu \\big|$。 原图 $G$ 构成的网络 $N$ 如下图 先给出结论： 若 原图所有正权点的点权和为 $totalval$ 对该网络跑最大流，且最大流为 $maxflow$， 所得到的最小割为 $[S,T]$ 那么 原图的最大权闭合图的权和为 $totalval-maxflow$ 并且，$S-\\lbrace s \\rbrace$ 为原图点数最少的最大权闭合图 证明【引理 1】 本问题的网络 $N$ 中，最小割是简单割。简单地说明一下，由于除与源点 $s$ 或汇点 $t$ 直接相连的边的容量是有限的，其它边是无限的，那么最小割中显然不会出现容量为无限的边（因为强行割断所有与源点相连的边可以构成一个割集，且割的容量是有限的，最小割的容量不会比这个大），所以该最小割是简单割。 记 $G_1$ 是原图 $G$ 的一个 闭合子图，$V_1$ 为 $G_1$ 的点集；$\\overline{V_1}$ 为点集 $V_1$ 在原图 $G$ 中的补集，即 $V_1 \\bigcup \\overline{V_1}=V$。【引理 2】 网络 $N$ 的简单割 $[S,T]$ 与图 $G$ 的闭合子图 $G_1$ 存在一个一一对应关系：$V_1 \\bigcup \\lbrace s \\rbrace = S$。 闭合图对应简单割：即 $S=V_1 \\bigcup \\lbrace s \\rbrace$，$T=\\overline{V_1} \\bigcup \\lbrace t \\rbrace$，求证 $[S,T]$ 为简单割。 因为 $V_1$ 是一个闭合图，所以不存在 $\\left&lt; \\mu,\\nu \\right&gt; \\in E$，其中 $\\mu \\in S-\\lbrace s \\rbrace$，$\\nu \\in T-\\lbrace t \\rbrace$。也就是不存在不与源汇有关联的边，其两个端点分别在 $V_1$ 和 $\\overline{V_1}$ 中，所以 $[S,T]$ 是一个割集。由 引理 1 可知，$[S,T]$ 是一个简单割。 简单割对应闭合图：即证明 $V_1=S-\\lbrace s \\rbrace$ 是一个闭合图。 若 $\\mu \\in S-\\lbrace s \\rbrace$，$\\nu \\in T-\\lbrace t \\rbrace$；显然不存在边 $\\left&lt; \\mu,\\nu \\right&gt; \\in E$，否则与 $[S,T]$ 是割集矛盾（因为 $c(\\mu,\\nu)=\\infty$）。 记 $V^+$ 为 $V$ 中 点权为正 的最大点集，$V^-$ 为 $V$ 中 点权为负 的最大点集；类似地，定义 $V_1^+$、$V_1^-$、$\\overline{V_1}^+$、$\\overline{V_1}^-$。【引理 3】 在 引理 2 的一 一对应关系下（即 $V_1\\bigcup\\lbrace s \\rbrace=S$、$\\overline{V_1}\\bigcup\\lbrace t \\rbrace=T$），有：$$\\displaystyle c[S,T]=\\sum_{\\nu\\in \\overline{V_1}^+} \\omega_\\nu + \\sum_{\\nu\\in V_1^-} \\left( -\\omega_\\nu \\right) \\tag{1}$$ 显然，$\\displaystyle \\Big[S,T\\Big] = \\left[\\lbrace s\\rbrace,\\overline{V_1}\\right] \\bigcup \\Big[\\lbrace t\\rbrace,V_1\\Big] \\bigcup \\left[\\overline{V_1},V_1\\right]$ （分析构造图的源汇关联情况不难得出结论） $[S,T]$ 是简单割，故 $\\left[\\overline{V_1},V_1\\right] = \\emptyset$ $s$ 只与正权点连边，故 $\\left[\\lbrace s\\rbrace,\\overline{V_1}\\right] = \\left[\\lbrace s\\rbrace,\\overline{V_1}^+\\right] $ $t$ 只与负权点连边，故 $\\left[\\lbrace t\\rbrace,V_1\\right] = \\left[\\lbrace t\\rbrace,V_1^-\\right] $ 因此，$\\displaystyle \\Big[S,T\\Big] = \\left[\\lbrace s\\rbrace,\\overline{V_1}^+\\right] \\bigcup \\Big[\\lbrace t\\rbrace,V_1^-\\Big]$；即可证明 (1) 式 【引理 4】（最优性） 当网络 $N$ 取得最小割时，其对应的图 $G$ 的闭合图（$V_1=S-{s}$）将取得最大权 按照定义，闭合图的权值为 正权点的权的绝对值和 - 负权点的权的绝对值和，即 $$\\omega(V_1) = \\sum_{\\nu\\in V_1^+}\\omega_\\nu - \\sum_{\\nu\\in V_1^-}(-\\omega_\\nu) \\tag{2}$$ 由 (1)、(2) 式，可得： \\begin{align} \\omega(V_1) + c[S,T] &amp;= \\sum_{\\nu\\in V_1^+}\\omega_\\nu - \\sum_{\\nu\\in V_1^-}(-\\omega_\\nu) + \\sum_{\\nu\\in \\overline{V_1}^+} \\omega_\\nu + \\sum_{\\nu\\in V_1^-} \\left( -\\omega_\\nu \\right) \\ &amp;= \\sum_{\\nu\\in V_1^+}\\omega_\\nu + \\sum_{\\nu\\in \\overline{V_1}^+} \\omega_\\nu \\ &amp;= \\sum_{\\nu\\in V^+} \\omega_\\nu \\end{align} 整理得： $$\\omega(V_1) = \\sum_{\\nu\\in V^+}\\omega_\\nu - c[S,T]$$ Hint参考资料：***《最小割模型在信息学竞赛中的应用》--by 胡伯涛***","tags":[{"name":"网络流","slug":"网络流","permalink":"http://littleclown.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://littleclown.github.io/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/"}]},{"title":"2016 多校第 2 场","date":"2016-07-22T11:14:40.000Z","path":"acm/contest/multi-university-training/2016/2/","text":"1004 Differencia题目链接 题目描述有两个序列：$\\displaystyle \\big\\lbrace a_1, a_2, \\cdots, a_n \\big\\rbrace$，$\\displaystyle \\big\\lbrace b_1, b_2, \\cdots, b_n \\big\\rbrace$有两种操作： $+lr~x$ 将所有的 $a_i(l \\leqslant i\\leqslant r)$ 置为 $x$ $?lr$ 询问 $l\\leqslant i\\leqslant r$ 中有多少个 $i$ 满足 $a_i \\geqslant b_i$ 数据范围：$1\\leqslant n\\leqslant 10^5$，$3\\times 10^6$ 次询问，强制在线。 题目简析将 $B$ 数组建成归并树（用线段树实现即可），并预处理出初始的 $a_i \\geqslant b_i$ 的前缀和，用该线段树维护。那么，对于每次查询就是简单的线段树区间求和问题，复杂度为 $O(n\\log n)$。由于修改操作是将一个区间内所有的 $a_i$ 置为 $x$，区间修改将影响线段树中 $O(\\log n)$ 个节点；对于每个节点，直接二分即可知道有多少这个区间内有多少个点满足 $b_i \\leqslant x$ 了。这么做的时间复杂度是 $O(n\\log n + q\\log^2 n)$ 的，遗憾的是，出题人只给 $O(n\\log n)$ 以下的复杂度过。如果预处理初每个节点所维护的区间中每个节点在左右子节点中的 $rank$，这个可以线扫，总复杂度为 $O(n\\log n)$；不难发现，每次在节点所维护的区间内查找有多少个点小于等于 $x$ 操作仅需在根节点处二分一次，之后 $O(1)$ 转移，复杂度降为 $O((n+q)\\log n)$。 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;/*&#123;&#123;&#123;*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;namespace solve &#123; const int MAXN = 100000+10; int A[MAXN], B[20][MAXN], L[20][MAXN], R[20][MAXN]; int sumv[MAXN&lt;&lt;2], setv[MAXN&lt;&lt;2], posv[MAXN&lt;&lt;2]; inline void build(int o, int lft, int rht, int cur=0) &#123; setv[o] = 0; if( lft == rht ) &#123; B[cur][lft] = read(); sumv[o] = A[lft] &gt;= B[cur][lft]? 1: 0; &#125; else &#123; int mid = lft+rht &gt;&gt; 1; build(o&lt;&lt;1, lft, mid, cur+1); build(o&lt;&lt;1|1, mid+1, rht, cur+1); int tot = lft, i = lft, j = mid+1; for(; i &lt;= mid &amp;&amp; j &lt;= rht;) if( B[cur+1][i] &lt;= B[cur+1][j] ) B[cur][tot++] = B[cur+1][i++]; else B[cur][tot++] = B[cur+1][j++]; for(; i &lt;= mid;) B[cur][tot++] = B[cur+1][i++]; for(; j &lt;= rht;) B[cur][tot++] = B[cur+1][j++]; sumv[o] = sumv[o&lt;&lt;1] + sumv[o&lt;&lt;1|1]; // 计算区间 [lft,rht] 的每个节点在左右子节点中的 rank L[cur][lft] = lft; R[cur][lft] = mid+1; for(int&amp; l=L[cur][lft]; l &lt;= mid &amp;&amp; B[cur+1][l] &lt;= B[cur][lft]; ++l); for(int&amp; r=R[cur][lft]; r &lt;= rht &amp;&amp; B[cur+1][r] &lt;= B[cur][lft]; ++r); --L[cur][lft]; --R[cur][lft]; for(int i=lft+1; i &lt;= rht; ++i) &#123; L[cur][i] = L[cur][i-1]+1; R[cur][i] = R[cur][i-1]+1; for(int&amp; l=L[cur][i]; l &lt;= mid &amp;&amp; B[cur+1][l] &lt;= B[cur][i]; ++l); for(int&amp; r=R[cur][i]; r &lt;= rht &amp;&amp; B[cur+1][r] &lt;= B[cur][i]; ++r); --L[cur][i]; --R[cur][i]; &#125; &#125; &#125; inline void pushdown(int o, int lft, int rht, int cur) &#123; int lc = o&lt;&lt;1, rc = o&lt;&lt;1|1, mid = lft+rht&gt;&gt;1; setv[lc] = setv[o]; posv[lc] = posv[o] &gt;= lft? L[cur][posv[o]]: lft-1; setv[rc] = setv[o]; posv[rc] = posv[o] &gt;= lft? R[cur][posv[o]]: mid; sumv[lc] = posv[lc]-lft+1; sumv[rc] = posv[rc]-mid; setv[o] = 0; &#125; int ul, ur, uv; inline void update(int o, int lft, int rht, int pos, int cur=0) &#123; if( lft == rht ) &#123; sumv[o] = uv &gt;= B[cur][lft]? 1: 0; return ; &#125; if( ul &lt;= lft &amp;&amp; rht &lt;= ur ) &#123; int mid = lft+rht &gt;&gt; 1; setv[o] = uv; posv[o] = pos; sumv[o] = pos-lft+1; &#125; else &#123; if( setv[o] ) pushdown(o, lft, rht, cur); int mid = lft+rht &gt;&gt; 1; if( ul &lt;= mid ) update(o&lt;&lt;1, lft, mid, pos &gt;= lft? L[cur][pos]: lft-1, cur+1); if( mid &lt; ur ) update(o&lt;&lt;1|1, mid+1, rht, pos &gt;= lft? R[cur][pos]: mid, cur+1); sumv[o] = sumv[o&lt;&lt;1] + sumv[o&lt;&lt;1|1]; &#125; &#125; int ql, qr; inline int query(int o, int lft, int rht, int cur=0) &#123; if( ql &lt;= lft &amp;&amp; rht &lt;= qr ) return sumv[o]; if( setv[o] ) pushdown(o, lft, rht, cur); int mid = lft+rht &gt;&gt; 1; int ans = 0; if( ql &lt;= mid ) ans += query(o&lt;&lt;1, lft, mid, cur+1); if( mid &lt; qr ) ans += query(o&lt;&lt;1|1, mid+1, rht, cur+1); return ans; &#125;&#125;;typedef long long LL;const int MOD = 1000000000+7;const int C = ~(1&lt;&lt;31);const int M = (1&lt;&lt;16)-1;int n, m, A, B, a, b, last;inline int rnd(int last) &#123; a = (36969 + (last &gt;&gt; 3)) * (a &amp; M) + (a &gt;&gt; 16); b = (18000 + (last &gt;&gt; 3)) * (b &amp; M) + (b &gt;&gt; 16); return (C &amp; ((a &lt;&lt; 16) + b)) % 1000000000;&#125;int main()&#123; int T_T = read(); for(int kase=1; kase &lt;= T_T; ++kase) &#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;A, &amp;B); for(int i=1; i &lt;= n; ++i) solve:: A[i] = read(); solve:: build(1, 1, n); LL ans = 0LL; a = A, b = B, last = 0; for(int i=1; i &lt;= m; ++i) &#123; int l = rnd(last) % n + 1; int r = rnd(last) % n + 1; int x = rnd(last) + 1; if( l &gt; r ) std:: swap(l, r); if( (l + r + x) &amp; 1 ) &#123; solve:: ul = l; solve:: ur = r; solve:: uv = x; int pos = std:: upper_bound(solve:: B[0]+1, solve:: B[0]+n+1, x)-solve:: B[0]-1; solve:: update(1, 1, n, pos); &#125; else &#123; solve:: ql = l; solve:: qr = r; last = solve:: query(1, 1, n); ans = (ans + (LL) i * last) % MOD; &#125; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125;/*&#125;&#125;&#125;*/","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"训练赛","slug":"训练赛","permalink":"http://littleclown.github.io/tags/%E8%AE%AD%E7%BB%83%E8%B5%9B/"}]},{"title":"二分图","date":"2016-07-17T06:44:22.000Z","path":"study/codding/graph-theory/bipartite-graph/bipartite-graph/","text":"概念点覆盖 (vertex covering) 点覆盖： 一个点集，满足所有边都至少有一个端点在集合中 极小点覆盖： 本身是一个点覆盖，但任意一个真子集都不是点覆盖 最小点覆盖： 点数最少的点覆盖 点覆盖数： 最小点覆盖的点数 边覆盖 (edge covering) 边覆盖： 一个边集，满足所有顶点都是集合中至少一条边的一个端点 极小边覆盖： 本身是一个边覆盖，但任意一个真子集都不是边覆盖 最小边覆盖： 边数最少的边覆盖 边覆盖数： 最小边覆盖的边数 团 (clique) 团： 一个点集，满足集合中任意两点相邻 极大团： 本身是一个团，但再加入任意个点都不再是团 最大团： 点数最多的团 团数： 最大团的点数 独立集 (independent set) 独立集： 一个点集，满足集合中的任意两点都不相邻 极大独立集： 本身是一个独立集，但再加入任意个点都不再是独立集 最大独立集： 点数最多的独立集 独立数： 最大独立集的点数 边独立集 (edge independent set) 边独立集： 一个边集，满足集合中的任意两条边都没有公共端点 极大边独立集： 本身是一个边独立集，但再加入任意条边都不再是边独立集 最大边独立集： 边数最多的边独立集 边独立数： 最大边独立集的边数 支配集 (dominating set) 支配集： 一个点集，满足集合外其它点都至少有一个相邻的点在集合中 极小支配集： 本身是一个支配集，但再加入任意个点都不再是支配集 最小支配集： 点数最少的支配集 支配数： 最小支配集的点数 边支配集 (edge dominating set) 边支配集： 一个边集，满足集合外其它边都至少有一条相邻的边在集合中 极小边支配集： 本身是一个边支配集，但再加入任意条边都不再是边支配集 最小边支配集： 边数最少的边支配集 边支配数： 最小边支配集的边数 匹配 (matching) 匹配： 一个两两没有共同顶点的边集，又称 边独立集 匹配点： 在匹配中的点，又称 饱和点 未匹配点： 不在匹配中的点，又称 未饱和点 最大匹配： 边最多的匹配 完备匹配： 匹配了二分图较小集合（左侧的点集和右侧点集中较小的点集）的所有点的匹配 完美匹配： 匹配了所有点的匹配 匹配数： 最大匹配的边数 交替路： 图的一条简单路径，满足路径上任意相邻的两条边，一条在匹配内，一条不在匹配内 增广路： 起始点与终止点都为未匹配点的交替路 定理增广路定理： 一个匹配是最大匹配当且仅当不存在增广路。König定理：最小点覆盖数 $=$ 最大匹配数。证明见 附录 性质Hint参考链接 实现增广路算法12345678910111213141516171819202122232425262728293031323334353637383940namespace hungary &#123;/*&#123;&#123;&#123;*/ int L, R; std:: vector&lt;int&gt; G[MAXN]; int left[MAXN], right[MAXN]; bool lmark[MAXN], rmark[MAXN]; void init(int L=0, int R=0) &#123; hungary:: L = L; hungary:: R = R; for(int u=1; u &lt;= L; ++u ) G[u].clear(); &#125; bool match(int u) &#123; lmark[u] = true; for(auto&amp; v: G[u]) if( !rmark[v] ) &#123; rmark[v] = true; if( !left[v] || match(left[v]) ) &#123; left[v] = u; right[u] = v; return true; &#125; &#125; return false; &#125; int solve() &#123; memset(left, 0, sizeof left); memset(right, 0, sizeof right); int ans = 0; for(int u=1; u &lt;= L; ++u) if( !right[u] ) &#123; memset(lmark, 0, sizeof lmark); memset(rmark, 0, sizeof rmark); if( match(u) ) ++ans; &#125; return ans; &#125;&#125;/*&#125;&#125;&#125;*/ 附录König定理证明 如左图所示，粗线构成了最大匹配。显然，最大匹配中， 任意一个匹配点不会同时和两个以上的未匹配点直接或间接相连，（否则就会存在增广路，这与最大匹配矛盾）。 任意一个未配点出发的边都直接连向匹配点（理由同上） 所以，对于每一条匹配边，至多只有一个未匹配点与其直接相邻；若选择与该未匹配点相邻的匹配点作为覆盖点，则可同时覆盖一条匹配边和一条与未匹配点相邻的边。不难发现：将所有与未匹配点直接相邻的匹配点选为覆盖点，并将剩下的没有端点为覆盖点的匹配边中任选一个端点作为覆盖点，则构成最小覆盖集。而这个集合的大小显然和最大匹配个数是相等的。 算法从二分图左侧所有未匹配点出发，扩展出匈牙利树，并将经过的点标记。则*** 左侧未标记点 与右侧 标记点 ***是最小覆盖集。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace hungary &#123;/*&#123;&#123;&#123;*/ int L, R; std:: vector&lt;int&gt; G[MAXN]; int left[MAXN], right[MAXN]; bool lmark[MAXN], rmark[MAXN]; void init(int L=0, int R=0) &#123; hungary:: L = L; hungary:: R = R; for(int u=1; u &lt;= L; ++u ) G[u].clear(); &#125; bool match(int u) &#123; lmark[u] = true; for(auto&amp; v: G[u]) if( !rmark[v] ) &#123; rmark[v] = true; if( !left[v] || match(left[v]) ) &#123; left[v] = u; right[u] = v; return true; &#125; &#125; return false; &#125; int solve() &#123; memset(left, 0, sizeof left); memset(right, 0, sizeof right); int ans = 0; for(int u=1; u &lt;= L; ++u) if( !right[u] ) &#123; memset(lmark, 0, sizeof lmark); memset(rmark, 0, sizeof rmark); if( match(u) ) ++ans; &#125; memset(lmark, 0, sizeof lmark); memset(rmark, 0, sizeof rmark); for(int u=1; u &lt;= L; ++u) if( !right[u] ) match(u); printf(&quot;left:&quot;); for(int u=1; u &lt;= L; ++u) if( !lmark[u] ) printf(&quot; %d&quot;, u); printf(&quot;\\n&quot;); printf(&quot;right:&quot;); for(int v=1; v &lt;= R; ++v) if( rmark[v] ) printf(&quot; %d&quot;, v); printf(&quot;\\n&quot;); return ans; &#125;&#125;/*&#125;&#125;&#125;*/","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://littleclown.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"二分图","slug":"二分图","permalink":"http://littleclown.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"图论","slug":"图论","permalink":"http://littleclown.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"伸展树专题","date":"2016-07-03T03:07:47.000Z","path":"acm/special-topic/datastructure/tree/bbst/splay/","text":"题目UVa/11922 Permutation Transformer基础题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/using namespace std;struct node &#123; int key; int siz; bool flip; node* lson; node* rson; node(int key=0): key(key), siz(0), flip(0), lson(NULL), rson(NULL) &#123;&#125; int cmp(int key) &#123; int cnt = lson-&gt;siz + 1; if( key == cnt ) return -1; return key &lt; cnt? 0: 1; &#125; void pushdown() &#123; if( !flip ) return; lson-&gt;flip ^= 1; rson-&gt;flip ^= 1; swap(lson, rson); flip = false; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;typedef pair&lt;node*, node*&gt; droot;const int MAX_NODES = 100000+10;node* null = new node();node nodepool[MAX_NODES];node* nodetop;inline node* newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;flip = false; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void zag(root&amp; o) &#123; node* k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; node* k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz + 1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz + 1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;pushdown(); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;inline void build(root&amp; o, int lft, int rht) &#123; int mid = (lft+rht) &gt;&gt; 1; o = newnode(mid); if( lft &lt; mid ) build(o-&gt;lson, lft, mid-1); if( mid &lt; rht ) build(o-&gt;rson, mid+1, rht); o-&gt;maintain();&#125;inline void print(root&amp; o) &#123; if( o == null ) return; o-&gt;pushdown(); if( o-&gt;lson != null ) print(o-&gt;lson); if( o-&gt;key ) printf(&quot;%d\\n&quot;, o-&gt;key); if( o-&gt;rson != null ) print(o-&gt;rson);&#125;root rt;inline void init(int N) &#123; nodetop = nodepool; build(rt, 0, N);&#125;int main()&#123; int N, Q; while( scanf(&quot;%d%d&quot;, &amp;N, &amp;Q) == 2 ) &#123; init(N); while( Q-- ) &#123; int lft, rht; root o, left, middle, right; scanf(&quot;%d%d&quot;, &amp;lft, &amp;rht); split(rt, lft, left, o); split(o, rht-lft+1, middle, right); middle-&gt;flip ^= 1; rt=merge(merge(left, right), middle); &#125; print(rt); &#125; return 0;&#125;/*&#125;&#125;&#125;*/ UVa/11996 Jewel Magic用 hash 求 LCP，仅需用 splay 维护 hash 值即可。考虑到用反转操作，每个节点需要维护正反两个 hash 值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/using namespace std;typedef unsigned long long ULL;const int MAXN = 400000+10;const int hashkey = 137;ULL xp[MAXN];struct node &#123; int key; int siz; ULL val; ULL reval; bool flip; node* lson; node* rson; int cmp(int x) &#123; int cnt = lson-&gt;siz + 1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void reverse() &#123; flip ^= 1; swap(lson, rson); swap(val, reval); &#125; void pushdown() &#123; if( !flip ) return; lson-&gt;reverse(); rson-&gt;reverse(); flip = false; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; val = lson-&gt;val + key*xp[lson-&gt;siz] + rson-&gt;val*xp[lson-&gt;siz+1]; reval = rson-&gt;reval + key*xp[rson-&gt;siz] + lson-&gt;reval*xp[rson-&gt;siz+1]; &#125;&#125;;typedef node* root;typedef pair&lt;node*, node*&gt; droot;const int MAX_NODES = 400000+10;node* null;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;val = 0; nodetop-&gt;reval = 0; nodetop-&gt;flip = false; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void zag(root&amp; rt) &#123; root k = rt-&gt;rson; rt-&gt;rson = k-&gt;lson; k-&gt;lson = rt; rt = k;&#125;inline void zig(root&amp; rt) &#123; root k = rt-&gt;lson; rt-&gt;lson = k-&gt;rson; k-&gt;rson = rt; rt = k;&#125;inline void rotate(root&amp; rt, int d) &#123; d? zig(rt): zag(rt); d? rt-&gt;rson-&gt;maintain(): rt-&gt;lson-&gt;maintain(); rt-&gt;maintain();&#125;inline void splay(root&amp; rt, int k) &#123; rt-&gt;pushdown(); int d = rt-&gt;cmp(k); if( d == 1 ) k -= rt-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; pt = d? rt-&gt;rson: rt-&gt;lson; pt-&gt;pushdown(); int d2 = pt-&gt;cmp(k); if( d2 == 1 ) k -= pt-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? pt-&gt;rson: pt-&gt;lson), k); if( d == d2 ) rotate(rt, d^1); else rotate(pt, d); &#125; rotate(rt, d^1); &#125;&#125;inline void split(root rt, int k, root&amp; left, root&amp; right) &#123; splay(rt, k); left = rt; right = rt-&gt;rson; rt-&gt;rson = null; rt-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;/* insert at (k+1)th position. */inline void insert(root&amp; rt, int k, int key) &#123; root left, right; root middle = newnode(key); split(rt, k, left, right); rt = merge(merge(left, middle), right);&#125;/* remove at (k+1)th position. */inline void remove(root&amp; rt, int k) &#123; root left, middle, right; split(rt, k, left, right); split(right, 1, middle, right); rt = merge(left, right);&#125;/* modify [lft+1, rht+1]. */inline void update(root&amp; rt, int lft, int rht) &#123; splay(rt, lft); splay(rt-&gt;rson, rht-lft+2); rt-&gt;rson-&gt;lson-&gt;reverse(); /* update rt-&gt;rson-&gt;lson, rt-&gt;rson, rt */ rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;inline int query(root&amp; rt, int p1, int p2) &#123; int lft = 0, rht = rt-&gt;siz - p2; while( lft &lt; rht ) &#123; int mid = (lft+rht) &gt;&gt; 1; splay(rt, p1); splay(rt-&gt;rson, mid+1); ULL val1 = rt-&gt;rson-&gt;lson-&gt;val; splay(rt, p2); splay(rt-&gt;rson, mid+1); ULL val2 = rt-&gt;rson-&gt;lson-&gt;val; if( val1 == val2 ) lft = mid+1; else rht = mid; &#125; return lft-1;&#125;root rt;char s[MAXN];int N, Q, op, arg1, arg2;inline void build(root&amp; rt, int lft, int rht) &#123; int mid = (lft+rht) &gt;&gt; 1; rt = newnode(s[mid]-&#x27;0&#x27;); if( lft &lt; mid ) build(rt-&gt;lson, lft, mid-1); if( mid &lt; rht ) build(rt-&gt;rson, mid+1, rht); rt-&gt;maintain();&#125;inline void Init() &#123; nodetop = nodepool; scanf(&quot;%s&quot;, s+1); s[0] = s[N+1] = &#x27;0&#x27;; build(rt, 0, N+1);&#125;inline int read() &#123; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()); for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return s;&#125;int main()&#123; null = new node(); memset(null, 0, sizeof(node)); xp[0] = 1; for(int i=1; i &lt; MAXN; ++i) xp[i] = xp[i-1] * hashkey; while( scanf(&quot;%d%d&quot;, &amp;N, &amp;Q) == 2 ) &#123; Init(); while( Q-- ) &#123; op = read(); arg1 = read(); if( op != 2 ) arg2 = read(); switch( op ) &#123; case 1: insert(rt, arg1+1, arg2); break; case 2: remove(rt, arg1); break; case 3: update(rt, arg1, arg2); break; case 4: printf(&quot;%d\\n&quot;, query(rt, arg1, arg2)); break; &#125; &#125; &#125; return 0;&#125;/*&#125;&#125;&#125;*/ hihoCoder/1329 平衡树 Splay基础题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/typedef long long LL;struct node &#123; int key; int siz; node* lson; node* rson; int cmp(int x) &#123; int cnt = lson-&gt;siz + 1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;typedef std:: pair&lt;node*, node*&gt; droot;const int MAX_NODES = 200000+10;node* null;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;inline int rank(root o, int key) &#123; if( o == null ) return 0; if( key == o-&gt;key ) return o-&gt;lson-&gt;siz; if( key &lt; o-&gt;key ) return rank(o-&gt;lson, key); return o-&gt;lson-&gt;siz+1 + rank(o-&gt;rson, key);&#125;inline void insert(root&amp; o, int id) &#123; int k = rank(o, id); root left, right; root middle = newnode(id); split(o, k, left, right); o = merge(merge(left, middle), right);&#125;inline void remove(root&amp; o, int id1, int id2) &#123; int k1 = rank(o, id1); int k2 = rank(o, id2+1); if( k1 &gt;= k2 ) return; root left, middle, right; split(o, k1, left, right); split(right, k2-k1, middle, right); o = merge(left, right);&#125;inline int query(root&amp; o, int key) &#123; if( o == null ) return 0; if( key &lt; o-&gt;key ) return query(o-&gt;lson, key); return std:: max(o-&gt;key, query(o-&gt;rson, key));&#125;root rt;void Init() &#123; null = new node(); null-&gt;key = 0; null-&gt;siz = 0; null-&gt;lson = NULL; null-&gt;rson = NULL; nodetop = nodepool; rt = newnode(0); rt-&gt;rson = newnode(1000000001);&#125;int N, arg1, arg2, arg3;char cmd[20];inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;int main()&#123; Init(); N = read(); for(int i=1; i &lt;= N; ++i) &#123; scanf(&quot;%s&quot;, cmd); arg1 = std:: min(std:: max(read(), 1), 1000000000); if( cmd[0] == &#x27;D&#x27; ) arg2 = std:: min(std:: max(read(), 1), 1000000000); switch( cmd[0] ) &#123; case &#x27;I&#x27;: insert(rt, arg1); break; case &#x27;Q&#x27;: printf(&quot;%lld\\n&quot;, query(rt, arg1)); break; case &#x27;D&#x27;: remove(rt, arg1, arg2); break; &#125; &#125; return 0;&#125;/*&#125;&#125;&#125;*/ hihoCoder/1333 平衡树 Splay2节点中维护 add，sum，key，siz，val。其中，key 为每个人的 id，val 为每个人的兴趣值。在进行区间操作时，利用 key，计算出左右区间在 splay 中的名次，然后使用该名次 + 基础 splay 操作就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/typedef long long LL;struct node &#123; int key; int siz; int val; int add; LL sum; node* lson; node* rson; int cmp(int x) &#123; int cnt = lson-&gt;siz + 1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void pushdown() &#123; if( !add ) return; lson-&gt;update(add); rson-&gt;update(add); add = 0; &#125; void update(int add) &#123; if( this-&gt;lson == NULL ) return; this-&gt;add += add; this-&gt;val += add; this-&gt;sum += (LL) add * this-&gt;siz; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; sum = lson-&gt;sum + val + rson-&gt;sum; &#125;&#125;;typedef node* root;typedef std:: pair&lt;node*, node*&gt; droot;const int MAX_NODES = 200000+10;node* null;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0, int val=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;val = val; nodetop-&gt;add = 0; nodetop-&gt;sum = val; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;inline int rank(root o, int key) &#123; if( o == null ) return 0; if( key == o-&gt;key ) return o-&gt;lson-&gt;siz; if( key &lt; o-&gt;key ) return rank(o-&gt;lson, key); return o-&gt;lson-&gt;siz+1 + rank(o-&gt;rson, key);&#125;inline void insert(root&amp; o, int id, int val) &#123; int k = rank(o, id); root left, right; root middle = newnode(id, val); split(o, k, left, right); o = merge(merge(left, middle), right);&#125;inline void remove(root&amp; o, int id1, int id2) &#123; int k1 = rank(o, id1); int k2 = rank(o, id2+1); if( k1 &gt;= k2 ) return; root left, middle, right; split(o, k1, left, right); split(right, k2-k1, middle, right); o = merge(left, right);&#125;inline void update(root&amp; o, int id1, int id2, int add) &#123; int k1 = rank(o, id1); int k2 = rank(o, id2+1); if( k1 &gt;= k2 ) return; splay(o, k1); splay(o-&gt;rson, k2-k1+1); o-&gt;rson-&gt;lson-&gt;update(add); o-&gt;rson-&gt;maintain(); o-&gt;maintain();&#125;inline LL query(root&amp; o, int id1, int id2) &#123; int k1 = rank(o, id1); int k2 = rank(o, id2+1); if( k1 &gt;= k2 ) return 0; splay(o, k1); splay(o-&gt;rson, k2-k1+1); return o-&gt;rson-&gt;lson-&gt;sum;&#125;root rt;void Init() &#123; null = new node(); null-&gt;key = 0; null-&gt;siz = 0; null-&gt;val = 0; null-&gt;add = 0; null-&gt;sum = 0; null-&gt;lson = NULL; null-&gt;rson = NULL; nodetop = nodepool; rt = newnode(0, 0); rt-&gt;rson = newnode(1000000001, 0);&#125;int N, arg1, arg2, arg3;char cmd[20];inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;int main()&#123; Init(); N = read(); for(int i=1; i &lt;= N; ++i) &#123; scanf(&quot;%s&quot;, cmd); arg1 = std:: min(std:: max(read(), 1), 100000000); arg2 = std:: min(std:: max(read(), 1), 100000000); if( cmd[0] == &#x27;M&#x27; ) arg3 = read(); switch( cmd[0] ) &#123; case &#x27;I&#x27;: insert(rt, arg1, arg2); break; case &#x27;Q&#x27;: printf(&quot;%lld\\n&quot;, query(rt, arg1, arg2)); break; case &#x27;M&#x27;: update(rt, arg1, arg2, arg3); break; case &#x27;D&#x27;: remove(rt, arg1, arg2); break; &#125; &#125; return 0;&#125;/*&#125;&#125;&#125;*/ LA/3961 Robotic Sort初始时，建一棵 1～$N$ 的 splay，并对原序列进行排序（排序规则为：值小的优先，值相等时，在原序列靠左的优先）。对于第 $k$ 次询问，将值为 $k$ 的节点伸展至根，然后就是些基础的操作了。问题的难点在于快速找到值为 $k$ 的节点。法一：用一个父指针，直接从值为 $k$ 的节点往上伸展就好了。之所以扯这么多，是因为此前一直都是用 刘汝佳 的递归写法（被惯坏了），不需要父指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/struct node &#123; int key; int siz; bool flip; node* prev; node* lson; node* rson; void reverse() &#123; flip ^= 1; std:: swap(lson, rson); &#125; void pushdown() &#123; if( !flip ) return; lson-&gt;reverse(); rson-&gt;reverse(); flip = false; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson-&gt;prev = o; k-&gt;lson = o; o-&gt;prev = k; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson-&gt;prev = o; k-&gt;rson = o; o-&gt;prev = k; o = k;&#125;// 带父指针的 旋转 和 伸展操作 是此问题最大的难点（蒽，被刘汝佳的代码惯坏了。。inline void rotate(root o, int d) &#123; int d2 = -1; root p = o-&gt;prev; if( p != NULL ) d2 = p-&gt;lson == o? 0: 1; d? zig(o): zag(o); if( d2 != -1 ) d2? p-&gt;rson = o: p-&gt;lson = o; d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;prev = p; o-&gt;maintain();&#125;// 注意，d 必须在 pushdown 之后计算，因为有交换子树的操作。inline void splay(root o, root f) &#123;// o 必须先 pushdown() 一次，因为可能 o 已经是 f 的子节点，// 但为了保持 “splay 操作后的根节点标记全部下传” 的传统，需要这么做。 for(o-&gt;pushdown(); o-&gt;prev != f;) &#123; root p = o-&gt;prev; if( p-&gt;prev == f ) &#123; p-&gt;pushdown(); o-&gt;pushdown(); int d = p-&gt;lson == o? 0: 1; rotate(p, d^1); break; &#125; root g = p-&gt;prev; g-&gt;pushdown(); p-&gt;pushdown(); o-&gt;pushdown(); int d = p-&gt;lson == o? 0: 1; int d2 = g-&gt;lson == p? 0: 1; if( d == d2 ) rotate(g, d2^1), rotate(p, d^1); else rotate(p, d^1), rotate(g, d2^1); &#125;&#125;const int MAX_NODES = 100000+10;node* null;node nodepool[MAX_NODES];inline void build(root&amp; o, int lft, int rht) &#123; int mid = (lft+rht) &gt;&gt; 1; o = nodepool + mid; o-&gt;key = mid; o-&gt;siz = 1; o-&gt;flip = false; if( lft &lt; mid ) build(o-&gt;lson, lft, mid-1); else o-&gt;lson = null; if( mid &lt; rht ) build(o-&gt;rson, mid+1, rht); else o-&gt;rson = null; o-&gt;lson-&gt;prev = o; o-&gt;rson-&gt;prev = o; o-&gt;maintain();&#125;inline int solve(root&amp; rt, int key) &#123; root o = nodepool+key; splay(o, rt-&gt;prev); int ans = o-&gt;lson-&gt;siz; if( ans ) &#123; root k = o-&gt;lson; k-&gt;reverse(); for(; k-&gt;rson != null; k=k-&gt;rson) k-&gt;pushdown(); splay(k, o); k-&gt;rson = o-&gt;rson; o-&gt;rson-&gt;prev = k; o = k; &#125; else o = o-&gt;rson; rt = o; rt-&gt;prev = NULL; rt-&gt;maintain(); return ans;&#125;typedef std:: pair&lt;int, int&gt; pii;const int MAXN = 100000+10;root rt;pii A[MAXN];int N;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = true; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;inline void Init() &#123; for(int i=1; i &lt;= N; ++i) A[i] = pii(read(), i); sort(A+1, A+N+1); build(rt, 1, N); rt-&gt;prev = NULL;&#125;int main()&#123; null = new node(); null-&gt;key = 0; null-&gt;siz = 0; null-&gt;flip = false; null-&gt;lson = NULL; null-&gt;rson = NULL; while( scanf(&quot;%d&quot;, &amp;N) == 1 &amp;&amp; N ) &#123; Init(); for(int i=1; i &lt; N; ++i) printf(&quot;%d &quot;, solve(rt, A[i].second)+i); printf(&quot;%d\\n&quot;, N); &#125; return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/05 法二：将原序列离散化成 1～$N$，建成 splay，多维护一个区间最小值，利用维护的 siz，就可以实现名次树的一些功能，就可以快速查找了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/struct node &#123; int key; int siz; int minv; bool flip; node* lson; node* rson; int cmp(int key) &#123; int cnt = lson-&gt;siz + 1; if( key == cnt ) return -1; return key &lt; cnt? 0: 1; &#125; void reverse() &#123; flip ^= 1; std:: swap(lson, rson); &#125; void pushdown() &#123; if( !flip ) return; lson-&gt;reverse(); rson-&gt;reverse(); flip = false; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; minv = std:: min(key, std:: min(lson-&gt;minv, rson-&gt;minv)); &#125;&#125;;typedef node* root;node* null;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d2^1); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;inline int kth(root rt) &#123; rt-&gt;pushdown(); if( rt-&gt;key == rt-&gt;minv ) return rt-&gt;lson-&gt;siz + 1; if( rt-&gt;lson-&gt;minv &lt; rt-&gt;rson-&gt;minv ) return kth(rt-&gt;lson); return kth(rt-&gt;rson) + rt-&gt;lson-&gt;siz + 1;&#125;const int MAX_NODES = 100000+10;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;minv = key; nodetop-&gt;flip = false; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void build(root&amp; o, int lft, int rht, int* rank) &#123; int mid = (lft+rht) &gt;&gt; 1; o = newnode(rank[mid]); if( lft &lt; mid ) build(o-&gt;lson, lft, mid-1, rank); if( mid &lt; rht ) build(o-&gt;rson, mid+1, rht, rank); o-&gt;maintain();&#125;const int MAXN = 100000+10;const int INF = 0x3f3f3f3f;int N, A[MAXN], id[MAXN], rank[MAXN];root rt;inline bool cmp(int u, int v) &#123; return A[u] &lt; A[v]; &#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;inline void init() &#123; nodetop = nodepool;&#125;inline int solve() &#123; int k = kth(rt); splay(rt, k); int ans = rt-&gt;lson-&gt;siz; if( ans ) &#123; rt-&gt;lson-&gt;reverse(); splay(rt-&gt;lson, rt-&gt;lson-&gt;siz); rt = merge(rt-&gt;lson, rt-&gt;rson); &#125; else rt = rt-&gt;rson, rt-&gt;pushdown(); return ans;&#125;int main()&#123; null = new node(); null-&gt;key = 0; null-&gt;siz = 0; null-&gt;minv = INF; null-&gt;flip = false; null-&gt;lson = NULL; null-&gt;rson = NULL; while( scanf(&quot;%d&quot;, &amp;N) == 1 &amp;&amp; N ) &#123; init(); for(int i=1; i &lt;= N; ++i) A[i] = read(); for(int i=1; i &lt;= N; ++i) id[i] = i; std:: stable_sort(id+1, id+N+1, cmp); for(int i=1; i &lt;= N; ++i) rank[id[i]] = i; build(rt, 1, N, rank); for(int i=1; i &lt; N; ++i) printf(&quot;%d &quot;, solve()+i); printf(&quot;%d\\n&quot;, N); &#125; return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/06 HYSBZ/1269 文本编辑器 editor都是一些 splay 的经典操作，为了方便操作，在最最左边和最右边分别加了一个虚拟节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/struct node &#123; char key; int siz; bool flip; node* lson; node* rson; int cmp(int x) &#123; int cnt = lson-&gt;siz + 1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void reverse() &#123; flip ^= 1; std:: swap(lson, rson); &#125; void pushdown() &#123; if( !flip ) return; lson-&gt;reverse(); rson-&gt;reverse(); flip ^= 1; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;const int MAX_NODES = (1&lt;&lt;22) + 10;node* null;node* nodetop;node nodepool[MAX_NODES];inline root newnode(char key) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;flip = false; nodetop-&gt;lson = null; nodetop-&gt;rson = null; return nodetop++;&#125;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;inline void build(root&amp; o, int lft, int rht, char* s) &#123; int mid = (lft+rht) &gt;&gt; 1; o = newnode(s[mid]); if( lft &lt; mid ) build(o-&gt;lson, lft, mid-1, s); if( mid &lt; rht ) build(o-&gt;rson, mid+1, rht, s); o-&gt;maintain();&#125;const int MAXN = (1&lt;&lt;22) + 10;char s[MAXN];inline void Move(root&amp; rt, int k) &#123; splay(rt, k); &#125;inline void Insert(root&amp; rt, int n) &#123; for(s[1]=getchar(); s[1] &lt; 32 || s[1] &gt; 126;) s[1] = getchar(); for(int i=2; i &lt;= n; ++i) s[i] = getchar(); root left = rt; root middle; build(middle, 1, n, s); root right = rt-&gt;rson; rt-&gt;rson = null; rt-&gt;maintain(); rt = merge(left, merge(middle, right));&#125;inline void Delete(root&amp; rt, int n) &#123; splay(rt-&gt;rson, n); rt-&gt;rson = rt-&gt;rson-&gt;rson; rt-&gt;maintain();&#125;inline void Rotate(root&amp; rt, int n) &#123; splay(rt-&gt;rson, n+1); rt-&gt;rson-&gt;lson-&gt;reverse();&#125;inline void Get(root&amp; rt) &#123; root o = rt-&gt;rson; for(; o-&gt;lson != null; o=o-&gt;lson) o-&gt;pushdown(); printf(&quot;%c\\n&quot;, o-&gt;key);&#125;inline void Prev(root&amp; rt) &#123; splay(rt, rt-&gt;lson-&gt;siz); &#125; inline void Next(root&amp; rt) &#123; splay(rt, rt-&gt;lson-&gt;siz+2); &#125;root rt;inline void Init() &#123; null = new node(); null-&gt;key = &#x27;\\0&#x27;; null-&gt;siz = 0; null-&gt;flip = false; null-&gt;lson = NULL; null-&gt;rson = NULL; nodetop = nodepool; rt = newnode(31); rt-&gt;rson = newnode(127);&#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return s;&#125;char cmd[20];int main()&#123; Init(); int N = read(); for(int i=1; i &lt;= N; ++i) &#123; scanf(&quot;%s&quot;, cmd); switch( cmd[0] ) &#123; case &#x27;M&#x27;: Move(rt, read()+1); break; case &#x27;I&#x27;: Insert(rt, read()); break; case &#x27;D&#x27;: Delete(rt, read()); break; case &#x27;R&#x27;: Rotate(rt, read()); break; case &#x27;G&#x27;: Get(rt); break; case &#x27;P&#x27;: Prev(rt); break; case &#x27;N&#x27;: Next(rt); break; &#125; &#125; return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/05 HYSBZ/1500 维修数列前五个操作比较简单，第六个操作，需要维护：子树左侧起最大连续和 $mxlv$（可以为空），子树右侧起最大连续和 $mxrv$（可以为空），子树中最大连续和 $mxmv$（非空）。在序列的最左侧和最右侧增加两个虚拟节点就可以很方便了，注意为了不影响结果的正确性，虚拟节点的 sum 值需为 0，但是节点的 $key,mxlv,mxmv,mxrv$ 均需设成负无穷。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/const int INF = 0x3f3f3f3f;struct node &#123; int key; int siz; int setv; // 懒惰标记，表示是否标记为同一个值 int sumv; // 该节点为根的子树的 $\\sum key$ int mxlv; // 该节点为根的子树表示的序列左侧（可以为空）最大连续和 int mxmv; // 该节点为根的子树最大连续和 int mxrv; // 该节点为根的子树表示的序列右侧（可以为空）最大连续和 bool flip; // 懒惰标记，表示是否翻转 node* lson; node* rson; static node* null; int cmp(int x) &#123; int cnt = lson-&gt;siz + 1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void reverse() &#123; flip ^= 1; std:: swap(lson, rson); std:: swap(mxlv, mxrv); &#125; void update(int tag) &#123; setv = tag; key = tag; sumv = tag * siz; mxlv = mxrv = tag &gt; 0? sumv: 0; mxmv = tag &gt; 0? sumv: tag; &#125; void pushdown() &#123; if( flip ) &#123; lson-&gt;reverse(); rson-&gt;reverse(); flip = false; &#125; if( setv != -INF ) &#123; if( lson != null ) lson-&gt;update(setv); if( rson != null ) rson-&gt;update(setv); setv = -INF; &#125; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; sumv = lson-&gt;sumv + key + rson-&gt;sumv; mxlv = std:: max(lson-&gt;mxlv, lson-&gt;sumv + key + rson-&gt;mxlv); mxrv = std:: max(rson-&gt;mxrv, lson-&gt;mxrv + key + rson-&gt;sumv); mxmv = std:: max(lson-&gt;mxmv, rson-&gt;mxmv); mxmv = std:: max(mxmv, lson-&gt;mxrv + key + rson-&gt;mxlv); &#125;&#125;;typedef node* root;node* node:: null = new node();inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = node:: null; o-&gt;maintain();&#125;inline root merge(root left, root right) &#123; splay(left, left-&gt;siz); left-&gt;rson = right; left-&gt;maintain(); return left;&#125;/********************** 以上为 splay 基本操作 *******************/const int MAX_NODES = 1000000+10;std:: queue&lt;root&gt; Qnodepool;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; root nodetop = Qnodepool.front(); Qnodepool.pop(); nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;setv = -INF; nodetop-&gt;sumv = key; nodetop-&gt;mxlv = key &gt; 0? key: 0; nodetop-&gt;mxmv = key; nodetop-&gt;mxrv = key &gt; 0? key: 0; nodetop-&gt;flip = false; nodetop-&gt;lson = node:: null; nodetop-&gt;rson = node:: null; return nodetop;&#125;inline void deletenode(root o) &#123; if( o == node:: null ) return; deletenode(o-&gt;lson); deletenode(o-&gt;rson); Qnodepool.push(o);&#125;inline void build(root&amp; o, int lft, int rht, int* A) &#123; int mid = (lft+rht) &gt;&gt; 1; o = newnode(A[mid]); if( lft &lt; mid ) build(o-&gt;lson, lft, mid-1, A); if( mid &lt; rht ) build(o-&gt;rson, mid+1, rht, A); if( A[mid] == -INF ) o-&gt;sumv = 0; o-&gt;maintain();&#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;const int MAXN = 500000+10;int A[MAXN];root rt;inline void INSERT(int pos, int tot) &#123; for(int i=1; i &lt;= tot; ++i) A[i] = read(); root left, middle, right; build(middle, 1, tot, A); split(rt, pos+1, left, right); rt = merge(merge(left, middle), right);&#125;inline void DELETE(int pos, int tot) &#123; splay(rt, pos); splay(rt-&gt;rson, tot+1); deletenode(rt-&gt;rson-&gt;lson); rt-&gt;rson-&gt;lson = node:: null; rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;inline void MODIFY(int pos, int tot, int tag) &#123; splay(rt, pos); splay(rt-&gt;rson, tot+1); rt-&gt;rson-&gt;lson-&gt;update(tag); rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;inline void REVERSE(int pos, int tot) &#123; splay(rt, pos); splay(rt-&gt;rson, tot+1); rt-&gt;rson-&gt;lson-&gt;reverse(); rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;inline int GETSUM(int pos, int tot) &#123; splay(rt, pos); splay(rt-&gt;rson, tot+1); return rt-&gt;rson-&gt;lson-&gt;sumv;&#125;inline int MAXSUM() &#123; return rt-&gt;mxmv;&#125;inline void init() &#123; while( !Qnodepool.empty() ) Qnodepool.pop(); for(int i=0; i &lt; MAX_NODES; ++i) Qnodepool.push(nodepool+i); node:: null-&gt;key = -INF; node:: null-&gt;siz = 0; node:: null-&gt;setv = -INF; node:: null-&gt;sumv = 0; node:: null-&gt;mxlv = 0; node:: null-&gt;mxmv = -INF; node:: null-&gt;mxrv = 0; node:: null-&gt;flip = false; node:: null-&gt;lson = NULL; node:: null-&gt;rson = NULL;&#125;int main()&#123; init(); int N = read(); int Q = read(); for(int i=1; i &lt;= N; ++i) A[i] = read(); A[0] = A[N+1] = -INF; build(rt, 0, N+1, A); while( Q-- ) &#123; char cmd[20]; scanf(&quot;%s&quot;, cmd); if( cmd[0] == &#x27;M&#x27; &amp;&amp; cmd[2] == &#x27;X&#x27; ) &#123; printf(&quot;%d\\n&quot;, MAXSUM()); continue; &#125; int arg1 = read(); int arg2 = read(); switch( cmd[0] ) &#123; case &#x27;I&#x27;: INSERT(arg1, arg2); break; case &#x27;D&#x27;: DELETE(arg1, arg2); break; case &#x27;M&#x27;: MODIFY(arg1, arg2, read()); break; case &#x27;R&#x27;: REVERSE(arg1, arg2); break; case &#x27;G&#x27;: printf(&quot;%d\\n&quot;, GETSUM(arg1, arg2)); break; &#125; &#125; return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/07 POJ/2828 Buy Tickets法一：在线做。直接 splay 模拟，容易超时，可以检验自己 splay 写法常数大不大（不加读入读出优化的前提下）。Hint POJ 加读入读出优化能快很多 = = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;cstdio&gt;/*&#123;&#123;&#123;*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;struct node &#123; int key; int siz; node* lson; node* rson; static node* null; int cmp(int x) &#123; int cnt = lson-&gt;siz+1; if( x == cnt ) return -1; return x &lt; cnt? 0: 1; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void splay(root&amp; o, int k) &#123; int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline void split(root o, int k, root&amp; left, root&amp; right) &#123; splay(o, k); left = o; right = o-&gt;rson; o-&gt;rson = node:: null; o-&gt;maintain();&#125;const int MAX_NODES = 200000+10;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 0; nodetop-&gt;lson = node:: null; nodetop-&gt;rson = node:: null; return nodetop++;&#125;inline void insert(root&amp; rt, int pos, int key) &#123; root left, right; split(rt, pos+1, left, right); left-&gt;rson = newnode(key); left-&gt;rson-&gt;rson = right; left-&gt;rson-&gt;maintain(); left-&gt;maintain(); rt = left;&#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;inline void print(int s) &#123; if( s &gt; 9 ) print(s/10); putchar(s%10+&#x27;0&#x27;);&#125;node* node:: null = new node();root rt;int N;inline void init() &#123; node:: null-&gt;key = 0; node:: null-&gt;siz = 0; node:: null-&gt;lson = NULL; node:: null-&gt;rson = NULL;&#125;inline void printtree(root&amp; o) &#123; if( o == node:: null ) return; printtree(o-&gt;lson); print(o-&gt;key); putchar(&#x27; &#x27;); printtree(o-&gt;rson);&#125;int main()&#123; init(); while( scanf(&quot;%d&quot;, &amp;N) == 1 ) &#123; nodetop = nodepool; rt = newnode(0); for(int i=1; i &lt;= N; ++i) &#123; int arg1 = read(); int arg2 = read(); insert(rt, arg1, arg2); &#125; splay(rt, 1); printtree(rt-&gt;rson); printf(&quot;\\n&quot;); &#125; return 0;&#125;/*&#125;&#125;&#125;*/ 法二：离线做。类似约瑟夫问题的线段树写法。初始时，维护一个前缀和 $\\displaystyle sum(N)=\\sum\\_{i=1}^N i$；最后一个人的最终位置显然是 pos+1，然后去掉这个人，那么倒数第二个人就成了最后一个人了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;/*&#123;&#123;&#123;*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define lc (o&lt;&lt;1)#define rc (o&lt;&lt;1|1)#define lson lc, lft, mid#define rson rc, mid+1, rht#define MID(lft, rht) (lft+rht&gt;&gt;1)const int MAXN = 200000+10;int sumv[MAXN&lt;&lt;2], ans[MAXN], pos[MAXN], val[MAXN], N;void build(int o, int lft, int rht) &#123; sumv[o] = rht-lft+1; if( lft == rht ) return; int mid = MID(lft, rht); build(lson); build(rson);&#125;void query(int o, int lft, int rht, int pos, int val) &#123; --sumv[o]; if( lft == rht ) ans[lft] = val; else &#123; int mid = MID(lft, rht); if( pos &lt;= sumv[lc] ) query(lson, pos, val); else query(rson, pos-sumv[lc], val); &#125;&#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;inline void print(int s) &#123; if( s &gt; 9 ) print(s/10); putchar(s%10+&#x27;0&#x27;);&#125;int main()&#123; while( scanf(&quot;%d&quot;, &amp;N) == 1 ) &#123; build(1, 1, N); for(int i=1; i &lt;= N; ++i) pos[i] = read()+1, val[i] = read(); for(int i=N; i; --i) query(1, 1, N, pos[i], val[i]); for(int i=1; i &lt;= N; ++i) print(ans[i]), putchar(&#x27; &#x27;); putchar(&#x27;\\n&#x27;); &#125; return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/07 HYSBZ/1503 郁闷的出纳员只需要用 splay 实现名次树即可。注意由于存在懒惰标记，在查询第 $k$ 大，及确定有多少个值比 $key$ 小，这两个操作的过程中都要一路 $pushdown$。坑点：立即离开公司的人不算入答案。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;/*&#123;&#123;&#123;*/struct node &#123; int key; int siz; int addv; node* lson; node* rson; static node* null; int cmp(int s) &#123; int cnt = lson-&gt;siz+1; if( s == cnt ) return -1; return s &lt; cnt? 0: 1; &#125; void update(int v) &#123; key += v; addv += v; &#125; void pushdown() &#123; if( !addv ) return; if( lson != null ) lson-&gt;update(addv); if( rson != null ) rson-&gt;update(addv); addv = 0; &#125; void maintain() &#123; siz = lson-&gt;siz + 1 + rson-&gt;siz; &#125;&#125;;typedef node* root;inline void zag(root&amp; o) &#123; root k = o-&gt;rson; o-&gt;rson = k-&gt;lson; k-&gt;lson = o; o = k;&#125;inline void zig(root&amp; o) &#123; root k = o-&gt;lson; o-&gt;lson = k-&gt;rson; k-&gt;rson = o; o = k;&#125;inline void rotate(root&amp; o, int d) &#123; d? zig(o): zag(o); d? o-&gt;rson-&gt;maintain(): o-&gt;lson-&gt;maintain(); o-&gt;maintain();&#125;inline void printtree(root o, int cur=0) &#123; if( o == node:: null ) return; printtree(o-&gt;lson, cur+1); printf(&quot;cur %d: key=%d, siz=%d\\n&quot;, cur, o-&gt;key, o-&gt;siz); printtree(o-&gt;rson, cur+1); if( !cur ) printf(&quot;---------------------------------\\n&quot;);&#125;inline void splay(root&amp; o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == 1 ) k -= o-&gt;lson-&gt;siz+1; if( d != -1 ) &#123; root&amp; p = d? o-&gt;rson: o-&gt;lson; p-&gt;pushdown(); int d2 = p-&gt;cmp(k); if( d2 == 1 ) k -= p-&gt;lson-&gt;siz+1; if( d2 != -1 ) &#123; splay((d2? p-&gt;rson: p-&gt;lson), k); if( d == d2 ) rotate(o, d^1); else rotate(p, d); &#125; rotate(o, d^1); &#125;&#125;inline int kth(root o, int k) &#123; o-&gt;pushdown(); int d = o-&gt;cmp(k); if( d == -1 ) return o-&gt;key; return d? kth(o-&gt;rson, k - o-&gt;lson-&gt;siz - 1): kth(o-&gt;lson, k);&#125;inline int rank(root o, int k) &#123; if( o == node:: null ) return 0; o-&gt;pushdown(); if( k &lt;= o-&gt;key ) return rank(o-&gt;lson, k); return rank(o-&gt;rson, k) + o-&gt;lson-&gt;siz + 1;&#125;const int MAX_NODES = 100000+10;node* nodetop;node nodepool[MAX_NODES];inline root newnode(int key=0) &#123; nodetop-&gt;key = key; nodetop-&gt;siz = 1; nodetop-&gt;addv = 0; nodetop-&gt;lson = node:: null; nodetop-&gt;rson = node:: null; return nodetop++;&#125;inline void insert(root&amp; rt, int key) &#123; int k = rank(rt, key); splay(rt, k); root left = rt; root middle = newnode(key); root right = rt-&gt;rson; left-&gt;rson = middle; middle-&gt;rson = right; middle-&gt;maintain(); left-&gt;maintain(); rt = left;&#125;inline void remove(root&amp; rt, int M) &#123; int k = rank(rt, M); if( k == 1 ) return; splay(rt, 1); splay(rt-&gt;rson, k); rt-&gt;rson-&gt;lson = node:: null; rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;inline void update(root&amp; rt, int addv) &#123; if( rt-&gt;siz == 2 ) return; splay(rt, 1); splay(rt-&gt;rson, rt-&gt;rson-&gt;siz); rt-&gt;rson-&gt;lson-&gt;update(addv); rt-&gt;rson-&gt;maintain(); rt-&gt;maintain();&#125;const int INF = 0x3f3f3f3f;root rt;node* node:: null = new node();inline void init() &#123; node:: null-&gt;key = 0; node:: null-&gt;siz = 0; node:: null-&gt;addv = 0; node:: null-&gt;lson = NULL; node:: null-&gt;rson = NULL; nodetop = nodepool; rt = newnode(-INF); rt-&gt;rson = newnode(INF); rt-&gt;maintain();&#125;inline int read() &#123; bool positive = true; char c = getchar(); int s = 0; for(; c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;; c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;int main()&#123; init(); int N = read(); int M = read(); int tot = 2; for(int i=1; i &lt;= N; ++i) &#123; char cmd[20]; scanf(&quot;%s&quot;, cmd); int arg = read(); switch( cmd[0] ) &#123; case &#x27;I&#x27;: if( arg &gt;= M ) insert(rt, arg), ++tot; break; case &#x27;A&#x27;: update(rt, arg); break; case &#x27;S&#x27;: update(rt, -arg); remove(rt, M); break; case &#x27;F&#x27;: printf(&quot;%d\\n&quot;, arg &lt;= rt-&gt;siz-2? kth(rt, rt-&gt;siz - arg): -1); break; &#125; &#125; printf(&quot;%d\\n&quot;, tot - rt-&gt;siz); return 0;&#125;/*&#125;&#125;&#125;*/ update time: 2016/07/07 汇总 problems categories solution UVa/11922 基础题 Code UVa/11996 初级题 Code hihoCoder/1329 基础题 Code hihoCoder/1333 初级题 Code LA/3961 初级题 Code1、Code2 HYSBZ/1269 经典题 Code HYSBZ/1500 经典题 Code POJ/2828 基础题 ***Code1***、 Code2 HYSBZ/1503 初级题 Code","tags":[{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"专题训练","slug":"专题训练","permalink":"http://littleclown.github.io/tags/%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/"},{"name":"Splay","slug":"Splay","permalink":"http://littleclown.github.io/tags/Splay/"}]},{"title":"最佳文章","date":"2016-06-26T11:32:55.000Z","path":"acm/oj/ccf/2015/09/5/","text":"题目链接 问题简述有 $N$ 个由小写字母构成的单词。一个串的权值为这个串中每个单词出现的次数的总和（单词可部分重叠）。求一个长度为 $L$ 串的最大权值。 数据范围：$N$ 个单词长度总和不超过 100，$1\\leqslant L\\leqslant 10^{15}$。 样例输入： 3 15 agva agvagva gvagva 样例输出： 11 问题简析先将 $N$ 个串建成 Aho-Corasick 自动机，并记 $S$ 为此自动机的状态转移图的节点集。用 $dp[i][s]$ 表示长度为 $i$ 且最后一个字符在 Aho-Corasick 自动机的节点 s 上的串的最大权值。显然，答案为 $\\max\\big\\lbrace dp[L][s] \\big| s\\in S \\big\\rbrace$。状态转移：$dp[i+1][s’]=\\max\\big\\lbrace dp[i][s] \\big| s\\in S \\text{且存在从 $s$ 到 $s’$ 的边}\\big\\rbrace +val[s’]$。其中，$val[s’]$ 为以该节点结尾的单词的个数（经典的 AC 自动机基础操作，应该懂我在说什么吧。。） 样例的状态图如下 其中，虚线为 fail 指针。上图中，$val[4]=1, val[7]=3,val[13]=2$，其它节点 $val$ 值为 0。不难发现，仅考虑有实线的边的转移是最优的；当没有实线的边时，选择虚线的边转移。 接下来就是重头戏了。我们可以构造一个 $\\big|S\\big| \\times \\big|S\\big| =14 \\times 14$ 的矩阵 $M$\\begin{align} M[s’][s] = \\left\\lbrace \\begin{aligned} &amp;val[s’], &amp;\\text{存在一条边} s \\rightarrow s’ \\ &amp;-INF, &amp;\\text{不存在一条边} s \\rightarrow s’ \\end{aligned} \\right.\\end{align}结合前面的状态转移方程有：$dp[i+1][s’]=\\max\\big\\lbrace dp[i][s]+M[s’][s] \\big\\rbrace$。可以将 $dp[i]$ 当做一个列向量，那么 $dp[i+1]$ 可以看做由 $M$ 和 $dp[i]$ 进行如转移方程所示的运算规则得到。对比传统的矩阵乘法，相当于：$\\sum$ 变成了 $\\max$，同时 $\\times$ 变成了 $+$。不难验证，新的矩阵运算同样是左结合的，这意味着：$dp[L]=M{\\color{red}{op}}dp[L-1]=M^{L}{\\color{red}{op}}dp[0]$。接下来，矩阵“快速幂”就好了。 还有一个问题，$dp[0]$ 是什么？因为零个字符，只能在状态 0，其它状态必须设为负无穷，即：\\begin{align} dp[0][i] = \\left\\lbrace \\begin{aligned} &amp;0, &amp;i=0 \\ &amp;-INF, &amp;i \\neq 0 \\end{aligned} \\right.\\end{align}可以通过 $dp[1]=M{\\color{red}{op}}dp[0]$ 来验证。 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const LL LNF = 0x3f3f3f3f3f3f3f3fLL;struct Matrix &#123; static const int MAXN = 100+10; LL M[MAXN][MAXN]; void fill(LL val) &#123; for(int i=0; i &lt; MAXN; ++i) for(int j=0; j &lt; MAXN; ++j) M[i][j] = val; &#125; friend Matrix operator * (const Matrix&amp; A, const Matrix&amp; B) &#123; Matrix C; C.fill(-LNF); for(int i=0; i &lt; MAXN; ++i) for(int j=0; j &lt; MAXN; ++j) for(int k=0; k &lt; MAXN; ++k) C.M[i][j] = max(C.M[i][j], A.M[i][k]+B.M[k][j]); return C; &#125; static Matrix Power(Matrix A, LL X) &#123; Matrix ans; ans.fill(-LNF); for(int i=0; i &lt; MAXN; ++i) ans.M[i][i] = 0; for(; X &gt; 0; X&gt;&gt;=1, A=A*A) if( X&amp;1 ) ans = ans*A; return ans; &#125; void show(int N=MAXN) const &#123; for(int i=0; i &lt; N; ++i) printf(&quot;%6d &quot;, i); printf(&quot;\\n------------------------------------------------------------------------------------------------------\\n&quot;); for(int i=0; i &lt; N; ++i) &#123; printf(&quot;%2d:|&quot;, i); for(int j=0; j &lt; N; ++j) printf(&quot;%6d|&quot;, M[i][j]); printf(&quot;\\n&quot;); &#125; printf(&quot;------------------------------------------------------------------------------------------------------\\n&quot;); &#125;&#125;;struct AhoCorasick &#123; static const int SIGMA_SIZ = 26; static const int MAX_NODES = 100+10; int ch[MAX_NODES][SIGMA_SIZ]; int val[MAX_NODES]; int fail[MAX_NODES]; int siz; void Init() &#123; siz = 1; memset(ch[0], 0, sizeof ch[0]); &#125; int idx(const char c) const &#123; return c - &#x27;a&#x27;; &#125; void Insert(const char* s) &#123; int r = 0; for(; *s; ++s) &#123; int c = idx(*s); if( !ch[r][c] ) &#123; memset(ch[siz], 0, sizeof ch[siz]); val[siz] = 0; ch[r][c] = siz++; &#125; r = ch[r][c]; &#125; ++val[r]; &#125; void GetFail() &#123; static queue&lt;int&gt; Q; for(int c=0; c &lt; SIGMA_SIZ; ++c) &#123; int o = ch[0][c]; if( o ) fail[o] = 0, Q.push(o); &#125; while( !Q.empty() ) &#123; int r = Q.front(); Q.pop(); for(int c=0; c &lt; SIGMA_SIZ; ++c) &#123; int o = ch[r][c]; if( o ) &#123; int fo = fail[r]; for(; fo &amp;&amp; !ch[fo][c]; fo=fail[fo]); fail[o] = ch[fo][c]; val[o] += val[fail[o]]; Q.push(o); &#125; else &#123; ch[r][c] = ch[fail[r]][c]; &#125; &#125; &#125; &#125; void BuildMatrix(Matrix&amp; mat) &#123; mat.fill(-LNF); for(int r=0; r &lt; siz; ++r) for(int c=0; c &lt; SIGMA_SIZ; ++c) mat.M[ch[r][c]][r] = val[ch[r][c]]; &#125;&#125;;Matrix mat;AhoCorasick ac;int N;LL M;char s[200];int main()&#123; ac.Init(); scanf(&quot;%d%lld&quot;, &amp;N, &amp;M); for(int i=0; i &lt; N; ++i) &#123; scanf(&quot;%s&quot;, s); ac.Insert(s); &#125; ac.GetFail(); ac.BuildMatrix(mat);// for(int i=0; i &lt; ac.siz; ++i) printf(&quot;%d, fail[%d]=%d\\n&quot;, i, i, ac.fail[i]);// mat.show(ac.siz); mat = Matrix:: Power(mat, M); LL ans = 0; for(int i=0; i &lt; Matrix:: MAXN; ++i) ans = max(ans, mat.M[i][0]); printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://littleclown.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"Aho-Corasick 自动机","slug":"Aho-Corasick-自动机","permalink":"http://littleclown.github.io/tags/Aho-Corasick-%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"矩阵快速幂变形","slug":"矩阵快速幂变形","permalink":"http://littleclown.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%98%E5%BD%A2/"}]},{"title":"编译原理-语法制导翻译实现计算器","date":"2016-06-23T09:38:27.000Z","path":"study/computer/fundamentals-of-compiling/exercise/","text":"任务描述设计一个文法，匹配合法的计算式，并返回正确计算式的结果。 文法\\begin{align}&amp;A \\rightarrow BC \\&amp;C \\rightarrow +BC \\mid -BC \\mid \\varepsilon \\&amp;B \\rightarrow DE \\&amp;E \\rightarrow *DE \\mid /DE \\mid \\varepsilon \\&amp;D \\rightarrow digit \\mid (A) \\\\end{align} \\begin{align}FIRST(A) = \\Big\\lbrace digit,( \\Big\\rbrace &amp;\\quad FOLLOW(A) = \\Big\\lbrace $,) \\Big\\rbrace\\FIRST(B) = \\Big\\lbrace digit,( \\Big\\rbrace &amp;\\quad FOLLOW(B) = \\Big\\lbrace $,),+,- \\Big\\rbrace\\FIRST(C) = \\Big\\lbrace +,-,\\varepsilon \\Big\\rbrace &amp;\\quad FOLLOW(C) = \\Big\\lbrace $,) \\Big\\rbrace\\FIRST(D) = \\Big\\lbrace digit,( \\Big\\rbrace &amp;\\quad FOLLOW(D) = \\Big\\lbrace $,),*,/,+,- \\Big\\rbrace\\FIRST(E) = \\Big\\lbrace *,/,\\varepsilon \\Big\\rbrace &amp;\\quad FOLLOW(E) = \\Big\\lbrace $,),+,- \\Big\\rbrace\\\\end{align} LL(1) 预测分析表 $ $ digit ( ) + - * / $ A $A \\rightarrow BC$ $A \\rightarrow BC$ B $B \\rightarrow DE$ $B \\rightarrow DE$ C $C \\rightarrow \\varepsilon$ $C \\rightarrow +BC$ $C \\rightarrow -BC$ $C \\rightarrow \\varepsilon$ D $D \\rightarrow digit$ $D \\rightarrow (A)$ E $E \\rightarrow \\varepsilon$ $E \\rightarrow \\varepsilon$ $E \\rightarrow \\varepsilon$ $E \\rightarrow *DE$ $E \\rightarrow /DE$ $E \\rightarrow \\varepsilon$ SDD $ $ 产生式 语义规则 0) $A \\rightarrow BC$ \\begin{align} &amp;C.inh=B.syn \\\\ &amp;A.syn = C.syn \\end{align} 1) $C \\rightarrow +BC_1$ \\begin{align} &amp;C_1.inh=C.inh + B.syn \\\\ &amp;C.syn=C_1.syn \\end{align} 2) $C \\rightarrow -BC_1$ \\begin{align} &amp;C_1.inh=C.inh-B.syn \\\\ &amp;C.syn=C_1.syn \\end{align} 3) $C \\rightarrow \\varepsilon$ \\begin{align} C.syn=C.inh \\end{align} 4) $B \\rightarrow DE$ \\begin{align} &amp;E.inh=D.syn \\\\ &amp; B.syn=E.syn \\end{align} 5) $E \\rightarrow *DE_1$ \\begin{align} &amp;E_1.inh=E.inh \\times D.syn \\\\ &amp;E.syn=E_1.syn \\end{align} 6) $E \\rightarrow /DE_1$ \\begin{align} &amp;E_1.inh=E.inh / D.syn \\\\ &amp; E.syn=E_1.syn \\end{align} 7) $E \\rightarrow \\varepsilon$ \\begin{align} &amp;E.syn=E.inh \\end{align} 8) $D \\rightarrow digit$ \\begin{align} &amp;D.syn = digit.lexval \\end{align} 9) $D \\rightarrow (A)$ \\begin{align} &amp;D.syn = A.syn \\end{align*} 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;exception&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int id, syn, inh; node(int id=0, int syn=0, int inh=0): id(id), syn(syn), inh(inh) &#123;&#125;&#125;;char key[128];int M[10][10];vector&lt;int&gt; v[10];inline int idx(char c) &#123; return key[c];&#125;inline void initid() &#123; memset(key, 0, sizeof key); for(int k=&#x27;0&#x27;; k &lt;= &#x27;9&#x27;; ++k) key[k] = 1; key[&#x27;(&#x27;] = 2; key[&#x27;)&#x27;] = 3; key[&#x27;+&#x27;] = 4; key[&#x27;-&#x27;] = 5; key[&#x27;*&#x27;] = 6; key[&#x27;/&#x27;] = 7; key[&#x27;$&#x27;] = 8; key[&#x27;A&#x27;] = -1; key[&#x27;B&#x27;] = -2; key[&#x27;C&#x27;] = -3; key[&#x27;D&#x27;] = -4; key[&#x27;E&#x27;] = -5;&#125;inline void inittable() &#123;#define pb push_back for(int i=0; i &lt; 10; ++i) v[i].clear(); v[0].pb(idx(&#x27;B&#x27;)); v[0].pb(idx(&#x27;C&#x27;)); // A --&gt; BC v[1].pb(idx(&#x27;+&#x27;)); v[1].pb(idx(&#x27;B&#x27;)); v[1].pb(idx(&#x27;C&#x27;)); // C --&gt; +BC v[2].pb(idx(&#x27;-&#x27;)); v[2].pb(idx(&#x27;B&#x27;)); v[2].pb(idx(&#x27;C&#x27;)); // C --&gt; -BC // C --&gt; \\varepsilon v[4].pb(idx(&#x27;D&#x27;)); v[4].pb(idx(&#x27;E&#x27;)); // B --&gt; DE v[5].pb(idx(&#x27;*&#x27;)); v[5].pb(idx(&#x27;D&#x27;)); v[5].pb(idx(&#x27;E&#x27;)); // E --&gt; *DE v[6].pb(idx(&#x27;/&#x27;)); v[6].pb(idx(&#x27;D&#x27;)); v[6].pb(idx(&#x27;E&#x27;)); // E --&gt; /DE // E --&gt; \\varepsilon v[8].pb(idx(&#x27;0&#x27;)); // D --&gt; digit v[9].pb(idx(&#x27;(&#x27;)); v[9].pb(idx(&#x27;A&#x27;)); v[9].pb(idx(&#x27;)&#x27;)); // D --&gt; (A)// for(int i=0; i &lt; 10; ++i) reverse(v[i].begin(), v[i].end());#undef pb memset(M, -1, sizeof M); M[1][1] = 0; M[1][2] = 0; M[2][1] = 4; M[2][2] = 4; M[3][3] = 3; M[3][4] = 1; M[3][5] = 2; M[3][8] = 3; M[4][1] = 8; M[4][2] = 9; M[5][3] = 7; M[5][4] = 7; M[5][5] = 7; M[5][6] = 5; M[5][7] = 6; M[5][8] = 7;&#125;int getnum(const char*&amp; s) &#123; int num = 0; for(; isdigit(*s); ++s) num = num*10 + *s-&#x27;0&#x27;; return num;&#125;const int endsym = idx(&#x27;$&#x27;);void work(const char* &amp;s, node&amp; sy, int cur) &#123; int id = idx(*s); if( !id ) throw &quot;不识别的符号&quot;; if( sy.id != endsym ) &#123; if( sy.id == id ) &#123; if( id == 1 ) &#123; sy.syn = getnum(s); &#125; else ++s; return; &#125; if( sy.id &gt; 0 ) throw &quot;error!&quot;; int Mid = M[-sy.id][id]; if( Mid &lt; 0 ) throw &quot;error!&quot;; node sym[4]; for(int i=0; i &lt; v[Mid].size(); ++i) sym[i].id = v[Mid][i]; if( v[Mid].size() )work(s, sym[0], cur+1); switch( Mid ) &#123; case 0: case 4: sym[1].inh = sym[0].syn; work(s, sym[1], cur+1); sy.syn = sym[1].syn; break; // A --&gt; BC 或 B --&gt; DE case 1: work(s, sym[1], cur+1); sym[2].inh = sy.inh+sym[1].syn; work(s, sym[2], cur+1); sy.syn = sym[2].syn; break; // C --&gt; +BC case 2: work(s, sym[1], cur+1); sym[2].inh = sy.inh-sym[1].syn; work(s, sym[2], cur+1); sy.syn = sym[2].syn; break; // C --&gt; -BC case 3: case 7: sy.syn = sy.inh; break; // C --&gt; \\epsilon 或 E --&gt; \\epsilon case 5: work(s, sym[1], cur+1); sym[2].inh = sy.inh*sym[1].syn; work(s, sym[2], cur+1); sy.syn = sym[2].syn; break; // E --&gt; *DE case 6: work(s, sym[1], cur+1); sym[2].inh = sy.inh/sym[1].syn; work(s, sym[2], cur+1); sy.syn = sym[2].syn; break; // E --&gt; /DE case 8: sy.syn = sym[0].syn; break; // D --&gt; digit case 9: work(s, sym[1], cur+1); sy.syn = sym[1].syn; work(s, sym[2], cur+1); break; // D --&gt; (A) &#125; &#125; if( cur == 0 ) throw sy.syn;&#125;int main()&#123; string in; string coin; initid(); inittable(); while( getline(cin, in) ) &#123; in.push_back(&#x27;$&#x27;); int len = in.length(); const char* s = in.c_str(); coin.clear(); for(int i=0; i &lt; len; ++i) if( s[i] !=&#x27; &#x27; &amp;&amp; s[i] != &#x27;\\t&#x27; &amp;&amp; s[i] != &#x27;\\n&#x27; ) coin.push_back(s[i]); coin.push_back(&#x27;\\0&#x27;); /* 以上去除空格 */ try &#123; node sy = node(idx(&#x27;A&#x27;)); s = coin.c_str(); work(s, sy, 0); &#125; catch(const char* str) &#123; puts(str); &#125; catch(int ans) &#123; for(int i=0; i &lt; len-1; ++i) putchar(in[i]); printf(&quot; = %d\\n&quot;, ans); printf(&quot;succuss!\\n&quot;); &#125; &#125; return 0; &#125;","tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://littleclown.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法制导翻译","slug":"语法制导翻译","permalink":"http://littleclown.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"},{"name":"计算机","slug":"计算机","permalink":"http://littleclown.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"语法分析","date":"2016-06-18T06:27:03.000Z","path":"study/computer/fundamentals-of-compiling/grammer/","text":"FIRST计算方法$FIRST(X)$ 如果 $X$ 是一个终结符号，那么 $FIRST(X) = X$ 如果 $X \\rightarrow \\varepsilon$ 是一个产生式，那么 $\\varepsilon \\in FIRST(X)$ 如果 $X$ 是一个非终结符号，且 $X \\rightarrow Y_1Y_2\\cdots Y_k$ 是一个产生式： $FIRST(Y_1) \\in FIRST(X)$ 对于 $1 \\leqslant t \\leqslant k$，如果 $\\varepsilon \\in FIRST(Y_s)$, $1\\leqslant s &lt; t$ 成立，则 $FIRST(Y_t) \\in FRIST(X)$。 $FIRST(X_1X_2\\cdots X_k)$ 向 $FIRST(X_1X_2\\cdots X_k)$ 加入 $FIRST(X_1)$ 的所有非 $\\varepsilon$ 符号 如果 $\\varepsilon \\in FIRST(X_1)$，再加入 $FIRST(X_2)$ 的所有非 $\\varepsilon$ 符号；以此类推 如过 $\\varepsilon \\in FIRST(X_t)$ 对 $1 \\leqslant t\\leqslant k$ 均成立，则将 $\\varepsilon$ 加入 FIRST($X_1X_2\\cdots X_k$) 中 HintFIRST 集合大概就是在语法分析树中，当前节点即将扩展的下一个节点的点集。 FOLLOW计算方法 $S$ 是开始符号，$ 是输入右端的结束标记 将 $ 放到 $FOLLOW(S)$ 中 如果存在一个产生式 $A \\rightarrow \\alpha B\\beta$，将 $FIRST(\\beta)$ 中所有的非 $\\varepsilon$ 符号放入到 $FOLLOW(B)$ 中 如果存在一个产生式 $A \\rightarrow \\alpha B$ 或存在一个产生式 $A \\rightarrow \\alpha B\\beta$ 且 $\\varepsilon \\in FIRST(\\beta)$，将 $FOLLOW(A)$ 中所有符号放到 $FOLLOW(B)$ 中 HintFOLLOW 集合大概就是在语法分析树中，以当前节点为根节点的子树扩展完毕后，回溯时所即将扩展的下一个节点的点集。 自顶向下的语法分析LL(1) 文法 有二义性和左递归的文法都不是 $LL(1)$ 的 一个文法是 $LL(1)$ 的，当且仅当 $G$ 的任意两个不同的产生式 $X \\rightarrow \\alpha \\mid \\beta$ 满足： $FIRST(\\alpha)$ 和 $FIRST(\\beta)$ 是不相交的集合。也就是不存在左公因子。 如果 $\\epsilon \\in FIRST(\\alpha)$，则 $FIRST(X)$ 和 $FIRST(\\beta)$ 是不相交的集合 如果 $\\epsilon \\in FIRST(\\beta)$，则 $FIRST(X)$ 和 $FIRST(\\alpha)$ 是不相交的集合 预测分析表 对于 $G$ 的每个产生式 $A \\rightarrow \\alpha$ 对于 $FIRST(\\alpha)$ 中的每个终结符号 $a$，将 $A \\rightarrow \\alpha$ 加入到 $M[A,a]$中 如果 $\\epsilon$ 在 $FIRST(\\alpha)$ 中： 那么对于 $FOLLOW(A)$ 中的每个终结符号 $b$，将 $A \\rightarrow \\alpha$ 加入到 $M[A,b]$ 中 如果 $ 在 $FOLLOW(A)$ 中，将 $A \\rightarrow \\alpha$ 加入到 $M[A,$]$ 中 自底向上的语法分析规范 LR(0) 项集族项集的闭包 如果 $I$ 是文法 $G$ 的一个项集，那么 $CLOSURE(I)$ 可由下面两个规则从 $I$ 构造得到。 将 $I$ 中的各个项加入到 $CLOSURE(I)$ 中； 如果 $A \\rightarrow \\alpha \\cdot B\\beta$ 在 $CLOSURE(I)$ 中， $B \\rightarrow \\gamma$ 是一个产生式，并且项 $B \\rightarrow \\cdot ~\\gamma$ 不在 $CLOSURE(I)$ 中，就将这个项加入其中。 不断应用这个规则，直到没有新项加入到 $CLOSURE(I)$ 中为止。 直观地讲，CLOSURE$(I)$ 中的项 $A \\rightarrow \\alpha \\cdot B\\beta$ 表明在语法分析过程的某点上，我们认为接下来可能会在输入中看到一个能够从 $B\\beta$ 推导得到的子串。 GOTO 函数 $GOTO(I,X)$，其中 $I$ 是一个项集，$X$ 是一个文法符号。 $GOTO(I,X)$ 被定义为 $I$ 中所有形如 $[A \\rightarrow \\alpha \\cdot X\\beta]$ 的项所对应的项 $[A \\rightarrow \\alpha X \\cdot \\beta]$ 的集合的闭包。 直观地讲，GOTO 函数用于定义一个文法的 LR(0) 自动机中的转换，描述了当输入为 $X$ 时离开状态 $I$ 的转换。 构造项集族 初始时，$C=I_0=\\Big\\lbrace CLOSURE\\big( \\big\\lbrace \\big[ S’ \\rightarrow \\cdot S \\big] \\big\\rbrace \\big)\\Big\\rbrace$ 对于 $C$ 中的每个项集 $I$： - 对于每个文法符号 $X$： 如果 $GOTO(I,X)$ 非空且不在 $C$ 中，将 $GOTO(I,X)$ 加入到 $C$ 中 重复过程 2 构造 SLR 语法分析表 构造 $G’$ 的规范 $LR(0)$ 项集族 $C=\\lbrace I_0,I_1,\\cdots,I_n \\rbrace$。 根据 $I_i$ 构造得到状态 $i$。状态 $i$ 的语法分析动作按照下面的方法决定： - 如果 $[A \\rightarrow \\alpha \\cdot a\\beta]$ 在 $I_i$ 中，并且 $GOTO(I_i,a)=I_j$， 令 $ACTION[i,a]=s_j$，即 移入 $j$；其中，$a$ 必须是终结符。 - 如果 $[A \\rightarrow \\alpha \\cdot]$ 在 $I_i$ 中，那么对于 $FOLLOW(A)$ 中的所有 $a$， 令 $ACTION[i,a]=r_j$，即 规约 $j$；其中，**$j$ 为产生式 $A \\rightarrow \\alpha$ 的编号**；$A \\neq S’$。 - 如果 $[S’ \\rightarrow S \\cdot]$ 在 $I_i$ 中，令 $ACTION[i,$]=acc$，即 接受。 如果根据上面的规则生成了任何冲突动作，则这个文法不是 $SLR(1)$ 的。 状态 $i$ 对于各个非终结符号 $A$ 的 $GOTO$ 转换使用下面的规则构造得到： 如果 $GOTO(I_i,A)=I_j$， 那么，$GOTO[i,A]=j$。 规则(2)和规则(3) 没有定义的条目均设为“报错”。 语法分析器的初始状态是根据 $[S’ \\rightarrow \\cdot S]$ 所在项集构造得到的状态。 有效 LR(1) 项集族 可行前缀 可以出现在一个 移入–规约 的语法分析器的栈中的最右句型前缀，称为 可行前缀 $LR(1)$ 项 形如 $\\big[ A \\rightarrow \\alpha \\cdot \\beta, a \\big]$ 的项，称为 $LR(1)$ 项；其中 $A \\rightarrow \\alpha\\beta$ 是一个产生式，$a$ 是一个终结符或右端结束标记 $ 形如 $\\big[ A \\rightarrow \\alpha \\cdot, a \\big]$ 的项只有在下一个输入符号为 $a$ 时才选择 $A \\rightarrow \\alpha$ 规约。 可行前缀的有效项 $LR(1)$ 项 $\\big[ A \\rightarrow \\alpha \\cdot \\beta, a \\big]$ 对于可行前缀 $\\gamma$ 有效的条件是： 存在一个最右推导 $S \\overset{*}{\\underset{rm}{\\Rightarrow}} \\delta A\\omega \\underset{rm}\\Rightarrow \\delta\\alpha\\beta\\omega$，且 $\\gamma = \\delta\\alpha$，且 要么 $a$ 是 $\\omega$ 的第一个符号，要么 $\\omega=\\varepsilon$ 且 $a=$$ 项集的闭包如果 $\\big[ A \\rightarrow \\alpha \\cdot B\\beta, a \\big]$ 对可行前缀 $\\gamma=\\delta\\alpha$ 有效， 那么必然存在一个最右推导 $S \\overset{*}{\\underset{rm}{\\Rightarrow}} \\delta A\\alpha x \\underset{rm}\\Rightarrow \\delta\\alpha B\\beta ax$。 假设 $\\beta ax$ 推导出终结符号串 $by$，那么对于某个形如 $B \\rightarrow \\eta$ 的产生式，有推导 $S \\overset{*}{\\underset{rm}{\\Rightarrow}} \\gamma Bby \\underset{rm}\\Rightarrow \\gamma\\eta by$。因此，$\\big[ B \\rightarrow \\cdot\\eta, b \\big]$ 是 $\\gamma$ 的有效项。其中，$b \\in FIRST(\\beta a)$。 如果 $I$ 是文法 $G$ 的一个项集，那么 $CLOSURE(I)$ 可由下列规则从 $I$ 中构造得到。 对于 $I$ 中的每个项 $\\big[ A \\rightarrow \\alpha\\cdot B\\beta,a \\big]$ 对于 $G’$ 中的每个产生式 $B \\rightarrow \\gamma$ 对于 $FIRST(\\beta a)$ 中的每个终结符号 $b$ 将 $\\big[ B \\rightarrow \\gamma, b \\big]$ 加入到集合 $I$ 中 Hint 本质上，$SLR$ 是利用 $LR(0)$ 自动机能够识别可行前缀这一事实构造的语法分析方案；$LR(1)$ 在此基础上考虑了对可行前缀的 有效性。 $LR(1)$ 和 $LR(0)$ 构造闭包的算法的区别在于： 不再对于任意的 $\\big[ A \\rightarrow \\alpha\\cdot B\\beta ]$ 添加到闭包中了， 这样做的目的是为了减少 移入–规约 冲突。也就是，如果 $I$ 中有产生式 $A \\rightarrow \\alpha\\cdot B\\beta$，对于产生式 $B \\rightarrow \\eta$： SLR：直接将 $B \\rightarrow \\eta$ 加进 $I$ 的闭包中 LR(1)：由于有一个向前看符号，不妨记 $A \\rightarrow \\alpha\\cdot B\\beta$ 的向前看符号为 $a$，那么仅当满足 $a \\in FIRST(\\beta a)$ 时才能将 $B \\rightarrow \\eta$ 加进 $I$ 的闭包 GOTO 函数 计算 $GOTO(I,X)$ 将 $J$ 初始化为空集 对于 $I$ 中的每个项 $\\big[ A \\rightarrow \\alpha\\cdot X\\beta,a \\big]$ 将项 $\\big[ A \\rightarrow \\alpha X\\cdot \\beta,a \\big]$ 加入到集合 $J$ 中 返回 $CLOSURE(J)$ 构造项集族 初始时， $C=I_0=\\Big\\lbrace CLOSURE\\big( \\big\\lbrace \\big[ S’ \\rightarrow \\cdot S,$ \\big] \\big\\rbrace \\big)\\Big\\rbrace$ 对于 $C$ 中的每个项集 $I$ 对于每个文法符号 $X$ 如果 $GOTO(I,X)$ 非空且不在 $C$ 中 将 $GOTO(I,X)$ 加入 $C$ 中 构造规范 LR(1) 语法分析表 构造 $G’$ 的规范 $LR(0)$ 项集族 $C=\\lbrace I_0,I_1,\\cdots,I_n \\rbrace$。 根据 $I_i$ 构造得到状态 $i$。状态 $i$ 的语法分析动作按照下面的方法决定： - 如果 $[A \\rightarrow \\alpha \\cdot a\\beta, b]$ 在 $I_i$ 中，并且 $GOTO(I_i,a)=I_j$， 令 $ACTION[i,a]=s_j$，即 移入 $j$；其中，$a$ 必须是终结符。 - 如果 $[A \\rightarrow \\alpha \\cdot, a]$ 在 $I_i$ 中，且 $A \\neq S’$； 那么令 $ACTION[i,a]=r_j$，即 规约 $j$；其中，**$j$ 为产生式 $A \\rightarrow \\alpha$ 的编号**。 - 如果 $[S’ \\rightarrow S \\cdot, $]$ 在 $I_i$ 中，令 $ACTION[i,$]=acc$，即 接受。 如果根据上面的规则生成了任何冲突动作，则这个文法不是 $LR(1)$ 的。 状态 $i$ 对于各个非终结符号 $A$ 的 $GOTO$ 转换使用下面的规则构造得到： 如果 $GOTO(I_i,A)=I_j$， 那么，$GOTO[i,A]=j$。 规则(2)和规则(3) 没有定义的条目均设为“报错”。 语法分析器的初始状态是根据 $[S’ \\rightarrow \\cdot S, $]$ 所在项集构造得到的状态。","tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://littleclown.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机","slug":"计算机","permalink":"http://littleclown.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"语法分析","slug":"语法分析","permalink":"http://littleclown.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"百度之星 2016 解题报告","date":"2016-06-03T10:11:48.000Z","path":"acm/contest/baiduzhixing/2016/","text":"1002 K 个连通块题目链接 题目简析假入 $N$ 个点依次为：$\\displaystyle V=\\left\\lbrace A_0,A_1,\\cdots,A_{N-1} \\right\\rbrace$。不难想到状态压缩。令 $dp[k][s]$ 表示点集 $\\displaystyle V_s=\\big\\lbrace A_i ~~ \\big| ~~\\left\\lfloor \\frac{s}{2^i} \\right\\rfloor \\equiv 1\\hskip -1em\\mod 2 \\text{（即 $s&amp;2^i=1$）} \\big\\rbrace$ 恰好构成 $k$ 个连通块的方案数。要注意的是，点对 $\\displaystyle \\big\\lbrace (u,v) ~~ \\big| ~~ u \\in V, v\\in V_s \\big\\rbrace$ 之间的连边都要抹去，因为 $V_s$ 中的点首先要和不在 $V_s$ 中的断开“联系”，才能得到独立的 $k$ 连通块，这样才能正确递推。 先考虑如何求 $dp[1][s]$。 为方便叙述，记 $f(s) = dp[1][s]$， $\\displaystyle s=2^{j_1}+2^{j_2}+\\cdots+2^{j_t}$，故其所代表点集为 $\\displaystyle V_s=\\big\\lbrace A_{j_1},A_{j_2},\\cdots,A_{j_t} \\big\\rbrace,(0\\leqslant j_1 &lt; j_2 &lt; \\cdots &lt; j_t \\leqslant N-1)$。令 $E(s)$ 表示 $V_s$ 中的互不相同的两点之间的边的总数；则\\begin{align} f(s) = 2^{E(s)} - \\sum_{A_{j_1} \\in V_{s’},~V_{s’} \\in \\lbrace V_s \\rbrace} f(s’) \\times 2^{E(s-s’)}\\end{align}证明并不难：为使 $V_s$ 为一个独立的连通块，则需要考虑两个部分。 $V_s$ 中的点与不在 $V_s$ 中的点之间不连通；因此，我们仅需考虑 $V_s$ 中两两之间的边，去边的总方案为 $2^{E(s)}$。 $V_s$ 内部的点两两连通；可以反过来考虑，减去所有使得内部不连通的情况。将点集 $V_s$ 分成 $V_{s’}$ 和 $V_{s’’}$ 两部分，其中 $V_{s’}+V_{s’’}=V_s$ 且 $A_{j_1} \\in V_{s’}$，且 $V_{s’}$ 构成一个独立的连通块。对于这一划分方案，共有 $f(s’) \\times 2^{E(s-s’)}$ 种方案使得 $V_{s’}$ 和 $V_{s’’}$ 之间不连通。因为 $V_{s’}$ 是一个独立的连通块，所以 $V_{s’}$ 和 $V_{s’’}$ 之间的边必须全断，则 $V_{s’’}$ 中的边可以自由选择了。 再考虑如何递推。 不难想到递推方程 $\\displaystyle dp[k+1][s]=\\sum_{V_{s’} \\in V_s} dp[k][s’] \\times dp[1][s-s’]$。但是，很遗憾，因为它是错的。考虑 $k=3$ 的情况，如果 $V_s=\\big\\lbrace A_1, A_2,A_3 \\big\\rbrace$，则 $V_{s’}=\\big\\lbrace A_1,A_2 \\big\\rbrace$ 与 $V_{s’}=\\big\\lbrace A_1, A_3 \\big\\rbrace$ 所做的贡献是完全重复的。为了避免重复，我们得到新的递推式\\begin{align} dp[k+1][s]=\\sum_{A_{j_1} \\notin V_{s’},~V_{s’} \\in V_s} dp[k][s’] \\times dp[1][s-s’]\\end{align}不难验证其正确性。 进一步分析上述分析足以通过此题，我跑了 858MS。但还有改进的余地。先改造一下递推式，记 $V’_s=V-V_{s’}=\\big\\lbrace A_{p_1},A_{p_2},\\cdots,A_{p_q} \\big\\rbrace$。\\begin{align} dp[k+1][s]=\\sum_{A_{j_1} \\in V_{s’},V_{s’} \\in V_s,A_{p_1} \\in V_{s-s’}} dp[k][s’] \\times dp[1][s-s’]\\end{align}上述递推式用刷表法实现即可避免 $A_{p_1} \\in V_{s-s’}$ 的判断。注意到我们要的终态是 $dp[K][2^N-1]$，所以，我们可以只计算满足 $A_1 \\in V_s$ 的状态 $dp[K][s]$，理由是 $A_1 \\in V_{s’}$，即这条递推到 $dp[K][s]$ 的递推链都可以被计算到。当然，也可以采取记忆化搜索。跑了 124MS 左右。 复杂度分析空间复杂度 $O(2^N)$时间复杂度 $O(N^2 \\cdot 2^N+K \\cdot 3^N)$ 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int MAXN = 15;const int MOD = 1000000000+9;int G[MAXN][MAXN];int p2[MAXN*MAXN];int l2[1&lt;&lt;MAXN];int dp[2][1&lt;&lt;MAXN];int f[1&lt;&lt;MAXN];int c[1&lt;&lt;MAXN];inline int lowbit(int&amp; x) &#123; return x &amp; -x;&#125;inline void add(int&amp; x, int y) &#123; x += y; if( x &gt;= MOD ) x -= MOD;&#125;inline void sub(int&amp; x, int y) &#123; x -= y; if( x &lt; 0 ) x += MOD;&#125;int calc(int N, int K) &#123; const int all = (1&lt;&lt;N) - 1; int now = 0, last = 1; for(int s=0; s &lt;= all; s+=2) dp[0][s] = 0; for(int s=1; s &lt;= all; s+=2) dp[0][s] = f[s]; for(int k=1; k &lt; K; ++k) &#123; swap(now, last); memset(dp[now], 0, sizeof dp[now]); for(int s=1; s &lt;= all; ++s) &#123; if( !dp[last][s] ) continue; int r = all^s; int x = lowbit(r); r ^= x; for(int t=r; t; t=(t-1)&amp;r) add(dp[now][s|x|t], (LL) dp[last][s]*f[t|x] %MOD); add(dp[now][s|x], (LL) dp[last][s]*f[x] %MOD); &#125; &#125; return dp[now][all];&#125;void solve(int N, int K, int e) &#123; const int all = (1&lt;&lt;N) - 1; static int vi[20]; int siz, cnt; for(int s=1; s &lt;= all; ++s) &#123; siz = cnt = 0; for(int u=s, v; u; u^=v) vi[siz++] = l2[v=lowbit(u)]; for(int u=0; u &lt; siz; ++u) for(int v=u+1; v &lt; siz; ++v) cnt += G[vi[u]][vi[v]]; c[s] = p2[cnt]; &#125; memcpy(f, c, sizeof f); for(int s=1; s &lt;= all; ++s) &#123; int ls = lowbit(s); if( ls == s ) continue; int r = s^ls; for(int t=(r-1)&amp;r; t; t=(t-1)&amp;r) sub(f[s], (LL) f[t|ls]*c[r^t] %MOD); sub(f[s], (LL) f[ls]*c[r] %MOD); &#125; int ans = (LL) calc(N, K)*p2[e] %MOD; printf(&quot;%d\\n&quot;, ans);&#125;void work() &#123; p2[0] = 1; for(int i=1; i &lt; MAXN*MAXN; ++i) p2[i] = p2[i-1]*2 %MOD; for(int i=0; i &lt; MAXN; ++i) l2[1&lt;&lt;i] = i; int T_T, N, M, K, e, u, v; scanf(&quot;%d&quot;, &amp;T_T); for(int kase=1; kase &lt;= T_T; ++kase) &#123; printf(&quot;Case #%d:\\n&quot;, kase); memset(G, 0, sizeof G); e = 0; scanf(&quot;%d%d%d&quot;, &amp;N, &amp;M, &amp;K); for(int i=0; i &lt; M; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if( u &gt; v ) swap(u, v); if( u != v ) ++G[u-1][v-1]; else ++e; &#125; solve(N, K, e); &#125;&#125;int main()&#123; work(); return 0;&#125; 1004 XOR 游戏题目链接 题目简析设 $dp[k][n]$ 表示将前 $n$ 个数划分成 $k$ 组的合法方案的 分组异或和最小值 的最大值；设 $A[n]$ 表示前 $n$ 个数的异或和。不难得到递推方程：$dp[k+1][n] = \\max \\Big\\lbrace \\min \\big\\lbrace dp[k][n-i], A[n] \\oplus A[n-i] \\big\\rbrace \\Big\\rbrace, 1\\leqslant i\\leqslant L$。很可惜，这个方程的时间复杂度是 $O(M\\cdot N\\cdot L)$ 的，难以承受。 如何在更短的时间内求出 $dp[k+1][n] = \\max \\Big\\lbrace \\min \\big\\lbrace dp[k][n-i], A[n] \\oplus A[n-i] \\big\\rbrace \\Big\\rbrace, 1\\leqslant i\\leqslant L$ 呢？ 算法一先假设 $\\big\\lbrace A[n-L],A[n-L+1],\\cdots,A[n-1] \\big\\rbrace$ 两两不相等；并将其二进制表示插入字典树中。字典树中 表示 $A[i]$ 的链 的叶子节点的权值为 $dp[k][i]$，非叶子节点权值为所有子孙节点权值最大值。那么，计算 $dp[k+1][n]$ 时，仅需在用字典树贪心求 $A[n]$ 最大异或和的基础上，将节点的权值作为选择贪心策略的依据。具体地： 设当前在字典树中第 h 层(考虑到题目的数据范围，从 31 开始递减计数，所有叶子节点都在第 0 层)：记在前面 $31-h$ 层中，选择的边边权依次为：$a_{30},a_{29},\\cdots,a_{h}$。记 $x=A[n]=b_{30}\\cdot 2^{30}+b_{29}\\cdot 2^{29}+\\cdots+b_0 2^{0}$；$y=(a_{30} \\oplus b_{30})\\cdot 2^{30}+(a_{29} \\oplus b_{29})\\cdot 2^{29}+\\cdots+(a_{h} \\oplus b_{h})\\cdot 2^h$。接下来考虑下一层往哪走，即 $a_{h-1}$ 的取值。记与当前节点相连且边权为 $a_{h-1} = b_{h-1} \\oplus 1$ 的子节点为 $o_1$；另一子节点为 $o_2$。其权值依次为 $val(o_1),~val(o_2)$。 $\\displaystyle \\left\\lfloor \\frac{x}{2^h} \\right\\rfloor \\equiv 1\\hskip -1em \\mod 2$。 也就是 $b_h=1$。 如果 $val(o_1) &lt; y+2^{h-1}$，说明如果下一步选择 $o_1$，则 $\\max \\Big\\lbrace \\min \\big\\lbrace dp[k][n-i], A[n] \\oplus A[n-i] \\big\\rbrace \\Big\\rbrace = val(o_1)$，所以我们 仅需选择 $o_2$ 求出一个最优值 $ans_2$，最后的答案就是 $\\max \\big\\lbrace val(o_1),ans_2 \\big\\rbrace$。 如果 $val(o_1) \\geqslant y+2^{h-1}$，即选择 $o_1$，则最坏情况答案不小于 $y+2^{h-1}$。同时，选择 $o_2$，最好的情况不会大于 $y+2^{h-1}$。所以我们 仅需选择 $o_1$ 求出一个最优值 $ans_1$，即是最后的答案。 $\\displaystyle \\left\\lfloor \\frac{x}{2^h} \\right\\rfloor \\equiv 0\\hskip -1em \\mod 2$。 也就是 $b_h=0$。 只有走到 $o_2$ 这一个选择。 根据上面的分析，不难发现，查询操作时间复杂度为 $O(1)$。如果存在一对 $(i,j)$ 使得 $A[i]=A[j]$ 呢？ 事实上，只要保证字典树中的表示 $A[i]$ 的链的叶子节点权值为 $\\max \\big\\lbrace dp[k][n-i],dp[k][n-j] \\big\\rbrace$ 就好了。可以先将 $A$ 离散化，开 $N$ 棵 $multiset$。那么，在删除 $dp[k][n-L-1]$ 时，只要将 $A[n-L-1]$ 对应的 $multiset$ 中最大权值更新到字典树中即可。 复杂度分析时间复杂度：$O(M\\cdot N\\cdot \\log L)$空间复杂度：$O(N)$ 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;set&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;static const int MAXN = 10000+10;struct node &#123; node *ch[2]; int val; void Maintain() &#123; val = 0; if( ch[0] ) val = ch[0]-&gt;val; if( ch[1] ) val = std:: max(val, ch[1]-&gt;val); &#125;&#125;;node nodepool[MAXN&lt;&lt;5];node* nodetop;node* root;inline node* newnode() &#123; nodetop-&gt;ch[0] = nodetop-&gt;ch[1] = NULL; nodetop-&gt;val = 0; return nodetop++;&#125;void Update(node* &amp;o, int x, int v, int d=30) &#123; if( o == NULL ) o = newnode(); if( d == -1 ) o-&gt;val = v; else &#123; int c = (x&gt;&gt;d) &amp; 1; Update(o-&gt;ch[c], x, v, d-1); o-&gt;Maintain(); &#125;&#125;int Query(node* &amp;o, int x, int ans=0, int d=30) &#123; if( o == NULL ) return 0; if( d == -1 ) return min(o-&gt;val, ans); int c = (x&gt;&gt;d) &amp; 1; if( o-&gt;ch[c^1] ) &#123; if( o-&gt;ch[c^1]-&gt;val &lt; (ans^(1&lt;&lt;d)) ) return max(o-&gt;ch[c^1]-&gt;val, Query(o-&gt;ch[c], x, ans, d-1)); return Query(o-&gt;ch[c^1], x, ans^(1&lt;&lt;d), d-1); &#125; return Query(o-&gt;ch[c], x, ans, d-1);&#125;inline int read() &#123; int s = 0; char c = getchar(); bool positive = true; for(; !isdigit(c); c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; isdigit(c); c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;multiset&lt;int&gt; ms[MAXN];int A[MAXN];int B[MAXN], bsiz;int dp[2][MAXN];inline void add(int x, int v) &#123; int id = lower_bound(B, B+bsiz, x) - B; if( ms[id].upper_bound(v) == ms[id].end() ) Update(root, B[id], v); ms[id].insert(v);&#125;inline void sub(int x, int v) &#123; int id = lower_bound(B, B+bsiz, x) - B; multiset&lt;int&gt;:: iterator it; it = ms[id].find(v); ms[id].erase(it); int vv = 0; if( !ms[id].empty() ) &#123; it = ms[id].end(); vv = *(--it); &#125; if( vv &lt; v ) Update(root, B[id], vv);&#125;void work() &#123; int N = read(); int K = read(); int L = read(); for(int i=1; i &lt;= N; ++i) A[i] = A[i-1]^read(); memcpy(B, A+1, sizeof(int)* N); sort(B, B+N); bsiz = std:: unique(B, B+N) - B; memset(dp[0], 0, sizeof dp[0]); for(int i=1; i &lt;= L; ++i) dp[0][i] = A[i]; int now = 0, last = 1; for(int k=2; k &lt;= K; ++k) &#123; nodetop = nodepool; root = newnode(); for(int i=0; i &lt; bsiz; ++i) ms[i].clear(); swap(now, last); for(int n=1; n &lt;= N; ++n) &#123; if( n &gt; L+1 ) sub(A[n-L-1], dp[last][n-L-1]); dp[now][n] = Query(root, A[n]); add(A[n], dp[last][n]); &#125; &#125; printf(&quot;%d\\n&quot;, dp[now][N]);&#125;int main()&#123; int T_T = read(); for(int kase=1; kase &lt;= T_T; ++kase) &#123; printf(&quot;Case #%d:\\n&quot;, kase); work(); &#125; return 0;&#125; Hint在离散化过程中使用排序，查询使用 $lowerbound$，复杂度退化为 $O(M\\cdot N\\cdot(\\log L+\\log N))$。不过，仍然只跑了 $202MS$。 算法二重新定义 $dp[k][n]$。给定一个下界 $val$，定义 $dp[k][n]$ 为能否将前 $n$ 个数分成 $k$ 份，使得合法方案的 分组异或和最小值 的最大值大于等于 $val$。那么，我们仅需将 $1\\leqslant i\\leqslant L$ 中满足 $dp[k][n-i]=true$ 的 $A[n-i]$ 丢进字典树中，则仅需判断字典树中的数与 $A[n]$ 最大异或值是否大于等于 $val$ 即可。然后，仅需二分 $val$ 即可。 复杂度分析时间复杂度：$O(M\\cdot N\\cdot \\log N)$空间复杂度：$O(N)$ 程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000;struct node &#123; node* ch[2]; int val; node(int val=0): val(val) &#123; ch[0] = ch[1] = NULL; &#125;&#125;;node* root;node* nodetop;node nodepool[MAXN&lt;&lt;5];bool dp[12][MAXN];int A[MAXN];int N, K, L;inline node* newnode() &#123; nodetop-&gt;ch[0] = nodetop-&gt;ch[1] = NULL; nodetop-&gt;val = 0; return nodetop++;&#125;inline void Insert(int x, int d) &#123; node* u = root; for(int i=30; i &gt;= 0; --i) &#123; int c = (x&gt;&gt;i) &amp; 1; if( !u-&gt;ch[c] ) u-&gt;ch[c] = newnode(); u = u-&gt;ch[c]; u-&gt;val += d; &#125;&#125;inline int Search(int x) &#123; node* u = root; int ans = 0; for(int i=30; i &gt;= 0; --i) &#123; int c = (x&gt;&gt;i) &amp; 1; if( u-&gt;ch[c^1] &amp;&amp; u-&gt;ch[c^1]-&gt;val &gt; 0 ) &#123; ans ^= 1&lt;&lt;i; u = u-&gt;ch[c^1]; &#125; else if( u-&gt;ch[c] ) u = u-&gt;ch[c]; &#125; return ans;&#125;inline int read() &#123; int s = 0; char c = getchar(); bool positive = true; for(; !isdigit(c); c=getchar()) if( c == &#x27;-&#x27; ) positive = false; for(; isdigit(c); c=getchar()) s = s*10 + c-&#x27;0&#x27;; return positive? s: -s;&#125;bool check(int val) &#123; memset(dp[1], 0, sizeof dp[1]); for(int n=1; n &lt;= L; ++n) dp[1][n] = A[n] &gt;= val? true: false; for(int k=2; k &lt;= K; ++k) &#123; nodetop = nodepool; root = newnode(); for(int n=1; n &lt;= N; ++n) &#123; if( n &gt; L+1 &amp;&amp; dp[k-1][n-L-1] ) Insert(A[n-L-1], -1); dp[k][n] = Search(A[n]) &gt;= val? true: false; if( dp[k-1][n] ) Insert(A[n], 1); &#125; &#125; return dp[K][N];&#125;void work() &#123; N = read(); K = read(); L = read(); for(int i=1; i &lt;= N; ++i) A[i] = A[i-1]^read(); int lft = 0, rht = (1&lt;&lt;30) | 1; while( lft &lt; rht ) &#123; int mid = (lft+rht) &gt;&gt; 1; if( check(mid) ) lft = mid+1; else rht = mid; &#125; printf(&quot;%d\\n&quot;, lft-1);&#125;int main()&#123; int T_T = read(); for(int kase=1; kase &lt;= T_T; ++kase) &#123; printf(&quot;Case #%d:\\n&quot;, kase); work(); &#125; return 0;&#125; Hint算法二思路简单，实现难度小，效率还不错，跑了 $1092MS$。","tags":[{"name":"递推","slug":"递推","permalink":"http://littleclown.github.io/tags/%E9%80%92%E6%8E%A8/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://littleclown.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"动态规划","slug":"动态规划","permalink":"http://littleclown.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字典树","slug":"字典树","permalink":"http://littleclown.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"python 字符串操作","date":"2016-05-28T07:45:45.000Z","path":"study/codding/programming-language/python/string/1/","text":"python 字符串可由 单引号&#39; 或 双引号&quot; 括起来，二者无区别；引号可用 反斜杠\\ 转义在引号前加一个 r 可以使得引号中的字符保留原义 12345&gt;&gt;&gt; print(&#x27;\\some\\name&#x27;)\\someame&gt;&gt;&gt; print(r&#x27;\\some\\name&#x27;)\\some\\name 字符串运算符 连接 ‘+’1234&gt;&gt;&gt; h = &#x27;hello&#x27;&gt;&gt;&gt; w = &#x27;world&#x27;&gt;&gt;&gt; print(h+&#x27;, &#x27;+w)hello, world 重复 ‘*’1234567&gt;&gt;&gt; h = &#x27;hello&#x27;&gt;&gt;&gt; w = &#x27;world&#x27;&gt;&gt;&gt; print((h+&#x27;, &#x27;+w+&#x27;\\n&#x27;)*3)hello, worldhello, worldhello, world 索引、切片 ‘[]’关于 索引 和 切片 的特性其实对于 python 其它的容器（如：list,tuple 等）同样有效。 12345678&gt;&gt;&gt; h = &#x27;hello&#x27;&gt;&gt;&gt; w = &#x27;world&#x27;&gt;&gt;&gt; print(&#x27;h[0]:&#x27;, h[0], &#x27;\\t|\\t&#x27;, &#x27;w[2]:&#x27;, w[2])h[0]: h | w[2]: r&gt;&gt;&gt; print(&#x27;h[1:3]:&#x27;, h[1:3], &#x27;\\t|\\t&#x27;, &#x27;h[:3]:&#x27;, h[:3], &#x27;\\t|\\t&#x27;, &#x27;h[3:]:&#x27;, h[3:])h[1:3]: el | h[:3]: hel | h[3:]: lo&gt;&gt;&gt; print(&#x27;w[-1:1]:&#x27;, w[-1:1], &#x27;\\t|\\t&#x27;, &#x27;w[1:-1]:&#x27;, w[1:-1], &#x27;\\t|\\t&#x27;, &#x27;w[-4:4]:&#x27;, w[-4:4])w[-1:1]: | w[1:-1]: orl | w[-4:4]: orl 比较在 python3 中，不再支持 cmp 函数。只能使用 operator 模块的函数： operator 等效于传统比较运算符 operator.lt(a,b) a &lt; b operator.le(a,b) a &lt;= b operator.eq(a,b) a == b operator.nq(a,b) a != b operator.ge(a,b) a &gt;= b operator.gt(a,b) a &gt; b 常用内置函数分割splitsplit(sep=None, maxsplit=-1) 其中，sep 是分隔符，默认为空格；maxsplit 是最大分割次数，默认无限次（割完所有分隔符为止）。 split(sep=None, maxsplit=-1)[n] 选取第 $n+1$ 个分片。 re.splitimport re re.split(sep, str) 其中，sep 是分隔符，可以是正则表达式，str 为待分割字符串。re.split 同样支持取第 $n+1$ 个分片的写法。 import re re.split(sep, str)[n] 实例123456789101112&gt;&gt;&gt; S=&#x27;Never say Never&#x27;&gt;&gt;&gt; print(S.split(&#x27; &#x27;)) # 使用空格作为分割符[&#x27;Never&#x27;, &#x27;say&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Never&#x27;] # 无法分割多个空格&gt;&gt;&gt; import re # 使用正则表达式&gt;&gt;&gt; print(re.split(r&#x27;[ ]+&#x27;, S)) # 可以分割多个空格[&#x27;Never&#x27;, &#x27;say&#x27;, &#x27;Never&#x27;]&gt;&gt;&gt; print(re.split(r&#x27;[\\s,;]+&#x27;, &#x27;Never,; Say,,;,, Never&#x27;)) # \\s 匹配空格字符[&#x27;Never&#x27;, &#x27;Say&#x27;, &#x27;Never&#x27;]&gt;&gt;&gt; print(re.split(r&#x27;[ ]+&#x27;, S)[2]) # 选取第 3 个分片Never&gt;&gt;&gt; print(S.split(&#x27; &#x27;, 1)) # 分割一次[&#x27;Never&#x27;, &#x27;say Never&#x27;]","tags":[{"name":"python","slug":"python","permalink":"http://littleclown.github.io/tags/python/"},{"name":"字符串","slug":"字符串","permalink":"http://littleclown.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"技术","slug":"技术","permalink":"http://littleclown.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"数论基础之离散对数","date":"2016-05-22T04:14:05.000Z","path":"study/math/number-theory/modular-arithmetic/discrete-logarithm/","text":"离散对数初步 问题描述求解 $0\\leqslant X &lt; C$ 使得 $\\displaystyle X^A \\equiv B\\hskip -1em \\mod C$ 成立。其中，$C$ 为素数。 问题简析由于 $C$ 是素数，所以必有 原根 $g$。用 Baby Step Gaint Step 算法先求出 $\\displaystyle g^t \\equiv B\\hskip -1em\\mod C$ 的解 $t$。令 $\\displaystyle X=g^s$，由于 $\\displaystyle g^{s\\cdot A}=(g^s)^A=X^A\\equiv B\\hskip -1em\\mod C\\equiv g^t\\hskip -1em\\mod C$，根据 ***数论欧拉定理***，有 $\\displaystyle g^{\\varphi(C)}\\equiv 1\\hskip -1em\\mod C$；所以可以用 扩展欧几里得算法 求出 $\\displaystyle s\\cdot A\\equiv t\\hskip -1em\\mod \\varphi(C)$ 的通解 $\\displaystyle s=s_0+k\\cdot\\frac{\\varphi(C)}{\\gcd\\big(\\varphi(C),A\\big)}$。再由快速幂求出 $\\displaystyle X=g^s=g^{s_0+k\\cdot\\frac{\\varphi(C)}{\\gcd\\big(\\varphi(C),A\\big)}}$。至此，问题圆满解决。 复杂度分析Baby Step Gaint Step 算法的复杂度是 $O(\\sqrt{C})$ 的，一共执行一次；扩展欧几里得算法是 $O(\\log C)$ 的，一共执行一次；快速幂是 $O(\\log C)$ 的，一共要执行 $\\displaystyle \\gcd\\big(\\varphi(C),A\\big)$ 次，所以时间复杂度为 $O(\\sqrt{C}+\\log C+\\gcd\\big(\\varphi(C),A\\big)\\cdot \\log C)$。空间复杂度与 Baby Step Gaint Step 空间复杂度同阶。 问题扩展$C$ 是合数呢？ 离散对数进阶问题描述求解 $0\\leqslant X &lt; C$ 使得 $\\displaystyle X^A \\equiv B\\hskip -1em \\mod C$ 成立。其中，$C$ 为素数，不保证 $\\gcd(X,C) = 1$。 问题简析不妨假设 $\\displaystyle C=p_1^{k_1}p_2^{k_2}\\cdots p_s^{k_s}$。令 $C_i=p_i^{k_i},~1\\leqslant i\\leqslant s$。 先考虑如何求 $\\displaystyle X_i^A\\equiv B\\hskip -1em\\mod C_i$ 的解。先考虑 $C_i\\mid B$ 的情况 因为 $C_i\\mid X_i^A$ 的充要条件为：$X_i^A=p_i^{k_i+\\theta}$ 且 $0\\leqslant \\theta$；或 $X_i=0$。所以，通解为：$\\displaystyle X_i=p_i^{\\left\\lceil \\frac{p_i}{A} \\right\\rceil+\\theta}$ 且 $0\\leqslant \\theta$；或 $X_i=0$。 再考虑 $C_i\\nmid B$ 的情况 若 $2 \\mid C_i$：由于 $C_i=2^{k_i}$ 当 $k_i\\geqslant 3$ 时不存原根，所以离散对数的方法失效；由于本人能力有限，未能提供好的方法，目前只能暴力；如有能力做到 $O(\\sqrt{C_i})$ 以下复杂度的朋友，还望不吝赐教。 若 $2 \\nmid C_i$：由于 $C_i=p_i^{k_i}$，所以必有原根 $g_i$；再由 扩展 Baby Step Gaint Step 算法解方程 $\\displaystyle g_i^{t_i}\\equiv B\\hskip -1em\\mod C_i$；剩下的问题可以套用 离散对数初步 解决。 回到原问题 【定理 1】 若 $\\displaystyle X^A\\equiv B\\hskip -1em\\mod C$ 成立，则 $\\displaystyle (X+C)^A\\equiv B\\hskip -1em\\mod C$ 成立。由二项式展开即可得证，证明略。 所以，接下来，我们仅需解方程组：\\begin{align} X &amp;\\equiv X_1\\hskip -1em\\mod C_1 \\ X &amp;\\equiv X_2\\hskip -1em\\mod C_2 \\ &amp;\\cdots \\ X &amp;\\equiv X_s\\hskip -1em\\mod C_s\\end{align} 由于 $C_i,C_j$ 两两互质，可由 中国剩余定理 求出 $X$。至此，问题还算圆满解决。 练习 problems categories solution 51Nod/X^A Mod P 离散对数初步 Code 51Nod/X^A Mod B 离散对数进阶 Code Hint鉴于本人能力有限，有误之处还望指正。","tags":[{"name":"数论","slug":"数论","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://littleclown.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://littleclown.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"Baby Step Gaint Step","slug":"Baby-Step-Gaint-Step","permalink":"http://littleclown.github.io/tags/Baby-Step-Gaint-Step/"},{"name":"原根","slug":"原根","permalink":"http://littleclown.github.io/tags/%E5%8E%9F%E6%A0%B9/"}]},{"title":"数论基础之原根","date":"2016-05-16T04:11:55.000Z","path":"study/math/number-theory/modular-arithmetic/primitive-root/","text":"什么是原根对于正整数 $N$，如果正整数 $g$ 满足 $\\gcd(g,N)=1$ 且 $\\big\\lbrace g^0,g^1,\\cdots,g^{\\varphi(N)-1}\\big\\rbrace$ 两两模 $N$ 不同余，则称 $g$ 为 $N$ 的一个原根。 由于：$\\displaystyle \\gcd(A,B)=1 \\Leftrightarrow \\gcd(A\\hskip -1em\\mod B,B)=1$。所以，$\\big\\lbrace g^0,g^1,\\cdots,g^{\\varphi(N)-1}\\big\\rbrace$ 构成 $N$ 的一个既约剩余系。 阶如果正整数 $X$ 和 $N$ 互质，且 $r$ 为使得 $\\displaystyle X^r\\equiv 1\\hskip -1em\\mod N$ 的最小正整数，则称 $r$ 为 $X$ 模 $N$ 的阶，记做 $\\displaystyle \\delta_N(X)=r$。 所以，原根的定义也可以描述为：$X$ 是模 $N$ 的一个原根的充要条件为 $\\varphi(N)=\\delta_N(X)$。 如何求原根 【性质 1】 $r \\mid \\varphi(N)$$\\hskip 1em$【证】$\\hskip 3em$ 由定义可知，$\\varphi(N) \\geqslant \\delta_N(X)=r$；不妨设 $\\varphi(N)=k\\cdot r+t$，其中 $0\\leqslant t &lt; r$。$\\hskip 3em$ 因为 $\\displaystyle X^r\\equiv 1\\hskip -1em\\mod N$，所以，$\\displaystyle X^t\\equiv X^{k\\cdot r+t}\\equiv X^{\\varphi(N)}\\equiv 1\\hskip -1em\\mod N$；$\\hskip 3em$ 由于，$\\displaystyle \\delta_N(X)=r$；所以，必有 $t=0$。$\\hskip 3em$ 故 $r \\mid \\varphi(N)$。$\\hskip 1em$【证毕】 算法原理据说只要枚举 $X$ 是否 $N$ 的原根即可 = =通过【性质 1】，我们可以简单地通过检查所有的 $n\\mid \\varphi(N), n\\neq \\varphi(N)$，是否都有 $\\displaystyle X^n\\not\\equiv 1\\hskip -1em\\mod N$ 来判断 $X$ 是否为模 $N$ 的一个原根。进一步地，如果 $\\varphi(N)=p_1^{k_1}p_2^{k_2}\\cdots p_s^{k_s}$，我们仅需检查 $\\displaystyle n=\\frac{\\varphi(N)}{p_i},1\\leqslant i\\leqslant s$ 就够了。原因很简单，如果 $\\forall i$ 满足 $1\\leqslant i\\leqslant s$ 都有 $0\\leqslant a_i\\leqslant k_i$ 成立，且 $\\exists j$ 满足 $1\\leqslant j\\leqslant s$ 使得 $0\\leqslant a_j &lt; k_j$ 成立；必有 $\\displaystyle p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s} \\mid \\frac{\\varphi(N)}{p_j}$ 成立。所以，若 $\\displaystyle X^{p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}}\\equiv 1\\hskip -1em\\mod N$，那么 $\\displaystyle X^{\\frac{\\varphi(N)}{p_j}}\\equiv 1\\hskip -1em\\mod N$ 也会成立。 程序实现123456789101112131415161718192021222324252627void GetFac(int N, vector&lt;int&gt;&amp; fac) &#123; int sm = ceil(sqrt(1.0*N)); for(int i=2; i &lt;= sm; ++i) &#123; if( N%i == 0 ) &#123; fac.push_back(i); while( N%i == 0 ) N/=i; &#125; &#125; if( N &gt; 1 ) fac.push_back(N);&#125;int GetRoot(int N) &#123; vector&lt;int&gt; fac; int phin = phi(N); // phi(N) 返回 N 的欧拉函数值，实现略 GetFac(phin, fac); for(int i=0; i &lt; fac.size(); ++i) fac[i] = phin/fac[i]; for(int g=2; ; ++g) &#123; bool flag = true; for(int i=0; i &lt; fac.size(); ++i) if( ModPower(g, fac[i], N) == 1 ) &#123; // ModPower 返回 g^&#123;fac[i]&#125;%N，实现略 flag = false; break; &#125; if( flag ) return g; &#125; &#125; 哪些数有原根【定理】 $N$ 有原根的充要条件是 $N=2,4,p^k,2\\times p^k$。其中， $p$ 为素数。","tags":[{"name":"数论","slug":"数论","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原根","slug":"原根","permalink":"http://littleclown.github.io/tags/%E5%8E%9F%E6%A0%B9/"}]},{"title":"数论基础之欧拉函数","date":"2016-05-10T04:21:01.000Z","path":"study/math/number-theory/modular-arithmetic/Euler/","text":"今天学习一些欧拉函数的性质，以及重要的数论欧拉定理，当 $a$ 和 $N$ 互质时，有：$$ a^{\\phi(N)} \\equiv 1\\hskip -.6em \\mod N$$以及今天主要讨论的广义欧拉定理，当 $a$ 和 $N$ 不互质时，有：$$a^b \\equiv\\left\\lbrace\\begin{aligned} &amp;a^b \\hskip -.6em\\mod N, &amp; 0\\leqslant b &lt; \\varphi(N) \\ &amp;a^{\\big(b\\hskip -.6em\\mod \\varphi(N)\\big) + \\varphi(N)} \\hskip -.6em \\mod N, &amp;b \\geqslant \\varphi(N)\\end{aligned}\\right.$$ 欧拉函数 $\\varphi$$\\varphi(N)$ 等于 $1,2,\\cdots,N-1$ 中与 $N$ 互质的数的个数。 欧拉函数的一些性质【性质 1】 若 $\\displaystyle N=p_1^{k_1}p_2^{k_2}\\cdots p_s^{k_s}$，则 $\\displaystyle \\varphi(N)=N\\cdot\\left(1-\\frac{1}{p_1}\\right)\\cdot\\left(1-\\frac{1}{p_2}\\right)\\cdots\\left(1-\\frac{1}{p_s}\\right)$$\\hskip 2em$ 证明见 模方程基础之筛法【性质 2】 若 $X$ 和 $Y$ 是互质的两个正整数，则：$\\displaystyle\\varphi(X\\cdot Y)=\\varphi(X)\\cdot \\varphi(Y)$。 同余类与剩余系如果 $a \\equiv b\\hskip -.6em \\mod N$，则成 $a, b$ 模 $N$ 同余。特别地，$\\big\\lbrace a-kN, a-kN+N, \\cdots, a, a+N, \\cdots, a+kN \\big\\rbrace$ 构成一个模 $N$ 的同余类。如果 $\\big\\lbrace a_1, a_2, \\cdots, a_N\\big\\rbrace$ 两两模 $N$ 不同余，则称其为模 $N$ 的一组完全剩余系。如果 $\\big\\lbrace a_1, a_2, \\cdots, a_{\\varphi(N)}\\big\\rbrace$ 两两模 $N$ 不同余且均和 $N$ 互质，则称其为模 $N$ 的一组既约剩余系。 【定理 1】如果 $\\gcd(\\lambda,N)=1$ 且 $\\big\\lbrace a_1, a_2, \\cdots, a_{\\varphi(N)}\\big\\rbrace$ 是一组模 $N$ 的既约剩余系，$\\hskip 3em$ 则 $\\big\\lbrace \\lambda\\cdot a_1, \\lambda\\cdot a_2, \\cdots, \\lambda\\cdot a_{\\varphi(N)}\\big\\rbrace$ 也是一组模 $N$ 的既约剩余系。$\\hskip 1em$ 【证】$\\hskip 3em$ 因为 $\\gcd(\\lambda,N)=1$，且由 $\\big\\lbrace a_1, a_2, \\cdots, a_{\\varphi(N)}\\big\\rbrace$ 构成模 $N$ 的既约剩余系，有：$\\gcd(a_i, N)=1$。$\\hskip 3em$ 进而有， $\\gcd(\\lambda\\cdot a_i, N)=1$。$\\hskip 3em$ 若 $\\lambda\\cdot a_i \\equiv \\lambda\\cdot a_j\\hskip -.6em \\mod N$，则 $\\lambda\\cdot(a_i -a_j) \\equiv 0 \\hskip -.6em \\mod N$，$\\hskip 3em$ 即 $\\lambda \\equiv 0\\hskip -.6em \\mod N$ 或 $(a_i-a_j) \\equiv 0\\hskip -.6em \\mod N$。但这显然是不可能的。$\\hskip 3em$ 故有，$\\lambda\\cdot a_1, \\lambda\\cdot a_2, \\cdots, \\lambda\\cdot a_{\\varphi(N)}$ 两两模 $N$ 不同余。$\\hskip 3em$ 这就证明了 $\\big\\lbrace \\lambda\\cdot a_1, \\lambda\\cdot a_2, \\cdots, \\lambda\\cdot a_{\\varphi(N)}\\big\\rbrace$ 也是一组模 $N$ 的既约剩余系。$\\hskip 1em$ 【证毕】 数论欧拉定理如果 $\\gcd(\\lambda, N)=1$，那么 $\\lambda^{\\varphi(N)}\\equiv 1 \\hskip -.6em\\mod N$。这个定理被称为数论欧拉定理（因为欧拉在很多领域有欧拉定理= =，所以加前缀以区分）。 在证明数论欧拉定理之前，先看这个定理。【定理 2】如果 $\\displaystyle ca \\equiv cb\\hskip -1em\\mod N$，那么有 $\\displaystyle a\\equiv b\\hskip -1em\\mod\\frac{N}{\\gcd(c,N)}$。$\\hskip 1em$ 【证】$\\hskip 3em$ 因为 $\\displaystyle ca \\equiv cb\\hskip -1em\\mod N$，所以有 $\\displaystyle N\\mid c\\cdot(a-b)$，$\\hskip 3em$ 又因为 $\\displaystyle \\gcd\\left(\\frac{N}{\\gcd(c,N)},\\frac{c}{\\gcd(c,N)}\\right)=1$，所以必有 $\\displaystyle \\frac{N}{\\gcd(c,N)} \\big|~ a-b$。$\\hskip 3em$ 所以，$\\displaystyle a\\equiv b\\hskip -1em\\mod\\frac{N}{\\gcd(c,N)}$$\\hskip 1em$ 【证毕】 【欧拉定理】$\\hskip 1em$【证】$\\hskip 3em$ 如果 $\\big\\lbrace a_1, a_2, \\cdots, a_{\\varphi(N)}\\big\\rbrace$ 是一组模 $N$ 的既约剩余系，$\\hskip 3em$ 由【定理 1】 可知，$\\big\\lbrace \\lambda\\cdot a_1, \\lambda\\cdot a_2, \\cdots, \\lambda\\cdot a_{\\varphi(N)}\\big\\rbrace$ 也是一组模 $N$ 的既约剩余系。$\\hskip 3em$ 所以，$\\quad \\displaystyle \\prod_{i=1}^{\\varphi(N)} (a_i \\hskip -1em\\mod N) \\equiv \\prod_{i=1}^{\\varphi(N)} (\\lambda\\cdot a_i \\hskip -1em\\mod N)$$\\hskip 3em$ 即， $\\quad \\displaystyle \\prod_{i=1}^{\\varphi(N)} (a_i \\hskip -1em\\mod N) \\equiv \\lambda^{\\varphi(N)}\\prod_{i=1}^{\\varphi(N)} (a_i \\hskip -1em\\mod N)$$\\hskip 3em$ 又因为，$\\quad \\displaystyle \\gcd\\left(\\prod_{i=1}^{\\varphi(N)} (a_i\\hskip -1em\\mod N), N\\right)=1$ 且 $\\gcd(\\lambda^{\\varphi(N)},N)=1$$\\hskip 3em$ 所以由【定理 2】，$\\quad \\displaystyle \\lambda^{\\varphi(N)} \\equiv 1\\hskip -1em\\mod N$$\\hskip 1em$【证毕】 如果 $p$ 是一个素数，那么有 $\\varphi(p)=p-1$，且： 如果 $\\gcd(\\lambda, p)=1$，由欧拉定理，有：$\\displaystyle \\lambda^p=\\lambda^{\\varphi(p)+1}\\equiv 1\\cdot \\lambda\\hskip -1em\\mod p\\equiv \\lambda\\hskip -1em\\mod p$。 如果 $\\gcd(\\lambda, p)\\neq 1$，因为 $p$ 是一个素数，则必有 $\\displaystyle\\gcd(\\lambda, p)=p$，所以：$\\displaystyle \\lambda^p\\equiv 0\\hskip -1em\\mod p\\equiv \\lambda\\hskip -1em\\mod p$。 综上，对于任意整数 $\\lambda$ 都有 $\\displaystyle \\lambda^p\\equiv \\lambda\\hskip -1em\\mod p$。这就是著名的费马小定理。 广义欧拉定理如果 $\\gcd(\\lambda, N)\\neq 1$ 呢？ 首先，由于 $\\displaystyle \\lambda^i\\hskip -1em\\mod N\\in[0,N-1]$，由鸽巢原理可知，必存在 $i(0\\leqslant i\\leqslant N-1)$ 使得 $\\displaystyle \\lambda^N\\equiv \\lambda^i\\hskip -1em\\mod N$。可能你会想，那岂不是 $\\displaystyle \\lambda^{N-i}\\equiv 1\\hskip -1em\\mod N$？但事实并不是这样的，这样想的读者忽略了 $\\gcd(\\lambda, N)\\neq 1$ 。由于 $\\displaystyle N \\big|~ \\lambda^i\\cdot \\left(\\lambda^{N-i}-1 \\right)$，不难有：$\\displaystyle \\frac{N}{\\gcd(N,\\lambda^i)}\\big|~\\left(\\lambda^{N-i}-1\\right)$，所以只能得出 $\\displaystyle \\lambda^{N-i}\\equiv 1\\hskip -1em\\mod \\frac{N}{\\gcd(N,\\lambda^i)}$。 事实上，由扩展欧几里得定理可知，方程 $\\lambda\\cdot x+N\\cdot y=1\\neq \\gcd(\\lambda,N)$ 无解，那么就不存在 $\\lambda$ 在模 $N$ 意义下的逆元。进而推知，不存在整数 $b$ 使得 $\\displaystyle \\lambda^{b+1}\\equiv 1\\hskip -1em\\mod N$，因为如果存在，那 $\\lambda^b$ 就是 $\\lambda$ 模 $N$ 意义下的逆元了，与前面的结论矛盾。 尽管如此，由鸽巢原理的分析，我们知道存在一个最小的 $L$ 和一个足够大的整数 $\\delta$，使得当 $x\\geqslant \\delta$ 时，有：$$\\lambda^{L+x}\\equiv\\lambda^x\\hskip -1em\\mod N$$接下来，我们将证明当 $N=p_1^{k_1}p_2^{k_2}\\cdots p_{s}^{k_s}$ 时，有：$\\delta=\\max\\lbrace k_i\\rbrace,(1\\leqslant i\\leqslant s)$，以及 $L \\mid \\varphi(N)$。 不妨假设 $N=p^k\\cdot X$，其中，$k \\geqslant 1$ 且 $\\gcd(p^k, X)=1$。【定理 3】 $\\displaystyle \\varphi(X) \\mid \\varphi(N)$$\\hskip 1em$ 【证】$\\hskip 3em$ 因为 $\\gcd(p^k,X)=1$，由【性质 2】可知：$\\varphi(N)=\\varphi(X)\\cdot\\varphi(p^k)$。$\\hskip 3em$ 所以，$\\varphi(X) \\mid \\varphi(N)$$\\hskip 1em$ 【证毕】 【定理 4】 $\\displaystyle p^{\\varphi(N)+k} \\equiv p^k\\hskip -1em\\mod N$$\\hskip 1em$ 【证】$\\hskip 3em$ 由于 $\\gcd(p,X)=1$，根据欧拉定理，有 $\\displaystyle p^{\\varphi(X)}\\equiv 1\\hskip -1em\\mod X$$\\hskip 3em$ 所以，存在一个整数 $t$ 使得 $\\displaystyle p^{\\varphi(X)}=tX+1$$\\hskip 3em$ 于是， $\\displaystyle p^k\\cdot p^{\\varphi(X)}=tX\\cdot p^k+p^k$， 即 $\\displaystyle p^{\\varphi(X)+k}=tN+p^k\\equiv p^k\\hskip -1em\\mod N$$\\hskip 3em$ 不难得出：对于任意整数 $s$ 都满足 $\\displaystyle p^{s\\cdot\\varphi(X)+k} \\equiv p^k\\hskip -1em\\mod N$$\\hskip 3em$ 又由【定理 3】可知，当 $\\displaystyle s=\\frac{\\varphi(N)}{\\varphi(X)}$ 时，有：$\\displaystyle p^{\\varphi(N)+k}\\equiv p^k\\hskip -1em\\mod N$$\\hskip 1em$ 【证毕】 【推论】对于任意非零整数 $s$，都有 $\\displaystyle (p^s)^{\\varphi(N)+k} \\equiv (p^s)^k\\hskip -1em\\mod N$$\\hskip 1em$ 【证】$\\hskip 3em$ 由【定理 4】可知， $\\displaystyle (p^s)^{\\varphi(N)+k}=p^{s\\cdot\\varphi(N)+s\\cdot k}\\equiv p^{s\\cdot k}\\hskip -1em\\mod N\\equiv (p^s)^k\\hskip -1em\\mod N$$\\hskip 1em$ 【证毕】 【定理 5】 若 $c=a\\cdot b$ 满足 $\\displaystyle a^{L+x}\\equiv a^x\\hskip -1em\\mod N$ 且 $\\displaystyle b^{L+x}\\equiv b^x\\hskip -1em\\mod N$；那么，$\\displaystyle c^{L+x}\\equiv c^x\\hskip -1em\\mod N$$\\hskip 1em$ 【证】$\\hskip 3em$ $\\displaystyle c^{L+x}=a^{L+x}\\cdot b^{L+x}\\equiv a^x\\cdot b^x\\hskip -1em\\mod N\\equiv c^x\\hskip -1em\\mod N$$\\hskip 1em$ 【证毕】 【定理 6】 若 $N=p_1^{k_1}p_2^{k_2}\\cdots p_s^{k_s}$，对于任意整数 $r$ 满足 $r\\geqslant \\max\\lbrace k_i \\rbrace,(1\\leqslant i\\leqslant s)$$\\hskip 3em$ 若 $\\gcd(\\lambda,N)\\neq 1$， 则 $\\displaystyle \\lambda^{r+\\varphi(N)}\\equiv \\lambda^r\\hskip -1em\\mod N$ 成立。$\\hskip 1em$ 【证】$\\hskip 3em$ 将 $\\lambda$ 唯一分解定理得，$\\displaystyle \\lambda=q_1^{a_1}\\cdot q_2^{a_2}\\cdots q_t^{a_t}$$\\hskip 3em$ 若 $\\gcd(q_j,N)=1$，由【欧拉定理】知 $\\displaystyle q_j^{\\varphi(N)} \\equiv 1\\hskip -1em\\mod N$$\\hskip 5em$ 所以，对于任意整数 $r$ 有： $\\displaystyle q_j^{\\varphi(N)+r}\\equiv q_j^r\\hskip -1em\\mod N$$\\hskip 3em$ 若 $\\gcd(q_j,N)\\neq 1$，不妨设 $q_j=p_i$，$\\hskip 5em$ 由【定理 4】可知，当 $r \\geqslant k_i$ 时，$\\displaystyle q_j^{\\varphi(N)+r}\\equiv q_j^r\\hskip -1em\\mod N$ 成立$\\hskip 3em$$\\hskip 3em$ 综上，不难发现，当 $r \\geqslant \\max\\lbrace k_i \\rbrace$ 时，$\\displaystyle q_j^{\\varphi(N)+r}\\equiv q^r\\hskip -1em\\mod N$ 对任意 $1\\leqslant j\\leqslant t$ 都成立。$\\hskip 3em$ 结合【定理 4】的【推论】有： $\\displaystyle (q_j^{a_j})^{\\varphi(N)+r}\\equiv (q_j^{a_j})^r\\hskip -1em\\mod N$ 对任意 $1\\leqslant j\\leqslant t$ 都成立。$\\hskip 3em$ 结合【定理 5】知，当 $r \\geqslant \\max\\lbrace a_i \\rbrace$ 时，$\\displaystyle \\lambda^{\\varphi(N)+r}=(q_1^{a_1}\\cdot q_2^{a_2}\\cdots q_t^{a_t})^{\\varphi(N)+r}\\equiv\\lambda^r\\hskip -1em\\mod N$$\\hskip 1em$ 【证毕】 【广义欧拉定理】 若 $N=p_1^{k_1}p_2^{k_2}\\cdots p_s^{k_s}$，则无论 $a$ 和 $N$ 互质与否，当 $b \\geqslant \\phi(N)$ 时，都有：$$a^b \\equiv a^{\\big(b\\hskip -.6em\\mod \\varphi(N)\\big) + \\varphi(N)} \\hskip -.6em \\mod N$$$\\hskip 1em$ 【证】$\\hskip 3em$ 当 $a$ 和 $N$ 互质时，根据【欧拉定理】，结论显然成立。$\\hskip 3em$ 当 $a$ 和 $N$ 不互质时，由于 $\\varphi(N)\\geqslant p_i^{k_i-1}\\geqslant k_i,(1\\leqslant i\\leqslant s)$，$\\hskip 3em$ 即 $\\varphi(N) \\geqslant \\max\\lbrace k_i\\rbrace$，结合【定理 6】可知结论成立。$\\hskip 1em$ 【证毕】 练习 problems categories solution FJU/Super A^B mod C 广义欧拉定理 Code Hint鉴于本人能力有限，有误之处还望指证。","tags":[{"name":"数论","slug":"数论","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://littleclown.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"既约剩余系","slug":"既约剩余系","permalink":"http://littleclown.github.io/tags/%E6%97%A2%E7%BA%A6%E5%89%A9%E4%BD%99%E7%B3%BB/"}]},{"title":"数论基础之筛法","date":"2016-05-06T06:26:36.000Z","path":"study/math/number-theory/modular-arithmetic/prime/","text":"筛素数的算法朴素筛法朴素的筛素数算法的流程是这样的： $i$ 没有被标记，$i$ 是素数；用 $i$ 去标记所有的 $i,2i,\\cdots,\\left\\lfloor \\frac{N}{i} \\right\\rfloor \\times i$ $i$ 被标记，$i$ 不是素数 这个算法的复杂度好像是 $O(N\\log N)$ 的，其中，$N$ 为要筛的数的个数。一个简单的优化技巧是：如果 $i$ 是素数，则用 $i$ 去标记所有的 $i^2,(i+1)\\times i,\\cdots,\\left\\lfloor \\frac{N}{i} \\right\\rfloor \\times i$。 优化之后的复杂度好像是 $O\\big(N\\log (\\log N)\\big)$ 的。之所以强调好像是，是因为这两个复杂度都是道听途说的，未能严谨证明。但是，显然它们都不会是线性的。比如 $12$，会被 $2,3$ 各标记一次。 线性筛对于任意一个大于 1 的整数 $X$，可以将其写为 $X=e\\cdot X’$。其中，$e$ 是 $X$ 的最小正素因子。特别地，如果 $X$ 是一个素数，有 $X=e$。那么，如果能让每一个正整数 $X$ 仅被其最小正素因子标记，就可以保证筛法的复杂度是线性的了。 先看怎么实现，再解释为什么是线性的。 程序实现线性筛 1234567891011121314151617typedef long long LL;bool isprime[MAXN];int prime[MAXN], tot; // 一般来说，素数个数在 MAXN/10 ～ MAXN/15 左右 void GetPrime() &#123; memset(isprime, 1, sizeof isprime); // 需要头文件 cstring tot = 0; for(int x=2; x &lt; MAXN; ++x) &#123; if( isprime[x] ) prime[tot++] = x; for(int i=0; i &lt; tot; ++i) &#123; if( (LL) prime[i]*x &gt;= MAXN ) break; // 注意乘法溢出 isprime[prime[i]*x] = false; if( x % prime[i] == 0 ) break; // 保证每个数仅被其最小正素因子标记 &#125; &#125;&#125; 先考虑上述筛法的正确性。 如果 $X$ 是一个合数，令 $X=e\\cdot X’$，其中 $e$ 为 $X$ 的最小正素因子。首先，$e &lt;= X’$，所以当 $x=X’$ 时，$e$ 已经在 prime 中了。其次，不存在一个正素数 $e’ &lt; e$ 满足 $e’ \\mid X’$；因为如果存在这样的 $e’$，则 $X=e’\\cdot\\frac{X’}{e’}\\cdot e$，与 $e$ 是 $X$ 的最小素因子矛盾。 也就说，如果 $X$ 是一个合数，那么必会执行（我们已经排除了所有跳过的可能） $ isprime[e*X’] = false$ ，所以这个筛法可以无疑漏的标记所有的合数。又因为 $prime[i]*x$ 是一个合数，所以这个筛法不会标记素数。据此，证明了该筛法的正确性。 再考虑上述筛法的效率。 如果 $X=e^k$，那么显然不用担心它被多个不同的素数筛过。 如果 $X=e_1*e_2*X’$，其中 $e_1 &lt; e_2$； 令 $x_2=\\frac{X}{e_2}$，显然，$e_1 \\mid x_2$，对应程序中，即会触发第 13 行操作： 1if( x2 % e1 == 0 ) break; 而 $e_2 &gt; e_1$，也就是说， $x_2$ 在遇见 $e_1$ 时就会结束内层循环，不会遇见 $e_2$， 所以保证了 $X$ 至多仅被 $e_1$ 筛一次。 综上，此筛法是 $O(N)$ 的。 欧拉函数的筛法欧拉函数欧拉函数 $\\varphi(X)$ 表示 $1,2,\\cdots,X-1$ 中与 $X$ 互质的数的个数。 定义函数： $\\hskip 2em f(x,y) = \\left\\lbrace \\begin{aligned} &amp;1, &amp;\\gcd(x,y)=1 \\ &amp;0, &amp;\\gcd(x,y) \\neq 1\\end{aligned} \\right.$对于正整数 $X$，那么，$$\\varphi(X)=\\sum_{i=1}^{X-1} f(X,i). \\tag{1}$$更一般地，将 $X$ 唯一分解，得：$X=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_s^{k_s}$。那么，$$\\varphi(X)=X\\cdot \\left(1-\\frac{1}{p_1}\\right) \\cdot \\left(1-\\frac{1}{p_2}\\right) \\cdots \\left(1-\\frac{1}{p_s}\\right). \\tag{2}$$ 下面利用容斥原理简单证明一下 **方程(2)**：【证明】$\\hskip 2em$ 将 $X$ 唯一分解，得：$X=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_s^{k_s}$。$\\hskip 2em$ 令 $A_i$ 为比 $X$ 小且被 $p_i$ 整除的正整数集合。\\begin{align} \\varphi(X) &amp;= X-\\sum_{i=1}^s \\big|A_i\\big|+\\sum_{i=1}^s \\sum_{j &gt; i} \\big|A_i \\bigcap A_j\\big|-\\sum_{i=1}^s\\sum_{j &gt; i}\\sum_{k &gt; j} \\big| A_i \\bigcap A_j \\bigcap A_k \\big|+\\cdots \\ &amp;~~~ +(-1)^{s}\\big|A_1\\bigcap A_2\\bigcap \\cdots \\bigcap A_s \\big| \\ &amp;= X-\\sum_{i=1}^s \\frac{X}{p_1}+\\sum_{i=1}^s\\sum_{j &gt; i} \\frac{X}{p_ip_j}-\\sum_{i=1}^s\\sum_{j &gt; i}\\sum_{k &gt; j} \\frac{X}{p_ip_jp_k}+\\cdots+(-1)^s\\frac{X}{p_1p_2\\cdots p_s} \\ &amp;= X\\cdot \\left(1-\\frac{1}{p_1}\\right) \\cdot \\left(1-\\frac{1}{p_2}\\right) \\cdots \\left(1-\\frac{1}{p_s}\\right)\\end{align}【证毕】 朴素筛法方程(2) 虽然给出了欧拉函数的一个简单计算方法，但是，注意到质因数分解的复杂度是 $O(\\sqrt{N})$ 的，如果多次这样计算代价太大。考虑筛除所有的素数，并用每个素数更新 $\\varphi(X)$ 的值。 程序实现朴素筛 123456789101112typedef long long LL;int phi[N];void GetPhi() &#123; memset(phi, 0, sizeof phi); phi[1] = 1; for(int i=2; i &lt; N; ++i) if( !phi[i] ) &#123; for(int j=i; j &lt; N; j += i) &#123; if( !phi[j] ) phi[j] = j; phi[j] = phi[i] / i * (i-1); // 先除后乘防止溢出 &#125; &#125;&#125; 这个程序可以生成 $X \\in [1,N)$ 的欧拉函数表，且时间复杂度与朴素筛素数方法同阶，据说是 $O(N\\log(N))$ 的。 线性筛基于素数线性筛的思想，不妨设 $X=e\\cdot X’$，其中，$e$ 为 $X$ 的最小素因子。 当 $e \\mid X’$ 时，由上述计算公式可知，$\\varphi(X) = \\varphi(X’) \\cdot (\\frac{X}{X’})=\\varphi(X’)\\cdot e$； 当 $e \\nmid X’$ 时，由上述计算公式可知，$\\varphi(X) = \\varphi(X’) \\cdot (\\frac{X}{X’}) \\cdot (1-\\frac{1}{e}) = \\varphi(X’)\\cdot (e-1)$ 所以：$$ \\varphi(X) = \\left\\lbrace \\begin{aligned} &amp;\\varphi(X’) \\cdot e, &amp;e \\mid X’ \\ &amp;\\varphi(X’) \\cdot (e-1), &amp;e \\nmid X’ \\end{aligned} \\right.$$不难发现，该筛法与素数线性筛同阶，因此也是线性的。 程序实现线性筛 12345678910111213141516171819202122typedef long long LL;int phi[N], prime[N], tot;void GetPhi() &#123; memset(phi, 0, sizeof phi); phi[1] = 1; tot = 0; for(int i=2; i &lt; N; ++i) &#123; if( !phi[i] ) &#123; phi[i] = i-1; prime[tot++] = i; &#125; for(int j=0; j &lt; tot; ++j) &#123; LL ret = (LL) prime[j]*i; if( ret &gt;= N ) break; if( i%prime[j] == 0 ) &#123; phi[ret] = phi[i]*prime[j]; // 对应 e 整除 X&#x27; 的情况 break; &#125; phi[ret] = phi[i]*(prime[j]-1); // 对应 e 不整除 X&#x27; 的情况 &#125; &#125;&#125; 练习 problems categories solution UVa/GCD Extreme(II) 欧拉函数 Code","tags":[{"name":"数论","slug":"数论","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://littleclown.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"素数线性筛","slug":"素数线性筛","permalink":"http://littleclown.github.io/tags/%E7%B4%A0%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B/"}]},{"title":"数论基础之模方程基础","date":"2016-05-04T09:13:58.000Z","path":"study/math/number-theory/modular-arithmetic/CRT/","text":"*** 离线文档*** 扩展欧几里得算法问题描述已知 $a,b$ 为常整数，求方程 $ax+by=\\gcd(a,b)$ 的一对整数解? 问题简析令 $\\displaystyle\\left\\lbrace\\begin{aligned} &amp;A=a(\\hskip -1em \\mod b) \\ &amp;B=b\\end{aligned}\\right.$，构造方程 $$AX+BY=\\gcd(A,B). \\hskip 5em (1)$$ 由于，$\\gcd(a,b)=\\gcd\\big(a(\\hskip -.7em \\mod b),b\\big)=\\gcd(A,B)$，\\begin{align} \\text{又， } ax+by &amp;=\\left(a-\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times b+\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times b\\right)\\times x+by \\ &amp;=\\left(a-\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times b\\right)\\times x+\\left(by +\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times bx\\right) \\ &amp;=\\big(a (\\hskip -1em \\mod b)\\big)\\times x+b\\times\\left(y+\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times x\\right)\\end{align} 所以，$\\quad \\displaystyle\\left\\lbrace\\begin{aligned} &amp;X=x \\ &amp;Y=y+\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times x\\end{aligned} \\right.\\hskip 1em \\Rightarrow \\hskip 1em\\left\\lbrace\\begin{aligned} &amp;x=X \\ &amp;y=Y- \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\times X\\end{aligned}\\right.$ 方程 (1) 的构造与辗转相除有异曲同工之妙，需要说明的是， $\\gcd(x,0)=x$。所以： 当 $b=0$ 时，我们得到一组解 $\\displaystyle\\left\\lbrace\\begin{aligned}&amp;x=1 \\&amp;y=0\\end{aligned}\\right.$; 当 $b\\neq 0$ 时，套用辗转相除的框架求出 $(X,Y)$，再得到 $(x,y)$。 程序实现12345typedef long long LL;void Extend_Euclid(LL a, LL&amp; x, LL b, LL &amp;y, LL&amp; d) &#123; // d=gcd(a,b) if( !b ) &#123; d=a; x=1; y=0; &#125; else &#123; Extend_Euclid(b, y, a%b, x, d); y -= (a/b)*x; &#125;&#125; 值得一提的是，扩展欧几里得算法解出的一组解是所有解中 $|x|+|y|$ 最小的；另外，$\\gcd(a,b)$ 可以一起求。 代码中，将 d=a 的执行顺序放在第一位是一个小技巧，因为这样就可以像这样调用函数： 123Extend_Euclid(a, x, b, d, d);// 或者Extend_Euclid(a, d, b, d, y); 问题扩展求方程 $ax+by+c=0$ 有多少对整数解，满足 $x \\in [x_1,x_2],~y \\in [y_1,y_2]$？ 由前文可知，当 $\\gcd(a,b) \\mid c$ 时，方程有解。因为方程 $ax+by=\\gcd(a,b)$ 的解乘上 $\\frac{c}{\\gcd(a,b)}$ 就是此方程的一组解。由此，我们可以推出 $ax+by=k{\\bf\\cdot}\\gcd(a,b)$，所以，当 $\\displaystyle \\gcd(a,b) \\nmid c$ 时，方程无解。 那有多少个解呢？如果 $(x_0,y_0)$,$(x_1,y_1)$ 是方程的两个解，那么 $a(x_1-x_0)+b(y_1-y_0) \\equiv 0$。令 $\\displaystyle a’=\\frac{a}{\\gcd(a,b)},b’=\\frac{b}{\\gcd(a,b)}$，显然，$\\gcd(a’,b’)=1$。所以，$(x_1-x_0) \\mid b’,(y_0-y_1) \\mid a’$，并且 $\\displaystyle \\frac{x_1-x_0}{b’} \\equiv \\frac{y_0-y_1}{a’}$。 一般地，若 $(x_0,y_0)$ 是方程 $ax+by+c=0$ 一组解，那么 $(x_0+kb’,y_0-ka’)$ 也是一组解。其中，$\\displaystyle b’=\\frac{b}{\\gcd(a,b)},~a’=\\frac{a}{\\gcd(a,b)}$，$k$ 为任意整数。 剩下的问题就很简单了，不再赘述。 逆元问题描述对于任意整数 $A,~N$，如果存在一个整数 $B$ 使得 $A{\\bf\\cdot}B \\equiv 1(\\hskip -.5em \\mod C)$，那么，$A$ 和 $B$ 称作模 $C$ 意义下的互为逆元，记做 $A^{-1}=B$ 或 $B^{-1}=A$。 问题简析 如果 $\\gcd(A,N)=1$，根据欧拉定理，有 $A^{-1} = N^{\\varphi(N)-1}$，特别地，当 $N$ 是素数时，$\\varphi(N)=N-1$。另外，由于 $\\gcd(A,N)=1$，构造方程 $Ax+Ny=1$，用扩展欧几里得算法也可求出 $A$ 在模 $N$ 意义下的逆元 $A^{-1}=x$。 如果 $\\gcd(A,N)\\neq 1$，由前文可知，方程 $Ax+Ny=1 \\neq k\\cdot\\gcd(A,N)$ 不存在整数解，故不存在逆元。 程序实现 欧拉定理求逆元，当 $N$ 是素数时，$\\phi(N)=N-1$，$A$ 的逆元为 $A^{N-2}$1234567891011typedef long long LL;LL ModPower(LL A, LL x, LL mod) &#123; // 返回 A^x%mod LL ans = 1; for(; x &gt; 0; x &gt;&gt;=1, A=A*A%mod) if( x&amp;1 ) ans = ans*A%mod; return ans;&#125;LL INV(LL A, LL mod) &#123; return ModPower(A, mod-2, mod); &#125; 扩展欧几里得求逆元1234567typedef long long LL;LL INV(LL A, LL mod) &#123; LL x, y, d; Extend_Euclid(A, x, N, y, d); if( d != 1 ) return -1; // 若 A 和 mod 不互质，则不存在逆元 return x;&#125; 中国剩余定理问题描述若正整数 $m_1,m_2,\\cdots,m_k$ 两两互素，$0 \\leqslant a_1 &lt; m_1, 0 \\leqslant a_2 &lt; m_2,\\cdots, 0 \\leqslant a_k &lt; m_k$。求整数 $x$ 满足同余方程组：\\begin{align} \\begin{aligned} &amp;x \\equiv a_1(\\hskip -1em \\mod m_1) \\ &amp;x \\equiv a_2(\\hskip -1em \\mod m_2) \\ &amp;\\hskip 2.5em \\cdots \\ &amp;x \\equiv a_k(\\hskip -1em \\mod m_k) \\end{aligned} \\tag{2}\\end{align} 问题简析令 $\\displaystyle w_i=\\prod_{j \\neq i} m_j$，显然：\\begin{align} \\gcd(w_i,m_j) = \\left\\lbrace \\begin{aligned} &amp;1, &amp;i = j \\ &amp;m_j, &amp;i \\neq j \\end{aligned} \\right. \\tag{3}\\end{align}构造方程 $w_i x_i+m_i y_i=\\gcd(w_i,m_i)=1$。那么，由方程组 (3) 有，\\begin{align} w_i x_i ~(\\hskip -1em \\mod m_j) \\equiv \\left\\lbrace \\begin{aligned} &amp;1, &amp;i=j \\ &amp;0, &amp;i\\neq j \\end{aligned} \\right. \\tag{4}\\end{align}结合方程组 (2) 和方程组 (4)，进而有，\\begin{align} a_i w_i x_i ~(\\hskip -1em \\mod m_j) \\equiv \\left\\lbrace \\begin{aligned} &amp;a_i, &amp;i=j \\ &amp;0, &amp;i\\neq j \\end{aligned} \\right. \\tag{5}\\end{align}所以，$\\displaystyle x=\\sum_{i=1}^k (a_i\\cdot w_i\\cdot x_i)$ 为同余方程组 (2) 的解。更一般地，方程的解为 $\\displaystyle x=\\sum_{i=1}^k (a_i\\cdot w_i\\cdot x_i) + k\\prod_{i=1}^k m_i$。剩下的问题仅需利用扩展欧几里得算法求出 $x_i$。 程序实现12345678910LL CRT(int N, int* a, int* m) &#123; LL M = 1, ans = 0; for(int i=0; i &lt; N; ++i) M *= m[i]; for(int i=0; i &lt; N; ++i) &#123; LL w = M/m[i], x, y, d; Extend_Euclid(w, x, m[i], y, d); ans = (ans+x*w*a[i]) % M; &#125; return ans;&#125; Baby Step Gaint Step问题描述求一个整数 $x \\in [0,C-1]$ 使得 $A^x \\equiv B(\\hskip -.6em \\mod C)$；其中，$C$ 为素数。 问题简析注意到 $C$ 是一个素数，那么对于任意 $X$ 都存在一个模 $C$ 意义下的逆元 $X^{-1}$，使得 $X \\cdot X^{-1} \\equiv 1(\\hskip -.6em \\mod C)$。对于 $0 \\leqslant x_0 &lt; m$，如果事先知道了所有 $A^{x_0}(\\hskip -.6em \\mod C)$ 的值，如何判断是否存在一个 $x’$ 满足 $km \\leqslant x’=x_0+km &lt; (k+1)m$，使得 $A^{x’} \\equiv B(\\hskip -.6em \\mod C)$ 成立呢？ 注意到，令方程两边同乘以 $A^{km}$ 的逆元 $A^{-km}$，得到 $A^{x_0} \\equiv B\\cdot A^{-km} (\\hskip -.6em \\mod C)$。所以，我们仅需将 $f(x_0)=A^{x_0}(\\hskip -.6em \\mod C)$ 映射到哈希表或平衡树中，再判断哈希表或平衡树中，是否存在 $B\\cdot A^{-km} (\\hskip -.6em \\mod C)$，并且在存在时返回 $x_0$ 即可。 $m$ 等于多少呢？注意到这样做的时间复杂度（使用哈希表，查询均摊 $O(1)$），是 $\\displaystyle O\\left( m+\\frac{C}{m} \\right)$ 的，不难证明，当 $m$ 取 $\\sqrt{C}$ 时复杂度最优。 程序实现123456789101112131415161718typedef long long LL;unordered_map&lt;LL, int&gt; emp;cnt+int EBSGS(LL A, LL B, LL C) &#123; emp.clear(); LL M = ceil(sqrt(1.0*C)); LL AA = 1; for(int i=0; i &lt; M; ++i) &#123; if( !emp.count(AA) ) emp[AA] = i; AA = AA*A % C; &#125; LL Am = INV(ModPower(A, M, C), C); for(int i=0; i &lt; M; ++i) &#123; if( emp.count(B) ) return emp[B]+i*M; B = B*Am % C; &#125; return -1;&#125; Extend Baby Step Gaint Step问题描述求一个整数 $x \\in [0,C-1]$ 使得 $A^x \\equiv B(\\hskip -.6em \\mod C)$；其中，$C$ 为合数。 问题简析【定理1】$\\hskip 1em$ 若 $k\\cdot A \\equiv k\\cdot B(\\hskip -.5em \\mod k\\cdot C)$，则有，$A \\equiv B(\\hskip -.5em \\mod C)$。这个定理不难证明，事实上，仅需构造方程 $k\\cdot A - k\\cdot B=k’\\cdot k\\cdot C$，再等式两边同除以 $k$ 即可得证。 再回过头来看普通版的 Baby Step Gaint Step 是如何工作的。注意到，Gaint Step 能够成功走出去的前提是 $A^m$ 存在模 $C$ 意义下的逆元 $A^{-m}$。由前文可知，$A^{-m}$ 存在的充要条件为 $\\gcd(A^m,C)=\\gcd(A,C)=1$，也就是要满足 $A$ 和 $C$ 互质即可。 设 $A_g=\\gcd(A^{\\infty},C)$，并且 $A_g \\mid A^{t}$； 再令 $C’=\\frac{C}{A_g}$，$D=\\frac{A^t}{A_g}$。所以，$\\quad A^x=A_g\\times \\frac{A^t}{A_g}\\times A^{x-t}=A_g\\times D\\times A^{x-t},~~C=A_g\\times \\frac{C}{A_g}=A_g\\times C’$。不难发现，$D$ 和 $C’$ 是互质的，$A^{x-t}$ 和 $C’$ 也是互质的。 若 $A_g \\mid B$，结合【定理1】，有 $A^x \\equiv B(\\hskip -.5em \\mod C) \\hskip .5em \\Rightarrow \\hskip .5em D\\cdot A^{x-t} \\equiv \\frac{B}{A_g}(\\hskip -.5em \\mod C’)$。 又因为 $D$ 和 $C’$ 是互质的，所以存在模 $C’$ 意义下的逆元 $D^{-1}$；进一步将同余方程化为 $A^{x-t} \\equiv \\left(D^{-1}\\cdot \\frac{B}{A_g}\\right)(\\hskip -.5em \\mod C’)$。 由于 $A^{x-t}$ 和 $C’$ 是互质的，根据前面的分析，可知直接套用普通版的 Baby Step Gaint Step 即可解决。 若 $A_g \\nmid B$，由于 $A^x(\\hskip -.5em \\mod C)=K\\cdot A_g$，所以无解。 程序实现12345678910111213141516171819202122232425262728typedef long long LL;unordered_map&lt;LL, int&gt; emp;int EBSGS(LL A, LL B, LL C) &#123; LL G, D = 1, cnt = 0; while( (G=GCD(A, C)) != 1 ) &#123; if( B % G ) return -1; B /= G; C /= G; D = D*A/G % C; ++cnt; if( D == B ) return cnt; &#125; emp.clear(); LL M = ceil(sqrt(1.0*C)); LL AA = 1; for(int i=0; i &lt; M; ++i) &#123; if( !emp.count(AA) ) emp[AA] = i; AA = AA*A % C; &#125; B = B*INV(D, C) % C; LL Am = INV(ModPower(A, M, C), C); for(int i=0; i &lt; M; ++i) &#123; if( emp.count(B) ) return emp[B]+cnt+i*M; B = B*Am % C; &#125; return -1;&#125; 练习 题目 分类 程序实现 SPJ/MOD 扩展 BSGS Code UVa/Code Feat 中国剩余定理 Code Hint拖沓了很久，终于耐下性子整理了一下。鉴于本人能力有限，有误之处欢迎指正。 参考链接","tags":[{"name":"数论","slug":"数论","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://littleclown.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://littleclown.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"Baby Step Gaint Step","slug":"Baby-Step-Gaint-Step","permalink":"http://littleclown.github.io/tags/Baby-Step-Gaint-Step/"}]},{"title":"HDU-5576 Expection of String （原 2015-上海区域赛-E) 解题报告","date":"2016-04-24T02:20:36.000Z","path":"acm/oj/hdu/5500/5576/","text":"*** 题目链接 ****** Code *** 题意简述一个长度为 $L$ 的串 $a_0a_1\\cdots a_{r-1} * a_{r+1}a_{r+2}\\cdots a_{L-1}$ 表示算式：$A \\times B$。其中： $$ \\begin{aligned} &amp;A = \\sum_{i=0}^{r-1} \\left( a_i \\times 10^{r-i-1} \\right) \\ &amp;B = \\sum_{i=r+1}^{L-1} \\left( a_i \\times 10^{L-i-1} \\right) \\ \\end{aligned} \\ 0\\leqslant r &lt; L, \\hskip .5em 0\\leqslant a_i\\leqslant 9, \\hskip .5em 0\\leqslant i &lt; L \\text{且} i \\neq r \\$$ \\begin{align} \\text{令} \\quad f\\big(S\\big) &amp;= f\\big(a_0a_1\\cdots a_{r-1} * a_{r+1}a_{r+2}\\cdots a_{L-1}\\big) \\\\ &amp;= A\\times B = \\left\\lbrace \\begin{aligned} &amp;\\left[ \\sum_{i=0}^{r-1} \\left( a_i \\times 10^{r-i-1} \\right) \\right] \\times \\left[ \\sum_{i=r+1}^{L-1} \\left( a_i \\times 10^{L-i-1} \\right) \\right], &amp;0 &lt; r &lt; L-1 \\\\ &amp; \\\\ &amp;0, &amp;r=0 \\text{ 或 } r=L-1 \\end{aligned} \\right.\\end{align} 交换操作：从 $S$ 中任选两个字符（可以选择 ‘*’号），交换它们的位置；若 $K$ 次交换后，$f(S)$ 的期望值为 $E$；求 $\\left(E \\times \\binom{L}{2}^K \\right) \\mod (10^9+7) $。 数据范围：$1\\leqslant L, K \\leqslant 50$。 题目简析*** HDU-5576.pdf *** Hint最后一个小时一直和 ZPH 学长讨论这一道题，当时实在是太弱，以至于这样的数据范围竟然想着推数学公式。。。ORZ。。 题解是赛后一周写的，所以是 pdf 格式。Markdown 中，两侧下划线表示斜体，所以书写数学公式时下划线要用 ‘&#39; 转义。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://littleclown.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"高级","slug":"高级","permalink":"http://littleclown.github.io/tags/%E9%AB%98%E7%BA%A7/"}]},{"title":"树链剖分","date":"2016-04-23T07:48:27.000Z","path":"study/codding/algorithm/tree/TCS/","text":"算法简介树链剖分是将树上的节点映射到一段连续的区间中，使得树上任意一条路径能用不超过 $O(\\log N)~$ 段连续区间表示。这样就可以对树上的路径做一些操作了。常见的搭配是 线段树+树链剖分。 算法原理 $siz(u)$ $\\hskip 1.3em$ 以 $u$ 为根的子树的节点数 $son(u)$ $\\hskip 0.9em$ $u$ 的子节点中 $siz$ 值最大的节点 重边 $\\hskip 1.2em$ $u$ 与 $son(u)$ 的连边 轻边 $\\hskip 1.2em$ $u$ 与除 $son(u)$ 外其它子节点的连边 重链 $\\hskip 1.2em$ 由重边连成的路径 【定理1】 如果 $(u,v)$ 是一条轻边，那么 $siz(v) &lt; \\frac{siz(u)}{2}$。$\\quad$【证】$\\hskip 3em$ 因为 $(u,v)$ 是一条轻边，所以 $u$ 还有一个由重边相连的儿子 $son(u)$；$\\hskip 3em$ 若 $siz(v) \\geqslant \\frac{siz(u)}{2}$；$\\hskip 3em$ 根据定义，有 $siz \\big( son(u) \\big) \\geqslant siz(v) \\geqslant \\frac{siz(u)}{2}$。$\\hskip 3em$ 而，$siz(u) \\geqslant siz(v)+siz \\big( son(u) \\big) +1 &gt; siz(u)$，矛盾。$\\hskip 3em$ 故，$siz(v) &lt; \\frac{siz(u)}{2}$。$\\quad$【证毕】 【定理2】 任意非根节点 $u$ 到根节点的路径上，轻边+重链 总数不超过 $O(\\log_2 N)$。$\\quad$【证】$\\hskip 3em$ 不难证明，最多会遇到 $\\log_2 N$ 条轻边；$\\hskip 3em$ 因为，从根节点到 $u$ 的路径中，每遇到一条轻边，节点个数就会减半；$\\hskip 3em$ 所以轻边的数目不超过 $\\log_2 N$。$\\hskip 3em$ 而，整条路径上 $\\log_2 N$ 条轻边最多隔开 $\\log_2 N +1$ 条重链；$\\hskip 3em$ 故，轻边+重链 总数不超过 $O(\\log_2 N)$。$\\quad$【证毕】 当我们将一棵树沿着重链剖分后，将重链依次映射到一段连续的区间后，就可以将任何一条到根的链分成 $\\log N$ 段连续区间了。也就是用 $\\log N$ 条重链的覆盖这一条路径。 算法实现 $fat(u)$ $\\hskip 1.15em$ $u$ 的父亲 $son(u)$ $\\hskip 0.95em$ $u$ 的子节点中 $siz$ 值最大的节点 $dep(u)$ $\\hskip .9em$ $u$ 的深度，根节点深度为 1 $siz(u)$ $\\hskip 1.3em$ 以 $u$ 为根的子树的节点数 $pos(u)$ $\\hskip 1em$ $u$ 在连续区间的映射值 $top(u)$ $\\hskip 1.05em$ $u$ 所在重链的顶端节点 求出 $siz,dep,son,fat$ 12345678910111213int fat[MAXN], son[MAXN], dep[MAXN], siz[MAXN];void DFS(int o, int f, int d) &#123; fat[o] = f; son[o] = 0; dep[o] = d; siz[o] = 1; for(int u=from[o]; u; u=nxt[u]) &#123; int v = to[u]; if( v == f ) continue; DFS(v, o, d+1); siz[o] += siz[v]; if( siz[son[o]] &lt; siz[v] ) son[o] = v; &#125;&#125; 求出 $top, pos$， 1234567891011int top[MAXN], pos[MAXN], dfs_colok;void DFS(int u, int t) &#123; pos[u] = ++dfs_clock; top[u] = t; if( !son[u] ) return; DFS(son[u], t); // u 与 son(u) 在同一条重链上，故重链的顶端节点相同 for(int i=from[u]; i; i=nxt[i]) &#123; int v = to[i]; if( v != fat[u] &amp;&amp; v != son[u] ) DFS(v, v); // u 的其它非 son(u) 子节点为新的重链的顶端节点 &#125;&#125; 树链剖分完了！！怎么用呢？先看下图： 左图中的粗线表示重边，虚线表示轻边； 黑色数字为节点编号，紫色数字为边编号。 左图中的 `0` 节点为一虚拟节点，引进它是方便理解下文; **在实际实现中，我们令 $fat($ 根节点 $)=$ 根节点，则上图的 `0` 节点指代 `1`。** **每条边上的紫色数字表示箭头所指的节点的 $pos$ 值。** 对于树的两个节点 $u$，$v$，若它们的最近公共祖先（LCA）为 $w$；那么，如果我们想要对路径 $(u,v)$ 上的所有节点进行一个操作，只需要让 $u$,$v$ 同时沿着各自的祖先节点走，并在 $w$ 处相遇就可以了。 $top$ 是为了加速往上走的过程；但是不难发现，由于每次可能不仅走一步，如果 $u$ 和 $v$ 同时行动的话，很可能会错过 $w$ ！为了解决这个问题，可以总是让 $dep(top)$ 值大的点先走（想一想，为什么）。 $\\hskip 1em$$\\hskip 1em$ 不妨假设 $dep \\big( top(u) \\big) \\geqslant dep \\big( top(v) \\big)$ $top(u) \\neq top(v)$ $\\hskip 1em$ 得到一段连续的映射区间 $\\Big[pos \\big( top(u) \\big),pos(u)\\Big]$；并让 $u$ 走到 $fat \\big( top(u) \\big)$ $top(u) = top(v) $ $\\hskip 1em$ $u$ 和 $v$ 在同一条重链中，显然， $w=dep(u) &lt; dep(v)?u: v$；得到一段连续的映射区间 $\\Big[ pos(w),pos \\big(w==u?v:u\\big) \\Big]$ 由于每次走到 $fat(top)$，可以放心的把轻边当做 长度为0的重链 来处理。 比如，我们现在要访问 节点6 –&gt; 节点15 的路径： $u$ 走到 12，得到一段连续的映射区间 $[7,7]$ $u$ 走到 1，得到一段连续的映射区间 $[2,3]$ $v$ 走到 2，得到一段连续的映射区间 $[12,12]$ $v$ 走到 1，得到一段连续的映射区间 $[11,11]$ $top(u) = top(v)$，得到一段连续的映射区间 $[1,1]$；相遇，终止算法 所以，我们在映射区间里依次对 $\\big\\lbrace [7,7],[2,3],[12,12],[11,11],[1,1] \\big\\rbrace$ 进行操作就好了。 123456789101112void Update(int L, int R) &#123; while (top[L] != top[R]) &#123; if (dep[top[L]] &lt; dep[top[R]]) swap(L, R); // 让 dep 大的走 int l = pos[top[L]], r = pos[L]; // 得到连续映射区间 [l,r] fun(l, r); // 对 [l,r] 进行操作 L = fat[top[L]]; &#125; if (dep[L] &gt; dep[R]) swap(L, R); fun(pos[L], pos[R])&#125; Hint上文中讨论的是对 $(u,v)$ 路径上的所有节点进行操作。若信息全维护在边上，即要对 $(u,v)$ 路径上的所有边进行操作，则仅需在 $dep(u) = dep(v)$ 时，执行的区间改成 $\\Big[ pos \\big( son(u) \\big),pos(v) \\Big]$ 就行了。 *** 参考链接 ***","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://littleclown.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://littleclown.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"51nod-1462 数据结构 解题报告","date":"2016-04-23T05:24:31.000Z","path":"acm/oj/51nod/1400/1462/","text":"*** 题目链接 ****** Code *** 题意简述一棵 $N$ 个节点的树，以 1 为根。树上的每个节点有两个权值：$v_i$，$t_i$。初始时均为 0。$Q$ 次操作： 1 u d $\\hskip .6em$ 对 $u$ 到根上所有点的 $v_i \\text{+=} d$ 2 u d $\\hskip .6em$ 对 $u$ 到根上所有点的 $t_i \\text{+=} v_i \\times d$ 输出 $Q$ 次操作后所有节点的权值。 数据范围：$N,Q \\leqslant 10^5$。数据保证 64 位整数不会溢出。 题目简析先考虑在一段区间中怎么维护这两个操作。 $t_i$ 增加值是 $v_i$ 和 $d$ 的乘积。 当 $v_i$ 不发生改变，可以累加 $d$ 的值， $d’=\\sum d$； 当 $v_i$ 发生改变，$t_i \\text{+=} v_i \\times d’$，$d’=0$，$v_i \\text{+=} d$。 由于我们求的是 $Q$ 次操作后每个节点的 $t_i$ 值；维护一个类似 区间更新，单点求值 的问题即可。 操作一（$v_i$ 发生变化） 12345678910111213141516171819void Pushdown(int o, int lft, int rht) &#123; t[o] += v[o] * d[o]; if( lft &lt; rht ) &#123; d[lc] += d[o]; d[rc] += d[o]; &#125; d[o] = 0;&#125;int ul, ur, uv, uc;void Update(int o, int lft, int rht) &#123; Pushdown(o, lft, rht); if( ul &lt;= lft &amp;&amp; rht &lt;= ur ) &#123; v[o] += uv; &#125; else &#123; int mid = lft+rht &gt;&gt; 1; if( ul &lt;= mid ) Update(lc, lft, mid); if( ur &gt; mid ) Update(rc, mid+1, rht); &#125;&#125; 操作二（$v_i$ 不发生变化） 123456789101112void Update(int o, int lft, int rht, LL add) &#123; if (ul &lt;= lft &amp;&amp; rht &lt;= ur) &#123; d[o] += uv; t[o] += add; &#125; else &#123; add += uv * v[o]; int mid = lft + rht &gt;&gt; 1; if (ul &lt;= mid) Update(lc, lft, mid, add); if (ur &gt; mid) Update(rc, mid+1, rht, add); &#125;&#125; 最后的 Query 操作只要把所有的标记 Pushdown 到叶子节点即可。解决了区间的问题，剩下的只要树剖一下就好了。 复杂度分析Update 操作是 $O(\\log N)$ 的，执行 $Q$ 次；Query 操作是 $O(N)$ 的，但只执行一次。 空间复杂度 $O(N)$ 时间复杂度 $O(Q\\log N + N)$ Hint数据范围比较大，会爆栈，需要手动扩栈。 1#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) 51nod 暂只有 Visual C++ 支持手动扩栈。 *** 树链剖分 ***","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://littleclown.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","permalink":"http://littleclown.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"中级","slug":"中级","permalink":"http://littleclown.github.io/tags/%E4%B8%AD%E7%BA%A7/"}]},{"title":"小球放盒模型","date":"2016-04-22T13:32:47.000Z","path":"study/math/combinatorial-mathematics/put-the-ball-in-box-model/","text":"准备组合数$$\\binom{n}{m} = C(n,m) = \\left\\lbrace \\begin{aligned} &amp;\\frac{n!}{m!~(n-m)!}, &amp;n \\geqslant m \\ &amp;0, &amp;n &lt; m \\end{aligned} \\right.$$ 第二类斯特林数\\begin{aligned} S(n,m) &amp;=mS(n-1,m)+S(n-1,m-1) \\ &amp;=\\frac{1}{m!} \\sum_{k=0}^m (-1)^k\\binom{m}{k} (m-k)^n \\ &amp;\\ &amp;\\text{其中， $n &gt; 1, m \\geqslant 1$。}\\end{aligned} 小球放盒模型有 $n$ 个小球放入 $m$ 个盒子中，求方案数。 000 小球无区别 盒子无区别 不允许空盒初始时，先给每一个盒子放一个小球。问题转化成 $n-m$ 个 无区别小球 放入 $m$ 个 无区别盒子 且 允许有空盒。方案数：$G(x)=\\frac{x^m}{(1-x)(1-x^2)\\cdots(1-x^m)}$ 的 $x^n$ 项系数。 001 小球无区别 盒子无区别 允许有空盒设某一方案中，有 $i$ 个小球的盒子有 $ a_i $ 个。 显然，$\\displaystyle \\left(\\sum_{i=0}^n a_i\\right) =m, ~ 0 \\leqslant a_i \\leqslant m $。对于每一个方案，我们仅用 $a_i \\neq 0$ 的项组成的形如 $\\big\\lbrace (r,a_r),(p,a_p),\\cdots,(q,a_q) \\big\\rbrace$ 的序偶序列表示足矣。问题等价于用 $\\lbrace 1,2,\\cdots,m \\rbrace$ 拆分 $n$ 的拆分数。利用母函数，容易得到： $$ \\begin{aligned} G(x)&amp;=(1+x+x^2+\\cdots)(1+x^2+x^4+\\cdots)\\cdots(1+x^m+x^{2m}+\\cdots) \\ &amp;=\\frac{x^m}{(1-x)(1-x^2)\\cdots(1-x^m)} \\end{aligned}$$方案数：$G(x)=\\frac{x^m}{(1-x)(1-x^2)\\cdots(1-x^m)}$ 的 $x^n$ 项系数。 010 小球无区别 盒子有区别 不允许空盒相当于在 $n$ 个小球中放置 $m-1$ 块挡板将小球分成不为空的 $m$ 部分。这个问题等价于在 $n-1$ 个位置中选择 $m-1$ 个位置。方案数：$C(n-1,m-1)$。 011 小球无区别 盒子有区别 允许有空盒由于允许空盒，根据前面的分析，挡板可以相邻。所以问题等价于，在 $n+m-1$ 个位置中放置 $m-1$ 块挡板。方案数：$C(n+m-1,m-1)$。 100 小球有区别 盒子无区别 不允许空盒设方案数 $f(n,m)$。讨论任一小球 $ball(1)$ 的摆放情况，所有的方案分为两类： $ball(1)$ 独占一个盒子；相当于其它 $n-1$ 个不同球需要放入 $m-1$ 个相同盒子且不允许空盒；方案数：$f(n-1,m-1)$。 $ball(1)$ 不独占一个盒子; 相当于先把 $n-1$ 个不同球放入 $m$ 个相同盒子且不允许空盒，再将 $ball(1)$ 放入任一盒子中； 得到递推式：$\\quad f(n,m) = m \\times f(n-1,m)+f(n-1,m-1). $比较第二类斯特林数，不难发现：$\\quad f(n,m)=S(n,m) $。 101 小球有区别 盒子无区别 允许有空盒仅需在 不允许空盒 的基础上枚举空盒个数就好了。方案数：$\\displaystyle \\sum_{i=1}^{\\min(n,m)} S(n,i)$ 110 小球有区别 盒子有区别 不允许空盒因为无空盒，且每个小球必然只能放到一个盒子中，故方案数等于 盒子无区别 时的方案数乘上 $m!$。方案数：$m! \\times S(n,m)$。 111 小球有区别 盒子有区别 允许有空盒显然每个球有 $m$ 个选择，且互不影响。方案数：$m^n$。 小结 $n$ 个球 $m$ 个盒子 是否允许空盒 方案数 无区别 无区别 无空盒 $G(x)=\\frac{x^m}{(1-x)(1-x^2)\\cdots(1-x^n)}$ 的 $x^n$ 项的系数 无区别 无区别 有空盒 $G(x)=\\frac{1}{(1-x)(1-x^2)\\cdots(1-x^n)}$ 的 $x^n$ 项的系数 无区别 有区别 无空盒 $C(n-1,m-1)$ 无区别 有区别 有空盒 $C(n+m-1,n)$ 有区别 无区别 无空盒 $S(n,m)$ 有区别 无区别 有空盒 \\begin{align} &amp;S(n,1)+S(n,2)+\\cdots+S(n,m), &amp;n\\geqslant m \\\\ &amp;S(n,1)+S(n,2)+\\cdots+S(n,n), &amp;n\\leqslant m \\end{align} 有区别 有区别 无空盒 $m!~S(n,m)$ 有区别 有区别 有空盒 $m^n$ HintMarkdown 下 \\\\\\ 才是换行。参考资料：《组合数学》（第 4 版》 —by 卢开澄、卢华明","tags":[]},{"title":"最长回文子串 Manacher 算法","date":"2016-04-18T14:53:22.000Z","path":"study/codding/algorithm/string/manacher/","text":"算法简介Manacher 算法能够在线性时间内求出一个字符串的最长回文子串。 算法原理记原字符串为 S，长度为 N。在 S 中的任一对相邻字符间插入一个特殊字符**’$’**，目的是保证新串中所有的回文子串长度都为奇数。设以 s[i] 为中心的最长回文串长度为 $2R[i]+1$。那么，如果 $j &lt; i$ 且 $j+R[j] &gt; i$；作 $i$ 点关于 $j$ 的对称点 $i’$，则必有 $i’ &gt; j-R[j]$。 见下图 在上图中，$i’-R[i’] &gt; j-R[j’]$；由对称性，可以断言 $R[i]=R[i’]$。 事实上，假设 $k’=i’-R[i’]-1$ 关于 $j$ 的对称点为 $k$; $k$ 关于 $i$ 的对称点为 $k_i$；$k_i$ 关于 $j$ 的对称点为 $k’_i$ 。 由于 $S[k]=S[k’]$，$S[k_i]=S[k’_i]$；$S[k’] \\neq S[k’_i]$。所以 $S[k] \\neq S[k_i]$，故 $R[i]=R[i’]$。 在上图中，$i’-R[i’] &lt; j-R[j’]$；由对称性，可以断言 $R[i]=j+R[j]-i$。 当 $j+R[j] \\leqslant i$ 时，不能做出更多的假设，只能暴力匹配。幸运地是，可以证明暴力匹配的总字符数是 $O(N)$ 的。 算法实现所谓的插入特殊字符是为了方便讲解，实现时可以将回文串 $[l,r]$ 的长度存在 $R[l+r]$ 中。不难发现，当回文串长度为偶数时，$l+r \\equiv 1\\mod(2)$。 参考了《ACM国际大学生程序设计竞赛:算法与实现》的代码。 123456789101112void Manacher(char* S, int* R, int n) &#123; R[0] = 1; int dn = (n&lt;&lt;1)-1; for(int i=1, j=0; i &lt; dn; ++i) &#123; int l = i&gt;&gt;1, r = i-l; int rst = (j-1&gt;&gt;1)+R[j]; R[i] = rst &lt; r? 0: min(rst-r+1, len[(j&lt;&lt;1)-i]); for(; l-R[i] &gt;=0 &amp;&amp; r+R[i] &lt; n &amp;&amp; S[l-R[i]] == S[r+R[i]]; ) ++R[i]; if( r+R[i] &gt; rst ) j = i; &#125;&#125; 复杂度分析由于每一次只从未被匹配过的字符出发往右扩展，一共只有 $O(N)$ 个字符，所以复杂度是线性的。 空间复杂度 $O(N)$ 时间复杂度 $O(N)$ Hint12if( i&amp;1 ) len = R[i]*2;else len = R[i]*2-1; 小记第一次接触这个算法是在 2016 年武大的校赛上；第一次没有抱大腿获奖;虽然奖品有点坑。。。","tags":[{"name":"字符串","slug":"字符串","permalink":"http://littleclown.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Manacher","slug":"Manacher","permalink":"http://littleclown.github.io/tags/Manacher/"}]},{"title":"POJ-1324 Holedox Moving 解题报告","date":"2016-04-13T02:09:54.000Z","path":"acm/oj/poj/1300/1324/","text":"*** 题目链接 ****** Code *** 题意简述在一个 $N\\times M$ 的矩形方格地图中，有一条长度为 $L$ 的贪吃蛇。地图的 (1,1) 位置是一个出口，如果贪吃蛇能移动到出口，输出最短步数（头到达出口的步数）；否则输出 -1。贪吃蛇的移动规则： 只能朝边相邻的格子移动 不能朝障碍物移动（身体及四周墙壁都视作障碍物） 数据范围： $1\\leqslant N, M\\leqslant 8$，$2\\leqslant L\\leqslant 8$。 题目简析为方便叙述，对贪吃蛇的身体进行编号：蛇头为 -1 号，蛇尾为 $L-2$ 号，以此类推。因为贪吃蛇的身体是紧邻的。所以，当我们确定了蛇头的位置，对于身体的其它任一部分 $i$，我们仅需知道 $i$ 相对与 $i-1$ 的方向即可。则可用链表的思想来存储贪吃蛇： 蛇头用一个二元组 $(x,y)$ 表示其位置 身体其它部分 $i$ 用一个整数 $dir(i)\\in\\lbrace 0, 1, 2, 3 \\rbrace$ 来表示它相对 $i-1$ 的方向。 注意到方向只有 4 个数，其蛇的身体 $L\\leqslant 8$。不难想到状态压缩。约定 $2^{i},2^{i+1}$ 的系数表示 $i$ 号身体相对于 $i-1$ 号身体的方向。我们会方向，当蛇头朝某一合法位置移动后，$newdir(i)=dir(i-1)$！其中，$newdir(i)$ 表示移动后，$i$ 号身体相对于 $i-1$ 号身体的方向。 为什么呢？因为当贪吃蛇移动一步后，除了蛇头，$i$ 号身体将会移至原先 $i-1$ 号身体所在的地方。特别地，$newdir(0)$ 将会等于蛇头移动的反方向。 所以，当贪吃蛇移动一步后，我们仅需将方向变量：左移两位，再右移两位，再或上蛇头移动的方向。剩下的问题就很普通了,搜索即可。 复杂度分析由于移动操作仅需 $O(1)$ 就可以完成了；但是，判断下一步是否为蛇的身体将需要 $O(L)$ 的时间完成。一共有 $O(N\\times M\\times 2^{2L-2})$ 个状态。 空间复杂度 $O(N\\times M\\times 2^{2L-2})$ 时间复杂度 $O(N\\times M\\times L\\times 2^{2L-2})$ Hint问题的难点在于移动操作的处理。","tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"http://littleclown.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"图论","slug":"图论","permalink":"http://littleclown.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"中级","slug":"中级","permalink":"http://littleclown.github.io/tags/%E4%B8%AD%E7%BA%A7/"},{"name":"BFS","slug":"BFS","permalink":"http://littleclown.github.io/tags/BFS/"}]},{"title":"HDU-5574 Colorful Tree （原 2015-上海区域赛-C） 解题报告","date":"2016-04-12T06:30:03.000Z","path":"acm/oj/hdu/5500/5574/","text":"*** 题目链接 ****** Code *** 题意简述一棵 $N$ 个节点的树，节点编号 $1 \\sim N$，且根节点编号始终为 1。初始时，节点 $i$ 的颜色为 $c_i$。$M$ 次操作： 0 u c $\\hskip .6em$ 将以 u 为根节点的子树中所有的节点颜色染成 c 1 u $\\hskip 1.5em$ 输出 u 为根节点的子树中颜色种数 数据范围： $1\\leqslant T\\leqslant 100$，$1\\leqslant N, M\\leqslant 10^5$, $1\\leqslant c_i\\leqslant N$。 题目简析应该想到要用线段树。但是如果直接用 DFS 序来表示树中的一段区间的话，维护颜色就举步维艰了。因为查询是一棵子树的颜色种数，普通的区间标记根本就无能为力。 只好另谋出路。 注意到，在树中，一个节点的颜色只会对其及祖先节点有贡献。具体地，一个节点的颜色更改可以视作将原来的颜色删除，再添加新的颜色。这样的话，删除颜色就对该节点及其祖先节点贡献 -1；添加颜色则 +1。但是，不难发现，有一个问题。 如下图（仅考虑 orange 对祖先节点的贡献）:*** *** 上图中，orange 对节点 orange、green 及 red 都有一个贡献值。但是，如果我们要把 violet 的颜色改成 orange 的话，则从 violet -&gt; red 这一条链中： 删除颜色 所有节点的贡献 -1 添加颜色 只对 violet、blue 两个节点 +1。因为，节点 red、green 已被 orange 这个颜色更新过了。 如下图（仅考虑将 violet 颜色修改成 orange 对祖先节点的贡献）： *** *** 不难想到，当修改一个节点 $i$ 的颜色 $c_i$ 时，我们仅需修改所有与 $c_i$ 颜色相同的节点与 $i$ 的最近公共祖先（所有与 $i$ 构成的最近公共祖先中的距离 $i$ 最近的祖先）$g(i)$ 到 $i$ 这条路径的所有的节点（包括 $i$，但不包括 $g(i)$ ） 即可。 如何找到 $g(i)$ 呢？ 假设节点 $i$ 在这棵树先序遍历序列中位置为 $dfs(i)$。 如果节点 $j$、$k$ 颜色和 $i$ 相同，即满足 $c_j=c_k=c_i$; 且对于任意 $dfs(j)\\leqslant dfs(i)\\leqslant dfs(k)$。 那么，$dfs\\big(g(i)\\big)=\\min \\Big\\lbrace dfs\\big(LCA(i, j)\\big), dfs\\big(LCA(i, k)\\big) \\Big\\rbrace$。 其中，$LCA(i,j)$ 表示节点 $i$、$j$ 的最近公共祖先。 所以，我们只要对每一种颜色开一棵平衡树，键值为节点的 dfs 序。然后 lower_bound, upper_bound 一下就可以找到 $j$，$k$ 了。 至于链上的操作树链剖分就可以了。 所以当我们执行一次 操作0 时，要把 $u$ 的子树中所有的颜色删掉，然后仅给 $u$ 添加新的颜色 $c$。注意到这样一来，一个节点颜色 $c_i$ 就是距它最近的有颜色的祖先（此处，$i$ 视作 $i$ 的祖先）的颜色了。同时，这样一来，当前节点颜色并没有总是对自己贡献 +1，因为我们始终只考虑了 $u$ -&gt; $g(u)$ 这条路径上的节点；而 $u$ 的子孙节点其实是有颜色的，且均为 $c$。所以，查询时如果发现当前节点颜色未在子孙节点中出现，答案 +1。 判断当前节点颜色是否在子孙节点中出现有一个小技巧，详见 *** Code ***。 123456int flag = 0;int c = TheColor(u);if( c ) &#123; it = lower_bound(s[c].begin(), s[c].end(), st[u]); if( it == s[c].end() || *it &gt; ed[u] ) flag = 1;&#125; 复杂度分析由于删除一个节点的复杂度为 $O(\\log^2 N)$（树链剖分有一个 $\\log$)，我们最多添加 $M$ 个节点，因此时间复杂度为 $O((M+N)log^2N)$。 空间复杂度 $O(N)$ 时间复杂度 $O((M+N)log^2 N)$ Hint据说正解是 $O(N\\log N)$ 的，蒟蒻表示不会。多谢小小兰学长的指教。 *** 参考链接 ****** 参考链接 ****** 树链剖分 ***","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://littleclown.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","permalink":"http://littleclown.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"难题","slug":"难题","permalink":"http://littleclown.github.io/tags/%E9%9A%BE%E9%A2%98/"}]},{"title":"快速傅里叶变换和雷德算法","date":"2016-04-10T13:24:45.000Z","path":"study/math/number-theory/fft/fft/","text":"*** SomethingAboutFFT.pdf *** 小记说起来，实在要感谢 lyl 学长（可能他并不想我写上他的名字，以下以他常用的名字 SparklingWind 指代）。大一的时候看了 SparklingWind 的《高中生学 FFT 算法》，当时自己实在太弱（虽然现在还是弱。。）以至于看得云里雾里。后来 SparklingWind 教我用 LaTeX，实在是让我受益匪浅。LaTeX 是一款精致的排版系统，可以漂亮、准确的表达出你心中所想。于是，我决定要基于自己的理解用 LaTeX 写一份 FFT 的学习笔记云云的东西，我把它命令为 SomethingAboutFFT，初衷是担心 LaTeX 这种软件对中文名不友好。。。 当时写了一份类似注解一样的东西，好像有 7 页，但是代码十分恶心。。之后随着对 LaTeX 学习的深入，又几经修改。 直到 2015 年暑假的一天晚上突然来了灵感把 HNU10004 给过了，心情大好，决定重写这份文档。 真的很用心的去完成它，希望你能喜欢。 Markdown 不能完全识别 LaTeX 代码，所以谨附上 *** pdf ***，以纪念这段寻常的往事。","tags":[{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"快速傅里叶变换","slug":"快速傅里叶变换","permalink":"http://littleclown.github.io/tags/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"复数","slug":"复数","permalink":"http://littleclown.github.io/tags/%E5%A4%8D%E6%95%B0/"}]},{"title":"HDU-5306 Gorgeous Sequence 解题报告","date":"2016-04-09T12:14:19.000Z","path":"acm/oj/hdu/5300/5306/","text":"*** 题目链接 ****** Code *** 题意简述$N$ 个点的序列，编号 0~$N$-1。初始时，点 $i$ 的权值为 $a_i$。$M$ 次操作： 0 x y t $\\hskip .6em$ 令 $a_i=\\min\\lbrace a_i, t \\rbrace$，其中：$x\\leqslant i\\leqslant y$。 1 x y $\\hskip 1.5em$ 输出 $\\max\\lbrace a_i \\rbrace$，其中：$x\\leqslant i\\leqslant y$。 2 x y $\\hskip 1.5em$ 输出 $\\displaystyle \\sum\\limits_{x\\leqslant i\\leqslant y} a_i$。 数据范围： $\\displaystyle 1\\leqslant T\\leqslant 100; 1 \\leqslant \\sum N, \\sum M \\leqslant 10^6$。 题目简析这是一道难题。 用线段树维护一段区间，4 个标记：tag, cnt, max, sum。其中，max, sum 的含义显而易见。tag 是一个懒惰标记, 表示在该区间执行了一次 操作0，且 t=tag；同时，tag==0 时还表示当前节点信息未被正确更新。cnt 表示当前区间中要删除的点的个数（见下文）。 注意到修改操作不会让 $a_i$ 变大，因此当一个数成功被修改后，它的值将始终等于 ** 当前区间的最大值 **，这点很重要。那么我们完全可以将这个数删除掉，即把这个数的权值置为 0，此后只维护当前区间的最大值信息即可。 注意，我们仅删除叶子节点。 同时，当一个叶子节点被删除时，我们要令其 cnt=1，注意到这样一来，整条从当前节点到该叶子节点的路径的信息都未被正确更新，所以我们要将整条路径的 tag 置为 0 ；同时，要执行一次 Pushup 操作，目的是将删除后的信息正确推送给父节点。 Pushup12345void Pushup(int o) &#123; maxv[o] = std:: max(maxv[lc], maxv[rc]); sumv[o] = sumv[lc] + sumv[rc]; cntv[o] = cntv[lc] + cntv[rc];&#125; 所以，完整的清零操作 Clear 应该是： 判断当前节点的 max 值是否大于 t， 若是，则不需要对该子树做修改 把当前节点 tag 置为 0 判断当前节点是否为叶子节点，若是则删除该节点； 否则，递归 Clear 左右子树，并 Pushup Clear123456789101112void Clear(int o, int tag) &#123; if( maxv[o] &lt;= tag ) return; tagv[o] = 0; if( leav[o] ) &#123; sumv[o] = maxv[o] = 0; cntv[o] = 1; &#125; else &#123; Clear(lc, tag); Clear(rc, tag); Pushup(o); &#125;&#125; 再考虑维护操作。max 的维护很简单，瞎搞下就好，问题在于 sum 的维护。由于执行操作 0，实际是将一个大于 t 的值变成 t，而不是删掉。这时， cnt 的作用就体现了。我们仅需执行 sum += cnt $\\times$ t。 Maintain123456789void Maintain(int o, int tag) &#123; if( tagv[o] ) return; // tagv[o]==0 表示当前节点未被正确更新 tagv[o] = tag; if( cntv[o] ) &#123; // 如果节点 o 维护的区间有叶子节点被删除 sumv[o] += (LL) cntv[o] * tag; maxv[o] = tag; cntv[o] = 0; &#125;&#125; 所以，更新操作就是将待修改区间的 权值比 t 大的叶子节点删除；同时，Maintain 当前区间的信息。 Update1234567891011121314int __ul, __ur, __uv;void Update(int o, int lft, int rht) &#123; if( maxv[o] &lt;= __uv ) return; if( __ul&lt;=lft and rht&lt;=__ur ) &#123; Clear(o, __uv); Maintain(o, __uv); &#125; else &#123; int mid = MID(lft, rht); Pushdown(o); if( __ul &lt;= mid ) Update(lson); if( __ur &gt; mid ) Update(rson); Pushup(o); &#125;&#125; 需要注意的是，Pushdown 操作把 tag 信息下传后，当前节点的 tag 不应该置为 0，因为 tag==0 表示当前节点的信息未被正确维护。所以直接调用 Maintain 维护左右子树即可。 Pushdown123456void Pushdown(int o) &#123; if( tagv[o] ) &#123; Maintain(lc, tagv[o]); Maintain(rc, tagv[o]); &#125;&#125; 复杂度分析显然，单次 Update 和 Query 只会影响 $O(log N)$ 个节点。一开始一共有 $N$ 个节点，而单次的 Update 或 Query 操作至多产生 4 个叶子节点，而删除一个叶子节点的代价是 $O(\\log N)$，也就是 Clear 操作，故复杂度为 $O((N+4M)\\log N)$。 空间复杂度 $O(N)$ 时间复杂度 $O(N\\log N)$ Hint尽管我们得到了 $O((N+4M)\\log N)$ 的算法，但由于本题数据太大，还是要加一个读入优化才能过。*** 参考链接 ***","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://littleclown.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ACM","slug":"ACM","permalink":"http://littleclown.github.io/tags/ACM/"},{"name":"解题报告","slug":"解题报告","permalink":"http://littleclown.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"线段树","slug":"线段树","permalink":"http://littleclown.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"难题","slug":"难题","permalink":"http://littleclown.github.io/tags/%E9%9A%BE%E9%A2%98/"}]}]