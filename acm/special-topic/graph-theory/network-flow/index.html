<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>网络流专题 | Clown's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="实现由于网络流问题难点在于建模，实现网络流的代码几乎可以不变，为此，特将下文中将会多次使用到的代码给罗列出来。 ISAP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747">
<meta property="og:type" content="article">
<meta property="og:title" content="网络流专题">
<meta property="og:url" content="http://littleclown.github.io/acm/special-topic/graph-theory/network-flow/index.html">
<meta property="og:site_name" content="Clown&#39;s Blog">
<meta property="og:description" content="实现由于网络流问题难点在于建模，实现网络流的代码几乎可以不变，为此，特将下文中将会多次使用到的代码给罗列出来。 ISAP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-07-30T05:16:55.000Z">
<meta property="article:modified_time" content="2019-01-03T02:22:28.466Z">
<meta property="article:author" content="笑着哭的小丑">
<meta property="article:tag" content="ACM">
<meta property="article:tag" content="解题报告">
<meta property="article:tag" content="二分图">
<meta property="article:tag" content="网络流">
<meta property="article:tag" content="专题训练">
<meta name="twitter:card" content="summary"><link rel="alternative" href="/atom.xml" title="Clown's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.ico">
<link rel="stylesheet" href="/css/style.css">
<meta name="generator" content="Hexo 5.4.0"></head><body><div id="container"><div class="left-col"><div class="overlay"></div><div class="intrude-less"><header class="inner" id="header"><a class="profilepic" href="/"><img class="js-avatar" lazy-src="/img/avatar.jpg"/></a><hgroup><h1 class="header-author"><a href="/">笑着哭的小丑</a></h1></hgroup><div class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-link hide" data-idx="2"><div class="loopback_l"></div><div class="loopback_r"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>菜单</li><li>标签</li><li>友情链接</li><li>关于我</li></ul></div></div><div class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives">文章</a></li></ul></nav><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LittleClown" title="github">github</a></div></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><a href="/tags/ACM/" style="font-size: 20px;">ACM</a> <a href="/tags/Aho-Corasick-%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 10px;">Aho-Corasick 自动机</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/Baby-Step-Gaint-Step/" style="font-size: 11.67px;">Baby Step Gaint Step</a> <a href="/tags/Manacher/" style="font-size: 10px;">Manacher</a> <a href="/tags/SG-%E5%AE%9A%E7%90%86/" style="font-size: 10px;">SG 定理</a> <a href="/tags/Splay/" style="font-size: 10px;">Splay</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/keyword/" style="font-size: 10px;">keyword</a> <a href="/tags/protected/" style="font-size: 10px;">protected</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/web-%E5%BC%80%E5%8F%91/" style="font-size: 10px;">web 开发</a> <a href="/tags/%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/" style="font-size: 11.67px;">专题训练</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" style="font-size: 11.67px;">中国剩余定理</a> <a href="/tags/%E4%B8%AD%E7%BA%A7/" style="font-size: 11.67px;">中级</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 11.67px;">二分图</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/%E5%8E%9F%E6%A0%B9/" style="font-size: 11.67px;">原根</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 11.67px;">图论</a> <a href="/tags/%E5%A4%8D%E6%95%B0/" style="font-size: 10px;">复数</a> <a href="/tags/%E5%AD%97%E5%85%B8%E6%A0%91/" style="font-size: 10px;">字典树</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 11.67px;">字符串</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">学习笔记</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" style="font-size: 10px;">快速傅里叶变换</a> <a href="/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/" style="font-size: 11.67px;">扩展欧几里得</a> <a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 11.67px;">技术</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 13.33px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size: 16.67px;">数论</a> <a href="/tags/%E6%97%A2%E7%BA%A6%E5%89%A9%E4%BD%99%E7%B3%BB/" style="font-size: 10px;">既约剩余系</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/" style="font-size: 10px;">最大权闭合图</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size: 13.33px;">树链剖分</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10px;">概率论</a> <a href="/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/" style="font-size: 11.67px;">欧拉函数</a> <a href="/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/" style="font-size: 11.67px;">状态压缩</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%98%E5%BD%A2/" style="font-size: 10px;">矩阵快速幂变形</a> <a href="/tags/%E7%B4%A0%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B/" style="font-size: 10px;">素数线性筛</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 11.67px;">线性代数</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 13.33px;">线段树</a> <a href="/tags/%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">组合游戏</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 11.67px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 11.67px;">网络流</a> <a href="/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/" style="font-size: 10px;">行列式</a> <a href="/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" style="font-size: 18.33px;">解题报告</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 11.67px;">计算机</a> <a href="/tags/%E8%AE%AD%E7%BB%83%E8%B5%9B/" style="font-size: 10px;">训练赛</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" style="font-size: 10px;">语法分析</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">语法制导翻译</a> <a href="/tags/%E9%80%92%E6%8E%A8/" style="font-size: 10px;">递推</a> <a href="/tags/%E9%9A%BE%E9%A2%98/" style="font-size: 11.67px;">难题</a> <a href="/tags/%E9%AB%98%E7%BA%A7/" style="font-size: 10px;">高级</a></div></section><section class="switch-part switch-part3"><div id="js-friends"><a class="main-nav-link switch-friends-link" target="_blank" href="http://sparklingwind.github.io/">SparklingWind</a></div></section><section class="switch-part switch-part4"><div id="js-aboutme">时过境迁、惟愿此心不变、</div></section></div></div></header></div></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"></h1></div><div class="intrude-less"><header class="inner" id="header"><div class="profilepic"><img class="js-avatar"/></div><hgroup><h1 class="header-author"></h1></hgroup><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives">文章</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LittleClown" title="github">github</a></div></nav></header></div></nav><div class="body-wrap"><article class="article article-type-post" id="post-acm/special-topic/graph-theory/network-flow" itemscope="itemscope" itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/acm/special-topic/graph-theory/network-flow/"><time datetime="2016-07-30T05:16:55.000Z" itemprop="datePublished">2016-07-30</time></a></div><div class="article-inner"><input class="isFancy" type="hidden"/><header class="article-header"><h1 class="article-title" itemprop="name">网络流专题</h1></header><div class="article-info article-info-post"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/" rel="tag">ACM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83/" rel="tag">专题训练</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" rel="tag">解题报告</a></li></ul></div><div class="clearfix"></div></div><div class="article-entry" itemprop="articleBody"><!-- by SparklingWind--><div class="toc-article" id="toc"><div class="toc-title">目录<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ISAP"><span class="toc-number">1.1.</span> <span class="toc-text">ISAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dinic"><span class="toc-number">1.2.</span> <span class="toc-text">Dinic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MCMF"><span class="toc-number">1.3.</span> <span class="toc-text">MCMF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-number">1.4.</span> <span class="toc-text">read</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">网络流 24 题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01"><span class="toc-number">2.1.</span> <span class="toc-text">01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02"><span class="toc-number">2.2.</span> <span class="toc-text">02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03"><span class="toc-number">2.3.</span> <span class="toc-text">03</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04"><span class="toc-number">2.4.</span> <span class="toc-text">04</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05"><span class="toc-number">2.5.</span> <span class="toc-text">05</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06"><span class="toc-number">2.6.</span> <span class="toc-text">06</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07"><span class="toc-number">2.7.</span> <span class="toc-text">07</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08"><span class="toc-number">2.8.</span> <span class="toc-text">08</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09"><span class="toc-number">2.9.</span> <span class="toc-text">09</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10"><span class="toc-number">2.10.</span> <span class="toc-text">10</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11"><span class="toc-number">2.11.</span> <span class="toc-text">11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12"><span class="toc-number">2.12.</span> <span class="toc-text">12</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">2.13.</span> <span class="toc-text">汇总</span></a></li></ol></li></ol></div></div><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>由于网络流问题难点在于建模，实现网络流的代码几乎可以不变，为此，特将下文中将会多次使用到的代码给罗列出来。</p>
<h2 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ISAP &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="keyword">int</span> from=<span class="number">0</span>, <span class="keyword">int</span> to=<span class="number">0</span>, <span class="keyword">int</span> cap=<span class="number">0</span>, <span class="keyword">int</span> flow=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap), <span class="built_in">flow</span>(flow) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> s, t, n;</span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN];</span><br><span class="line">    <span class="keyword">int</span> cur[MAXN];</span><br><span class="line">    <span class="keyword">int</span> path[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line">    std:: vector&lt;edge&gt; edges;</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line">    std:: queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = edges.<span class="built_in">size</span>();</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(siz);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(siz+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        Q.<span class="built_in">push</span>(t);</span><br><span class="line">        dist[t] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                edge&amp; e = edges[G[o][i]];</span><br><span class="line">                <span class="keyword">if</span>( dist[e.to] == INF &amp;&amp; e.cap == <span class="number">0</span> ) &#123;</span><br><span class="line">                    dist[e.to] = dist[o] + <span class="number">1</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mif = INF; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=t; o != s;) &#123;</span><br><span class="line">            edge&amp; e = edges[path[o]];</span><br><span class="line">            mif = std:: <span class="built_in">min</span>(mif, e.cap-e.flow);</span><br><span class="line">            o = e.from;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=t; o != s;) &#123;</span><br><span class="line">            edges[path[o]].flow += mif;</span><br><span class="line">            edges[path[o]^<span class="number">1</span>].flow -= mif;</span><br><span class="line">            o = edges[path[o]].from;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mif;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BFS</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span> cur);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">if</span>( dist[i] &lt; n ) ++cnt[dist[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=s; dist[o] &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( o == t ) ans += <span class="built_in">augment</span>(), o = s;</span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[o]; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                edge&amp; e = edges[G[o][i]];</span><br><span class="line">                <span class="keyword">if</span>( e.cap &gt; e.flow &amp;&amp; dist[o] == dist[e.to]+<span class="number">1</span> ) &#123;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    cur[o] = i;</span><br><span class="line">                    path[e.to] = G[o][i];</span><br><span class="line">                    o = e.to;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !ok ) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    edge&amp; e = edges[G[o][i]];</span><br><span class="line">                    <span class="keyword">if</span>( e.cap &gt; e.flow ) d = std:: <span class="built_in">min</span>(d, dist[e.to]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( --cnt[dist[o]] == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">                ++cnt[dist[o] = d+<span class="number">1</span>];</span><br><span class="line">                cur[o] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>( o != s ) o = edges[path[o]].from;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Dinic &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="keyword">int</span> from=<span class="number">0</span>, <span class="keyword">int</span> to=<span class="number">0</span>, <span class="keyword">int</span> cap=<span class="number">0</span>, <span class="keyword">int</span> flow=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap), <span class="built_in">flow</span>(flow) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> cur[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line">    std:: queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    std:: vector&lt;edge&gt; edges;</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = edges.<span class="built_in">size</span>();</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(siz);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(siz+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                edge&amp; e = edges[G[o][i]];</span><br><span class="line">                <span class="keyword">if</span>( dist[e.to] != <span class="number">-1</span> || e.cap &lt;= e.flow ) <span class="keyword">continue</span>;</span><br><span class="line">                dist[e.to] = dist[o]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist[t] != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> minflow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( o == t || minflow == <span class="number">0</span> ) <span class="keyword">return</span> minflow;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; i=cur[o]; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            edge&amp; e = edges[G[o][i]];</span><br><span class="line">            <span class="keyword">if</span>( dist[e.to] == dist[o]+<span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">int</span> f = <span class="built_in">DFS</span>(e.to, std:: <span class="built_in">min</span>(minflow, e.cap-e.flow));</span><br><span class="line">                <span class="keyword">if</span>( f &lt;= <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[o][i]^<span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                minflow -= f;</span><br><span class="line">                <span class="keyword">if</span>( minflow == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">BFS</span>() ) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            ans += <span class="built_in">DFS</span>(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MCMF &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="keyword">int</span> from=<span class="number">0</span>, <span class="keyword">int</span> to=<span class="number">0</span>, <span class="keyword">int</span> cap=<span class="number">0</span>, <span class="keyword">int</span> flow=<span class="number">0</span>, <span class="keyword">int</span> cost=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap), <span class="built_in">flow</span>(flow), <span class="built_in">cost</span>(cost) &#123;&#125;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> cost, flow;</span><br><span class="line">    <span class="keyword">int</span> path[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line">    std:: vector&lt;edge&gt; edges;</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> source=<span class="number">0</span>, <span class="keyword">int</span> converge=<span class="number">1</span>, <span class="keyword">int</span> N=MAXN)</span> </span>&#123;</span><br><span class="line">        s = source; </span><br><span class="line">        t = converge;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        flow = <span class="number">0</span>;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; N; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = edges.<span class="built_in">size</span>();</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(siz);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(siz+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> std:: queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> inq[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        inq[s] = <span class="literal">true</span>;</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                edge&amp; e = edges[G[o][i]];</span><br><span class="line">                <span class="keyword">if</span>( e.cap &gt; e.flow &amp;&amp; dist[e.to] &gt; dist[o]+e.cost ) &#123;</span><br><span class="line">                    dist[e.to] = dist[o] + e.cost;</span><br><span class="line">                    path[e.to] = G[o][i];</span><br><span class="line">                    <span class="keyword">if</span>( inq[e.to] ) <span class="keyword">continue</span>;</span><br><span class="line">                    inq[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inq[o] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> dist[t] != INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std:: <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">mincostmaxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">SPFA</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mif = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o=t; o != s;) &#123;</span><br><span class="line">                edge&amp; e = edges[path[o]];</span><br><span class="line">                mif = std:: <span class="built_in">min</span>(mif, e.cap-e.flow);</span><br><span class="line">                o = e.from;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o = t; o != s;) &#123;</span><br><span class="line">                edges[path[o]].flow += mif;</span><br><span class="line">                edges[path[o]^<span class="number">1</span>].flow -= mif;</span><br><span class="line">                o = edges[path[o]].from;</span><br><span class="line">            &#125;</span><br><span class="line">            flow += mif;</span><br><span class="line">            cost += mif*dist[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std:: <span class="built_in">make_pair</span>(flow, cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> ) positive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        s = s*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> positive? s: -s;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="网络流-24-题"><a href="#网络流-24-题" class="headerlink" title="网络流 24 题"></a>网络流 24 题</h1><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><span id="01">
**Power OJ/1736 *[飞行员配对方案问题](https://www.oj.swust.edu.cn/problem/show/1736)***
</span>
经典的二分图模型。
- 外籍飞行员作为左侧点，英国飞行员作为右侧点，可以互相配合的飞行员之间连一条容量为 1 的边
- 建立源点 $s$，并从 $s$ 对左侧的每个点引一条容量为 1 的边
- 建立汇点 $t$，并从右侧的每个点向 $t$ 引一条容量为 1 的边

<p>跑最大流。<br>至于方案，仅需考虑满流的边 $\left&lt; \mu,\nu \right&gt;$（其中 $\mu \in$ 左侧的点集，$\nu \in$ 右侧的点集），那么 $\mu$ 和 $\nu$ 是一对搭档。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ISAP:: <span class="built_in">solve</span>(<span class="keyword">int</span> N, <span class="keyword">int</span> M) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    s = <span class="number">0</span>; t = M+<span class="number">1</span>; n = M+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">maxflow</span>();</span><br><span class="line">    <span class="keyword">if</span>( ans &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>; o &lt; N; ++o) &#123;</span><br><span class="line">            edge&amp; e = edges[G[<span class="number">0</span>][o]];</span><br><span class="line">            <span class="keyword">if</span>( e.cap == e.flow ) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[e.to]) &#123;</span><br><span class="line">                    edge&amp; e2 = edges[i];</span><br><span class="line">                    <span class="keyword">if</span>( e2.cap == e2.flow ) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, e.to, e2.to);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N+<span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(i, M+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>( u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span> ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>( u &gt; v ) std:: <span class="built_in">swap</span>(u, v);</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ISAP:: <span class="built_in">solve</span>(N, M);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><span id="02">
**Power OJ/1737 *[太空飞行计划问题](https://www.oj.swust.edu.cn/problem/show/1737)***
</span>
经典的最大权闭合图问题。
关于最大权闭合图可以参见 ***[网络流基础之最大权闭合图](http://littleclown.github.io/2016/07/24/Study-GT-network-flow-Maximum-weight-Closure-of-a-Graph/)***。
- 设实验 $i$ 获利为 $x\_i$，实验仪器 $j$ 花费为 $y\_j$
- 将每个实验与实验所需仪器连边，且容量设为 $\infty$
- 建立源点 $s$，并从 $s$ 对所有的实验引一条容量为 $\alpha\times x+\beta$ 的边（其中，$\alpha$ 与 $\beta$ 的作用及取值在 ***[网络流基础之最大权闭合图](http://littleclown.github.io/2016/07/24/Study-GT-network-flow-Maximum-weight-Closure-of-a-Graph/)*** 一文中有详细讨论）
- 建立汇点 $t$，并从所有的实验仪器向 $t$ 引一条容量为 $\alpha\times y$ 的边

<p>跑最大流，$\big(\sum x \big)$-最大流量 即是答案。<br>至于方案，仅需考虑满流的边所连接的节点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ISAP:: <span class="built_in">solve</span>(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> tot) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> used[MAXN];</span><br><span class="line">        <span class="keyword">static</span> std:: stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line"></span><br><span class="line">        s = <span class="number">0</span>; t = M+N+<span class="number">1</span>; n = M+N+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = tot-<span class="built_in">maxflow</span>();</span><br><span class="line">        </span><br><span class="line">        st.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span>( !st.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            used[o] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[o]) &#123;</span><br><span class="line">                edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span>( e.cap &gt; e.flow &amp;&amp; !used[e.to] ) </span><br><span class="line">                    st.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= M; ++i) <span class="keyword">if</span>( used[i] ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i); <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">if</span>( used[M+i] ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i); <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans&gt;&gt;<span class="number">16</span>);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> partail = (<span class="number">1</span>&lt;&lt;<span class="number">16</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10000</span>], *ss;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextint</span><span class="params">(<span class="keyword">char</span>* &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; *s &lt; <span class="string">&#x27;0&#x27;</span> || *s &gt; <span class="string">&#x27;9&#x27;</span>; s++)</span><br><span class="line">        <span class="keyword">if</span>( *s == <span class="string">&#x27;\n&#x27;</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; *s &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="string">&#x27;9&#x27;</span>; s++)</span><br><span class="line">        num = num*<span class="number">10</span> + *s-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ss=s; (*ss=<span class="built_in">getchar</span>()) == <span class="string">&#x27;\n&#x27;</span>; );</span><br><span class="line">        <span class="keyword">for</span>(ss=s+<span class="number">1</span>; (*ss=<span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>; ++ss);</span><br><span class="line">        ss = s;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">nextint</span>(ss)&lt;&lt;<span class="number">16</span>|<span class="number">1</span>;</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, i, val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id; (id=<span class="built_in">nextint</span>(ss)) != <span class="number">-1</span>;)</span><br><span class="line">            ISAP:: <span class="built_in">addedge</span>(i, M+id, INF);</span><br><span class="line">        tot += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">read</span>()&lt;&lt;<span class="number">16</span>;</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(M+i, M+N+<span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ISAP:: <span class="built_in">solve</span>(M, N, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><span id="03">
**Power OJ/1738 *[最小路径覆盖问题](https://www.oj.swust.edu.cn/problem/show/1738)***
</span>
经典的有向无环图最小路径覆盖问题。
- 最小路径覆盖要求的是有向无环图，将原图每个点拆成两个，显然新图是一个二分图
- 求出二分图最大匹配，最小路径覆盖数=原图点数-新图最大匹配数。

<p>简单证明：初始时可以看做有 $N$ 个长度为 0 的路径，每得到一个匹配相当于合并两条路径。<br>至于方案，从左侧任意一个未访问过的点出发，经沿着交替路走，得到的就是最小路径覆盖中的一条路径。<br>考虑到使用网络流求出路径比较麻烦 = =，仅给出二分图的 <strong>增广路算法</strong> 的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hungary &#123;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line">    <span class="keyword">int</span> left[MAXN], right[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> mark[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L=<span class="number">0</span>, <span class="keyword">int</span> R=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        hungary:: L = L;</span><br><span class="line">        hungary:: R = R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u &lt;= L; ++u ) G[u].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span>( !mark[v] ) &#123;</span><br><span class="line">                mark[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>( !left[v] || <span class="built_in">match</span>(left[v]) ) &#123;</span><br><span class="line">                    left[v] = u;</span><br><span class="line">                    right[u] = v;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">0</span>, <span class="keyword">sizeof</span> left);</span><br><span class="line">        <span class="built_in">memset</span>(right, <span class="number">0</span>, <span class="keyword">sizeof</span> right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u &lt;= L; ++u) <span class="keyword">if</span>( !right[u] ) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span> mark);</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">match</span>(u) ) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span> mark);</span><br><span class="line">        mark[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>; o &lt;= L; ++o) <span class="keyword">if</span>( !mark[o] ) &#123;</span><br><span class="line">            mark[o] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, o);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u=right[o]; !mark[u]; u=right[u]) &#123;</span><br><span class="line">                mark[u] = <span class="literal">true</span>; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, u);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L-ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> ) positive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        s = s*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> positive? s: -s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    hungary:: <span class="built_in">init</span>(N, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">read</span>();</span><br><span class="line">        hungary:: G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hungary:: <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><span id="04">
**Power OJ/1739 *[魔术球问题](https://www.oj.swust.edu.cn/problem/show/1739)***
</span>
经典的有向无环图最小路径覆盖问题。
- 同样地，拆点得到二分图结构
- 如果 $\mu$ 是左侧的点，$\nu$ 是右侧的点，且 $\mu+\nu$ 是一个完全平方数，那么连一条从 $\mu$ 到 $\nu$ 的边
- 逐渐加点，直到最小覆盖数超过给定值终止
- 假如在 $N+1$ 的时候终止，可以考虑对于前面 $N$ 个点中会与 $N+1$ 形成完全平方数的点删掉最后一条边，再跑一遍最大匹配。

<p>路径的问题和 <em><strong><a href="#03">03</a></strong></em> 一样，不再赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hungary &#123;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    <span class="keyword">bool</span> mark[MAXN];</span><br><span class="line">    <span class="keyword">int</span> left[MAXN], right[MAXN];</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L=<span class="number">0</span>, <span class="keyword">int</span> R=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        hungary:: L = L;</span><br><span class="line">        hungary:: R = R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u &lt;= L; ++u ) G[u].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span>( !mark[v] ) &#123;</span><br><span class="line">                mark[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>( !left[v] || <span class="built_in">match</span>(left[v]) ) &#123;</span><br><span class="line">                    left[v] = u;</span><br><span class="line">                    right[u] = v;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxmatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u &lt;= L; ++u) <span class="keyword">if</span>( !right[u] ) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span> mark);</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">match</span>(u) ) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> std:: vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) A.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">0</span>, <span class="keyword">sizeof</span> left);</span><br><span class="line">        <span class="built_in">memset</span>(right, <span class="number">0</span>, <span class="keyword">sizeof</span> right);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">init</span>(N, N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: A) <span class="keyword">if</span>( a-i &gt;= <span class="number">1</span> &amp;&amp; a-i &lt; i ) G[a-i].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">maxmatch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">            ++L, ++R;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: A) <span class="keyword">if</span>( a-L &gt;= <span class="number">1</span> &amp;&amp; a-L &lt; L ) G[a-L].<span class="built_in">push_back</span>(L);</span><br><span class="line">            ans += <span class="built_in">maxmatch</span>();</span><br><span class="line">            <span class="keyword">if</span>( L-ans &gt; N ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: A) <span class="keyword">if</span>( a-L &gt;= <span class="number">1</span> &amp;&amp; a-L &lt; L ) G[a-L].<span class="built_in">pop_back</span>();</span><br><span class="line">        right[left[L]] = <span class="number">0</span>;</span><br><span class="line">        --L; --R;</span><br><span class="line">        <span class="built_in">maxmatch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L);</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span> mark);</span><br><span class="line">        mark[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>; o &lt;= L; ++o) <span class="keyword">if</span>( !mark[o] ) &#123;</span><br><span class="line">            mark[o] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, o);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u=right[o]; !mark[u]; u=right[u]) &#123;</span><br><span class="line">                mark[u] = <span class="literal">true</span>; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, u);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N; std:: cin &gt;&gt; N;</span><br><span class="line">    hungary:: <span class="built_in">solve</span>(N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><span id="05">
**Power OJ/1740 *[圆桌问题](https://www.oj.swust.edu.cn/problem/show/1740)***
</span>
经典的二分图多重匹配问题。
- 将不同单位作为左侧点，不同圆桌作为右侧点，每个左侧点与每个右侧点连接一条容量为 1 的边
- 建立源点 $s$，并从 $s$ 向所有的左侧点引一条容量为 $cap\_i$ （第 $i$ 个单位的人数）的边
- 建立汇点 $t$，并从所有的右侧点向 $t$ 引一条容量为 $cap\_j$ （第 $j$ 张圆桌的容量）的边
跑最大流。
- 若满流，则有解，方案仅需考虑每个左侧点引出的满流边即可
- 若不能满流，则无解
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ISAP:: <span class="built_in">solve</span>(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> tot) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    s = <span class="number">0</span>; t = M+N+<span class="number">1</span>; n = M+N+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">maxflow</span>();</span><br><span class="line">    <span class="keyword">if</span>( ans &lt; tot ) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>; o &lt;= M; ++o) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[o]) &#123;</span><br><span class="line">            edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span>( e.cap &gt; <span class="number">0</span> &amp;&amp; e.cap == e.flow ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e.to-M);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">        tot += val;</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, i, val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            ISAP:: <span class="built_in">addedge</span>(i, M+j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(M+i, N+M+<span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ISAP:: <span class="built_in">solve</span>(M, N, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><span id="06">
**Power OJ/1741 *[最长递增子序列问题](https://www.oj.swust.edu.cn/problem/show/1741)***
</span>
经典的最多最长不相交路径问题。
不妨记第 $i$ 个数大小为 $A\_i$。 
为了保证每个点只使用一次，拆点。不妨假设原序列第 $i$ 个数对应点 $x\_i$，将其拆成 $x\_i$ 和 $x'\_i$。
1. 定义 $dp[i]$ 为以第 $i$ 个数为结尾的最长上升子序列的长度，$O(N^2)$ 的动态规划
2. 记最长上升子序列长度为 $ans=\max\big\lbrace dp[i] \big| 1\leqslant i\leqslant N\big\rbrace$。
  - 对于任意 $1\leqslant i\leqslant N$，从 $x\_i$ 向 $x'\_i$ 引一条容量为 1 的边（以保证第 $i$ 个数只使用一次）
  - 若 $A\_i < A\_j$ 且 $dp[i]+1=dp[j]$，则从 $x\_i'$ 向 $x\_j$ 引一条容量为 1 的边
  - 建立源点 $s$，从 $s$ 向 $\big\lbrace x\_i \big| 1\leqslant i\leqslant N$ 且 $dp[i]=1 \big\rbrace$ 引一条容量为 1 的边
  - 建立汇点 $t$，从 $\big\lbrace x'\_i \big| 1\leqslant i\leqslant N$ 且 $dp[i]=ans  \big\rbrace$ 向 $t$ 引一条容量为 1 的边
  跑最大流即可。
3. 在 2. 的基础上，仅需将从源点出发的边及到达汇点的边（不包括反向边）的容量全改为无穷即可

<p>原题描述不严谨，如果第一问答案为 2，第三问中，方案 $\big\lbrace x_1,x_N \big\rbrace$ 只能记做一次。<br>最后需要注意的是，当 $N=1$ 时，第三问要特判。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400</span>+<span class="number">10</span>;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN], in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) in[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span>( in[i] &gt; in[j] ) </span><br><span class="line">                dp[i] = std:: <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) ans = std:: <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123; </span><br><span class="line">        <span class="keyword">if</span>( dp[i] == <span class="number">1</span> ) ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, i&lt;&lt;<span class="number">1</span>, INF);</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>( dp[i] == ans ) ISAP:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, <span class="number">1</span>, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            <span class="keyword">if</span>( in[i] &lt; in[j] &amp;&amp; dp[i]+<span class="number">1</span> == dp[j] )</span><br><span class="line">                ISAP:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, j&lt;&lt;<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ISAP:: s = <span class="number">0</span>;</span><br><span class="line">    ISAP:: t = <span class="number">1</span>;</span><br><span class="line">    ISAP:: n = N+<span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ISAP:: <span class="built_in">maxflow</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ans == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e: ISAP:: edges) e.flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: ISAP:: G[<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; e = ISAP:: edges[i];</span><br><span class="line">        <span class="keyword">if</span>( e.to == <span class="number">3</span> ) &#123; </span><br><span class="line">            e.cap = INF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: ISAP:: G[N&lt;&lt;<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; e = ISAP:: edges[i];</span><br><span class="line">        <span class="keyword">if</span>( e.to == (N&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) ) &#123;</span><br><span class="line">            e.cap = INF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ISAP:: <span class="built_in">maxflow</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><span id="07">
**COGS/732 *[试题库](http://cojs.tk/cogs/problem/problem.php?pid=732)***
</span>
如 **[05](#05)**，经典的二分图多重匹配问题。
- 将每道题与其所属类型连接一条容量为 1 的边
- 建立源点 $s$，从 $s$ 向每道试题引一条容量为 1 的边
- 建立汇点 $t$，从每个类型向 $t$ 引一条容量为该类型所需要的题数的边

<p>跑最大流，仅当流量为所有类型所需要的题数总和时有解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ISAP:: <span class="built_in">solve</span>(<span class="keyword">int</span> K, <span class="keyword">int</span> N, <span class="keyword">int</span> limit) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    s = <span class="number">0</span>; t = N+K+<span class="number">1</span>; n = N+K+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">maxflow</span>() != limit ) &#123; <span class="built_in">puts</span>(<span class="string">&quot;NoSolution!&quot;</span>); <span class="keyword">return</span> ; &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>; o &lt;= K; ++o) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>, o);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[N+o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            edge&amp; e = edges[G[N+o][i]];</span><br><span class="line">            <span class="keyword">if</span>( e.to &lt;= N &amp;&amp; e.flow == <span class="number">-1</span> ) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, e.to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;testlib.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;testlib.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">int</span> K = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">        limit += val;</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(N+i, N+K+<span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">while</span>( M-- ) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">read</span>();</span><br><span class="line">            ISAP:: <span class="built_in">addedge</span>(i, N+j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ISAP:: <span class="built_in">solve</span>(K, N, limit); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><span id="08">
**Power OJ/1743 *[机器人路径规划问题](https://www.oj.swust.edu.cn/problem/show/1743)***
</span>
**暂缺**

<h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><span id="09">
**Power OJ/1744 *[方格取数问题](https://www.oj.swust.edu.cn/problem/show/1744)***
</span>
经典的二分图点权最大独立集。
将方格二染色得到二分图
- 对于左侧的点，向其对应方格的前后左右方格对应的点连接一条容量为$\infty$的边
- 建立源点 $s$，从 $s$ 向左侧的点分别引一条`容量为该点所对应的方格中的数`的边
- 建立汇点 $t$，从右侧的点分别引一条`容量为该店所对应的方格中的数`的边

<p>跑最大流，方格中的数的和 - 最大流量 即是答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> col = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>; r &lt;= row; ++r)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c &lt;= col; ++c) &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">            tot += val;</span><br><span class="line">            <span class="keyword">if</span>( (r+c) &amp; <span class="number">1</span> ) ISAP:: <span class="built_in">addedge</span>(idx, row*col+<span class="number">1</span>, val);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ISAP:: <span class="built_in">addedge</span>(<span class="number">0</span>, idx, val);</span><br><span class="line">                <span class="keyword">if</span>( c &gt; <span class="number">1</span> ) ISAP:: <span class="built_in">addedge</span>(idx, idx<span class="number">-1</span>, INF);</span><br><span class="line">                <span class="keyword">if</span>( r &gt; <span class="number">1</span> ) ISAP:: <span class="built_in">addedge</span>(idx, idx-col, INF);</span><br><span class="line">                <span class="keyword">if</span>( c &lt; col ) ISAP:: <span class="built_in">addedge</span>(idx, idx+<span class="number">1</span>, INF);</span><br><span class="line">                <span class="keyword">if</span>( r &lt; row ) ISAP:: <span class="built_in">addedge</span>(idx, idx+col, INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ISAP:: s = <span class="number">0</span>;</span><br><span class="line">    ISAP:: t = row*col + <span class="number">1</span>;</span><br><span class="line">    ISAP:: n = row*col + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - ISAP:: <span class="built_in">maxflow</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><span id="10">
**Power OJ/1745 *[餐巾计划问题](https://www.oj.swust.edu.cn/problem/show/1745)***
</span>
最小费用最大流。
设第 $i$ 天有 $A\_i$ 条脏毛巾（可以是之前的脏毛巾累积下来的），需要 $B\_i$ 条干净的毛巾。
将第 $i$ 天拆成两个点 $\alpha\_i$，$\beta\_i$。
- 建立源点 $s$
  * 从 $s$ 向 $\alpha\_i$ 引一条容量为 $B\_i$、`单位流量费用为 0`的边（表示每天会产生 $B\_i$ 条脏毛巾）
  * 从 $s$ 向 $\beta\_i$ 引一条容量为 $B\_i$（或者大于等于 $B\_i$ 皆可）、`单位流量费用为新毛巾的费用`的边（表示每天可以购买的新毛巾数）
- 建立汇点 $t$
  * 从 $\beta\_i$ 向 $t$ 引一条容量为 $B\_i$、`单位流量费用为 0` 的边（表示每天需要的干净的毛巾数）
- 如果 $i+m+1 \leqslant j$（此 OJ 本题数据有点不一样，应为 $i+m \leqslant j$），那么从 $A\_i$ 向 $B\_j$ 引一条容量为 $\infty$（大于 $\displaystyle \sum\_{k=1}^i B\_k$ 即可）、单位流量费用为 $f$ 的边（表示第 $i$ 天快洗可以提供给第 $j$ 天；这里有这样一个事实：如果第 $j+k$ 天需要用到快洗的毛巾，那么大可以将脏毛巾攒到第 $i+k$ 天快洗）
- 慢细连边类似
- 最后，对于 $i < N$，从 $A\_i$ 向 $A\_{i+1}$ 引一条容量为 $\infty$、`单位流量费用为 0` 的边（表示每天留下来的脏毛巾可以免费留到第二天洗）

<p>跑最小费用最大流即可，由于每天新毛巾可以直接供应 $B_i$ 条，因此必然可以满流。最小费用即为答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> f = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    MCMF:: <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">        MCMF:: <span class="built_in">addedge</span>(<span class="number">0</span>, i&lt;&lt;<span class="number">1</span>, val, <span class="number">0</span>);</span><br><span class="line">        MCMF:: <span class="built_in">addedge</span>(<span class="number">0</span>, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, val, p);</span><br><span class="line">        MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, <span class="number">1</span>, val, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>( i+<span class="number">1</span> &lt;= N ) MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, (i+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>( i+m &lt;= N ) MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, (i+m)&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, INF, f);</span><br><span class="line">        <span class="keyword">if</span>( i+n &lt;= N ) MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, (i+n)&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, INF, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std:: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans = MCMF:: <span class="built_in">mincostmaxflow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans.second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><span id="11">
**Power OJ/1746 *[航空路线问题](https://www.oj.swust.edu.cn/problem/show/1746)***
</span>
最大费用最大流。
其实是求两条最长的不相交路径。
- 为了保证每个城市只访问一次，需要拆点；不妨将第 $i$ 个城市拆成 $\alpha\_i$ 和 $\beta\_i$，且从 $\alpha\_i$ 向 $\beta\_i$ 引一条容量为 1，费用为 1 的边
- 如果 $i < j$ 且城市 $i$ 和 城市 $j$ 之间有直达航线，那么向 $\beta\_i$ 和 $\alpha\_j$ 连接一条容量为 1，费用为 0 的边

<p>跑最大费用最大流（只增广两次），方案根据满流边判断即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="keyword">int</span> from=<span class="number">0</span>, <span class="keyword">int</span> to=<span class="number">0</span>, <span class="keyword">int</span> cap=<span class="number">0</span>, <span class="keyword">int</span> flow=<span class="number">0</span>, <span class="keyword">int</span> cost=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap), <span class="built_in">flow</span>(flow), <span class="built_in">cost</span>(cost) &#123;&#125;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> path[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line">    std:: vector&lt;edge&gt; edges;</span><br><span class="line">    std:: vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = edges.<span class="built_in">size</span>();</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(siz);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(siz+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> std:: queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> inq[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"> </span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        inq[s] = <span class="literal">true</span>;</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; G[o].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                edge&amp; e = edges[G[o][i]];</span><br><span class="line">                <span class="keyword">if</span>( e.cap &gt; e.flow &amp;&amp; dist[e.to] &gt; dist[o]+e.cost ) &#123;</span><br><span class="line">                    dist[e.to] = dist[o] + e.cost;</span><br><span class="line">                    path[e.to] = G[o][i];</span><br><span class="line">                    <span class="keyword">if</span>( inq[e.to] ) <span class="keyword">continue</span>;</span><br><span class="line">                    inq[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inq[o] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> dist[t] != INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(std:: vector&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(o&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[o]) &#123;</span><br><span class="line">            edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span>( e.flow == <span class="number">1</span> ) <span class="built_in">DFS</span>(ans, e.to|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(std:: string* in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> std:: vector&lt;<span class="keyword">int</span>&gt; ans[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>( !<span class="built_in">SPFA</span>() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o = t; o != s;) &#123;</span><br><span class="line">                edges[path[o]].flow += <span class="number">1</span>;</span><br><span class="line">                edges[path[o]^<span class="number">1</span>].flow -= <span class="number">1</span>;</span><br><span class="line">                o = edges[path[o]].from;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[<span class="number">3</span>]) &#123;</span><br><span class="line">            edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span>( e.flow == <span class="number">2</span> ) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">                std:: cout &lt;&lt; in[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; in[t&gt;&gt;<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; in[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">0</span>].<span class="built_in">push_back</span>(s&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        ans[<span class="number">1</span>].<span class="built_in">push_back</span>(s&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: G[<span class="number">3</span>]) &#123;</span><br><span class="line">            edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span>( e.flow == <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="built_in">DFS</span>(ans[idx++], e.to|<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">1</span>].<span class="built_in">pop_back</span>();</span><br><span class="line">        std:: <span class="built_in">reverse</span>(ans[<span class="number">1</span>].<span class="built_in">begin</span>(), ans[<span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[<span class="number">0</span>].<span class="built_in">size</span>() + ans[<span class="number">1</span>].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: ans[<span class="number">0</span>]) std:: cout &lt;&lt; in[a] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: ans[<span class="number">1</span>]) std:: cout &lt;&lt; in[a] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> ) positive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        s = s*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> positive? s: -s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">std:: unordered_map&lt;std:: string, <span class="keyword">int</span>&gt; ump;</span><br><span class="line">std:: string in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        std:: cin &gt;&gt; in[i];</span><br><span class="line">        ump[in[i]] = i;</span><br><span class="line">        <span class="keyword">if</span>( i == <span class="number">1</span> || i == N ) MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> MCMF:: <span class="built_in">addedge</span>(i&lt;&lt;<span class="number">1</span>, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        std:: string s, t;</span><br><span class="line">        std:: cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="keyword">int</span> ids = ump[s];</span><br><span class="line">        <span class="keyword">int</span> idt = ump[t];</span><br><span class="line">        <span class="keyword">if</span>( ids &gt; idt ) std:: <span class="built_in">swap</span>(ids, idt);</span><br><span class="line">        <span class="keyword">if</span>( ids == <span class="number">1</span> &amp;&amp; idt == N ) MCMF:: <span class="built_in">addedge</span>(ids&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, idt&lt;&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> MCMF:: <span class="built_in">addedge</span>(ids&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, idt&lt;&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MCMF:: s = <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    MCMF:: t = N&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( !MCMF:: <span class="built_in">solve</span>(in) ) <span class="built_in">puts</span>(<span class="string">&quot;No Solution!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><span id="12">
**Power OJ/1747 *[软件补丁问题](https://www.oj.swust.edu.cn/problem/show/1747)***
</span>
更像一个状压 $dp$。
抽象出图的结构，跑最短路即可。
定义 $s$ 为当前软件的错误状态，如果 $s$ 中包含 $B1[i]$ 的所有错误，且不包含 $B2[i]$ 中的所有错误，那么存在一条从 $s$ 到 $s-F1[i]+F2[i]$（这里的‘-’指集合运算），且花费为 $cost[i]$ 的边。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> solve &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> B1, B2;</span><br><span class="line">        <span class="keyword">int</span> F1, F2;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        <span class="built_in">node</span>(<span class="keyword">int</span> B1=<span class="number">0</span>, <span class="keyword">int</span> B2=<span class="number">0</span>, <span class="keyword">int</span> F1=<span class="number">0</span>, <span class="keyword">int</span> F2=<span class="number">0</span>, <span class="keyword">int</span> cost=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">B1</span>(B1), <span class="built_in">B2</span>(B2), <span class="built_in">F1</span>(F1), <span class="built_in">F2</span>(F2), <span class="built_in">cost</span>(cost) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line">    std:: vector&lt;node&gt; nodes;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i] == <span class="string">&#x27;+&#x27;</span> ) x |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( s[i] == <span class="string">&#x27;-&#x27;</span> ) y |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> inq[MAXN];</span><br><span class="line">        <span class="keyword">static</span> std:: queue&lt;<span class="keyword">int</span>&gt; Q; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line">        inq[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e: nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span>( (o&amp;e.B1) == e.B1 &amp;&amp; (o&amp;e.B2) == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u = (o&amp;e.F1) | e.F2;</span><br><span class="line">                    <span class="keyword">if</span>( dist[u] &gt; dist[o]+e.cost ) &#123;</span><br><span class="line">                        dist[u] = dist[o]+e.cost;</span><br><span class="line">                        <span class="keyword">if</span>( !inq[u] ) &#123;</span><br><span class="line">                            inq[u] = <span class="literal">true</span>;</span><br><span class="line">                            Q.<span class="built_in">push</span>(u);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inq[o] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dist[t] != INF? dist[t]: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> ) positive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c=<span class="built_in">getchar</span>())</span><br><span class="line">        s = s*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> positive? s: -s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> B1, B2, F1, F2, cost, re;</span><br><span class="line">    <span class="keyword">char</span> in[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    re = (<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        cost = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in);</span><br><span class="line">        solve:: <span class="built_in">update</span>(in, B1, B2);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in);</span><br><span class="line">        solve:: <span class="built_in">update</span>(in, F2, F1);</span><br><span class="line">        F1 = re^F1;</span><br><span class="line">        solve:: nodes.<span class="built_in">push_back</span>(solve:: <span class="built_in">node</span>(B1, B2, F1, F2, cost));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solve:: s = re;</span><br><span class="line">    solve:: t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solve:: <span class="built_in">SPFA</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br></pre></td></tr></table></figure>

<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table>
<thead>
<tr>
<th align="center">problems</th>
<th align="center">categories</th>
<th align="center">solution</th>
<th align="center">code</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1736">Power OJ/1736</a></strong></em></td>
<td align="center">二分图最大匹配</td>
<td align="center"><em><strong><a href="#01">01</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/01.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1737">Power OJ/1737</a></strong></em></td>
<td align="center">最大权闭合图</td>
<td align="center"><em><strong><a href="#02">02</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/02.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1738">Power OJ/1738</a></strong></em></td>
<td align="center">最小路径覆盖</td>
<td align="center"><em><strong><a href="#03">03</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/03.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1739">Power OJ/1739</a></strong></em></td>
<td align="center">最小路径覆盖</td>
<td align="center"><em><strong><a href="#04">04</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/04.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1740">Power OJ/1740</a></strong></em></td>
<td align="center">二分图多重匹配</td>
<td align="center"><em><strong><a href="#05">05</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/05.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1741">Power OJ/1741</a></strong></em></td>
<td align="center">最多最长不相交路径</td>
<td align="center"><em><strong><a href="#06">06</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/06.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="http://cojs.tk/cogs/problem/problem.php?pid=732">COGS/732</a></strong></em></td>
<td align="center">二分图多重匹配</td>
<td align="center"><em><strong><a href="#07">07</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/07.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1743">Power OJ/1743</a></strong></em></td>
<td align="center"><strong>暂缺</strong></td>
<td align="center"><em><strong><a href="#08">08</a></strong></em></td>
<td align="center"><strong>暂缺</strong></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1744">Power OJ/1744</a></strong></em></td>
<td align="center">二分图点权最大独立集</td>
<td align="center"><em><strong><a href="#09">09</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/09.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1745">Power OJ/1745</a></strong></em></td>
<td align="center">最小费用最大流（难在建图）</td>
<td align="center"><em><strong><a href="#10">10</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/10.cpp" title="Code">Code</a></strong></em></td>
</tr>
<tr>
<td align="center"><em><strong><a target="_blank" rel="noopener" href="https://www.oj.swust.edu.cn/problem/show/1746">Power OJ/1746</a></strong></em></td>
<td align="center">最大费用最大流</td>
<td align="center"><em><strong><a href="#11">11</a></strong></em></td>
<td align="center"><em><strong><a href="/acm/special-topic/graph-theory/network-flow/11.cpp" title="Code">Code</a></strong></em></td>
</tr>
</tbody></table>
</div></div><nav id="article-nav"><a class="article-nav-link-wrap" id="article-nav-newer" href="/study/math/combinatorial-game/SG/"><strong class="article-nav-caption"></strong><div class="article-nav-title">组合游戏基础之 SG 函数和 SG 定理</div></a><a class="article-nav-link-wrap" id="article-nav-older" href="/study/codding/graph-theory/network-flow/maximum-weight-Closure-of-a-Graph/"><div class="article-nav-title">网络流基础之最大权闭合图</div><strong class="article-nav-caption">></strong></a></nav></article><div id="gitalk-container"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"/><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  ...JSON.parse('{"clientID":"be8f64bb869585cb410e","clientSecret":"8c4cb258aecb72ccc1af7aa76380104cace8f816","repo":"LittleClown.github.io","owner":"littleclown","admin":["littleclown","lemon-clown"],"id":"window.location.pathname","distractionFreeMode":false}'),
})

gitalk.render('gitalk-container')</script></div></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left">&copy; 2021-06-13 笑着哭的小丑</div><div class="footer-right">青春是低吟浅唱、你是我学不会的歌、</div></div></div></footer></div>
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
<script>var yiliaConfig = {
  fancybox:     true,
  mathjax:      true,
  animate:      true,
  isHome:       false,
  isPost:       true,
  isArchive:    false,
  isTag:        false,
  isCategory:   false,
  open_in_new:  false,
}
</script><!-- by SparklingWind-->
<script src="/js/clipboard.min.js"></script>

<script src="/js/require.js"></script>
<script src="/js/jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<div id="totop"><img src="/img/scrollup.png" title="返回顶部"></div><div id="goback"><img src="/img/goback.png" title="返回上一位置"></div><!-- by SparklingWind--><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  showMathMenu: false,
  skipStartupTypeset: true,
  showProcessingMessage: false,
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  TeX: {
    equationNumbers: {
      autoNumber: 'AMS',
    },
  },
  messageStyle: 'none',
  SVG: {
    blacker: 1
  },
  styles: {
    '.MathJax_Display': {
      'user-select': 'none',
    },
  },
});

MathJax.Hub.Queue(['Typeset', MathJax.Hub, document.body])</script><!-- by SparklingWind--><script>var cnzz_protocol = ("https:" == document.location.protocol? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1259020930'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1259020930' type='text/javascript'%3E%3C/script%3E"))</script><!-- by SparklingWind--></div></body></html>